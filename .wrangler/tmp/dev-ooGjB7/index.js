var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type2) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type2) {
        return this._entries.filter((e) => e.name === name && (!type2 || e.entryType === type2));
      }
      getEntriesByType(type2) {
        return this._entries.filter((e) => e.entryType === type2);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      emitWarning(warning, type2, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type2 ? `${type2}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return "";
      }
      get versions() {
        return {};
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      ref() {
      }
      unref() {
      }
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      mainModule = void 0;
      domain = void 0;
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/apollo-server-env/dist/index.browser.js
var require_index_browser = __commonJS({
  "node_modules/apollo-server-env/dist/index.browser.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLSearchParams = exports2.URL = exports2.Headers = exports2.Response = exports2.Request = exports2.fetch = void 0;
    if (!global) {
      global = self;
    }
    var { fetch: fetch2, Request, Response: Response2, Headers: Headers2, URL: URL2, URLSearchParams } = global;
    exports2.fetch = fetch2;
    exports2.Request = Request;
    exports2.Response = Response2;
    exports2.Headers = Headers2;
    exports2.URL = URL2;
    exports2.URLSearchParams = URLSearchParams;
    exports2.fetch = fetch2 = fetch2.bind(global);
    if (!global.process) {
      global.process = {};
    }
    if (!global.process.env) {
      global.process.env = {
        NODE_ENV: typeof app !== "undefined" ? app.env : "production"
      };
    }
    if (!global.process.version) {
      global.process.version = "";
    }
    if (!global.process.hrtime) {
      global.process.hrtime = /* @__PURE__ */ __name(function hrtime4(previousTimestamp) {
        var clockTime = Date.now() * 1e-3;
        var seconds = Math.floor(clockTime);
        var nanoseconds = Math.floor(clockTime % 1 * 1e9);
        if (previousTimestamp) {
          seconds = seconds - previousTimestamp[0];
          nanoseconds = nanoseconds - previousTimestamp[1];
          if (nanoseconds < 0) {
            seconds--;
            nanoseconds += 1e9;
          }
        }
        return [seconds, nanoseconds];
      }, "hrtime");
    }
    if (!global.os) {
      global.os = {};
    }
  }
});

// node_modules/graphql/version.js
var require_version = __commonJS({
  "node_modules/graphql/version.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.versionInfo = exports2.version = void 0;
    var version3 = "16.11.0";
    exports2.version = version3;
    var versionInfo = Object.freeze({
      major: 16,
      minor: 11,
      patch: 0,
      preReleaseTag: null
    });
    exports2.versionInfo = versionInfo;
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/graphql/jsutils/devAssert.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.devAssert = devAssert;
    function devAssert(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
    __name(devAssert, "devAssert");
  }
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/graphql/jsutils/isPromise.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPromise = isPromise;
    function isPromise(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
    __name(isPromise, "isPromise");
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isObjectLike = isObjectLike;
    function isObjectLike(value) {
      return typeof value == "object" && value !== null;
    }
    __name(isObjectLike, "isObjectLike");
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS({
  "node_modules/graphql/jsutils/invariant.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.invariant = invariant;
    function invariant(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(
          message != null ? message : "Unexpected invariant triggered."
        );
      }
    }
    __name(invariant, "invariant");
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/graphql/language/location.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocation = getLocation;
    var _invariant = require_invariant();
    var LineRegExp = /\r\n|[\n\r]/g;
    function getLocation(source, position) {
      let lastLineStart = 0;
      let line = 1;
      for (const match of source.body.matchAll(LineRegExp)) {
        typeof match.index === "number" || (0, _invariant.invariant)(false);
        if (match.index >= position) {
          break;
        }
        lastLineStart = match.index + match[0].length;
        line += 1;
      }
      return {
        line,
        column: position + 1 - lastLineStart
      };
    }
    __name(getLocation, "getLocation");
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/graphql/language/printLocation.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printLocation = printLocation;
    exports2.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(
        location.source,
        (0, _location.getLocation)(location.source, location.start)
      );
    }
    __name(printLocation, "printLocation");
    function printSourceLocation(source, sourceLocation) {
      const firstLineColumnOffset = source.locationOffset.column - 1;
      const body = "".padStart(firstLineColumnOffset) + source.body;
      const lineIndex = sourceLocation.line - 1;
      const lineOffset = source.locationOffset.line - 1;
      const lineNum = sourceLocation.line + lineOffset;
      const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      const columnNum = sourceLocation.column + columnOffset;
      const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
      const lines = body.split(/\r\n|[\n\r]/g);
      const locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        const subLineIndex = Math.floor(columnNum / 80);
        const subLineColumnNum = columnNum % 80;
        const subLines = [];
        for (let i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([
          [`${lineNum} |`, subLines[0]],
          ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
          ["|", "^".padStart(subLineColumnNum)],
          ["|", subLines[subLineIndex + 1]]
        ]);
      }
      return locationStr + printPrefixedLines([
        // Lines specified like this: ["prefix", "string"],
        [`${lineNum - 1} |`, lines[lineIndex - 1]],
        [`${lineNum} |`, locationLine],
        ["|", "^".padStart(columnNum)],
        [`${lineNum + 1} |`, lines[lineIndex + 1]]
      ]);
    }
    __name(printSourceLocation, "printSourceLocation");
    function printPrefixedLines(lines) {
      const existingLines = lines.filter(([_, line]) => line !== void 0);
      const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
      return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
    }
    __name(printPrefixedLines, "printPrefixedLines");
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/graphql/error/GraphQLError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLError = void 0;
    exports2.formatError = formatError;
    exports2.printError = printError;
    var _isObjectLike = require_isObjectLike();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function toNormalizedOptions(args) {
      const firstArg = args[0];
      if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
        return {
          nodes: firstArg,
          source: args[1],
          positions: args[2],
          path: args[3],
          originalError: args[4],
          extensions: args[5]
        };
      }
      return firstArg;
    }
    __name(toNormalizedOptions, "toNormalizedOptions");
    var GraphQLError = class _GraphQLError extends Error {
      static {
        __name(this, "GraphQLError");
      }
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
          (loc) => (0, _location.getLocation)(loc.source, loc.start)
        );
        const originalExtensions = (0, _isObjectLike.isObjectLike)(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
    exports2.GraphQLError = GraphQLError;
    function undefinedIfEmpty(array) {
      return array === void 0 || array.length === 0 ? void 0 : array;
    }
    __name(undefinedIfEmpty, "undefinedIfEmpty");
    function printError(error3) {
      return error3.toString();
    }
    __name(printError, "printError");
    function formatError(error3) {
      return error3.toJSON();
    }
    __name(formatError, "formatError");
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/graphql/error/syntaxError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
        source,
        positions: [position]
      });
    }
    __name(syntaxError, "syntaxError");
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/graphql/language/ast.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.QueryDocumentKeys = exports2.OperationTypeNode = exports2.Location = void 0;
    exports2.isNode = isNode;
    var Location = class {
      static {
        __name(this, "Location");
      }
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    exports2.Location = Location;
    var Token = class {
      static {
        __name(this, "Token");
      }
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    exports2.Token = Token;
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports2.QueryDocumentKeys = QueryDocumentKeys;
    var kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
      const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
      return typeof maybeKind === "string" && kindValues.has(maybeKind);
    }
    __name(isNode, "isNode");
    var OperationTypeNode;
    exports2.OperationTypeNode = OperationTypeNode;
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (exports2.OperationTypeNode = OperationTypeNode = {}));
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/graphql/language/directiveLocation.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    exports2.DirectiveLocation = DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (exports2.DirectiveLocation = DirectiveLocation = {}));
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "node_modules/graphql/language/kinds.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Kind = void 0;
    var Kind;
    exports2.Kind = Kind;
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (exports2.Kind = Kind = {}));
  }
});

// node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS({
  "node_modules/graphql/language/characterClasses.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isDigit = isDigit;
    exports2.isLetter = isLetter;
    exports2.isNameContinue = isNameContinue;
    exports2.isNameStart = isNameStart;
    exports2.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(code) {
      return code === 9 || code === 32;
    }
    __name(isWhiteSpace, "isWhiteSpace");
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    __name(isDigit, "isDigit");
    function isLetter(code) {
      return code >= 97 && code <= 122 || // A-Z
      code >= 65 && code <= 90;
    }
    __name(isLetter, "isLetter");
    function isNameStart(code) {
      return isLetter(code) || code === 95;
    }
    __name(isNameStart, "isNameStart");
    function isNameContinue(code) {
      return isLetter(code) || isDigit(code) || code === 95;
    }
    __name(isNameContinue, "isNameContinue");
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/graphql/language/blockString.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dedentBlockStringLines = dedentBlockStringLines;
    exports2.isPrintableAsBlockString = isPrintableAsBlockString;
    exports2.printBlockString = printBlockString;
    var _characterClasses = require_characterClasses();
    function dedentBlockStringLines(lines) {
      var _firstNonEmptyLine2;
      let commonIndent = Number.MAX_SAFE_INTEGER;
      let firstNonEmptyLine = null;
      let lastNonEmptyLine = -1;
      for (let i = 0; i < lines.length; ++i) {
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent = leadingWhitespace(line);
        if (indent === line.length) {
          continue;
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent < commonIndent) {
          commonIndent = indent;
        }
      }
      return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
        (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
        lastNonEmptyLine + 1
      );
    }
    __name(dedentBlockStringLines, "dedentBlockStringLines");
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
        ++i;
      }
      return i;
    }
    __name(leadingWhitespace, "leadingWhitespace");
    function isPrintableAsBlockString(value) {
      if (value === "") {
        return true;
      }
      let isEmptyLine = true;
      let hasIndent = false;
      let hasCommonIndent = true;
      let seenNonEmptyLine = false;
      for (let i = 0; i < value.length; ++i) {
        switch (value.codePointAt(i)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          // Has non-printable characters
          case 13:
            return false;
          // Has \r or \r\n which will be replaced as \n
          case 10:
            if (isEmptyLine && !seenNonEmptyLine) {
              return false;
            }
            seenNonEmptyLine = true;
            isEmptyLine = true;
            hasIndent = false;
            break;
          case 9:
          //   \t
          case 32:
            hasIndent || (hasIndent = isEmptyLine);
            break;
          default:
            hasCommonIndent && (hasCommonIndent = hasIndent);
            isEmptyLine = false;
        }
      }
      if (isEmptyLine) {
        return false;
      }
      if (hasCommonIndent && seenNonEmptyLine) {
        return false;
      }
      return true;
    }
    __name(isPrintableAsBlockString, "isPrintableAsBlockString");
    function printBlockString(value, options) {
      const escapedValue = value.replace(/"""/g, '\\"""');
      const lines = escapedValue.split(/\r\n|[\n\r]/g);
      const isSingleLine = lines.length === 1;
      const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
        (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
      );
      const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
      const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
      const hasTrailingSlash = value.endsWith("\\");
      const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
      const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
      (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
      let result = "";
      const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
      if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
      }
      result += escapedValue;
      if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
      }
      return '"""' + result + '"""';
    }
    __name(printBlockString, "printBlockString");
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/graphql/language/tokenKind.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenKind = void 0;
    var TokenKind;
    exports2.TokenKind = TokenKind;
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (exports2.TokenKind = TokenKind = {}));
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/graphql/language/lexer.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Lexer = void 0;
    exports2.isPunctuatorTokenKind = isPunctuatorTokenKind;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _blockString = require_blockString();
    var _characterClasses = require_characterClasses();
    var _tokenKind = require_tokenKind();
    var Lexer = class {
      static {
        __name(this, "Lexer");
      }
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new _ast.Token(
          _tokenKind.TokenKind.SOF,
          0,
          0,
          0,
          0
        );
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      }
    };
    exports2.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    __name(isPunctuatorTokenKind, "isPunctuatorTokenKind");
    function isUnicodeScalarValue(code) {
      return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
    }
    __name(isUnicodeScalarValue, "isUnicodeScalarValue");
    function isSupplementaryCodePoint(body, location) {
      return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
    }
    __name(isSupplementaryCodePoint, "isSupplementaryCodePoint");
    function isLeadingSurrogate(code) {
      return code >= 55296 && code <= 56319;
    }
    __name(isLeadingSurrogate, "isLeadingSurrogate");
    function isTrailingSurrogate(code) {
      return code >= 56320 && code <= 57343;
    }
    __name(isTrailingSurrogate, "isTrailingSurrogate");
    function printCodePointAt(lexer, location) {
      const code = lexer.source.body.codePointAt(location);
      if (code === void 0) {
        return _tokenKind.TokenKind.EOF;
      } else if (code >= 32 && code <= 126) {
        const char = String.fromCodePoint(code);
        return char === '"' ? `'"'` : `"${char}"`;
      }
      return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
    }
    __name(printCodePointAt, "printCodePointAt");
    function createToken(lexer, kind, start, end, value) {
      const line = lexer.line;
      const col = 1 + start - lexer.lineStart;
      return new _ast.Token(kind, start, end, line, col, value);
    }
    __name(createToken, "createToken");
    function readNextToken(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        switch (code) {
          // Ignored ::
          //   - UnicodeBOM
          //   - WhiteSpace
          //   - LineTerminator
          //   - Comment
          //   - Comma
          //
          // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
          //
          // WhiteSpace ::
          //   - "Horizontal Tab (U+0009)"
          //   - "Space (U+0020)"
          //
          // Comma :: ,
          case 65279:
          // <BOM>
          case 9:
          // \t
          case 32:
          // <space>
          case 44:
            ++position;
            continue;
          // LineTerminator ::
          //   - "New Line (U+000A)"
          //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
          //   - "Carriage Return (U+000D)" "New Line (U+000A)"
          case 10:
            ++position;
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 13:
            if (body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          // Comment
          case 35:
            return readComment(lexer, position);
          // Token ::
          //   - Punctuator
          //   - Name
          //   - IntValue
          //   - FloatValue
          //   - StringValue
          //
          // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
          case 33:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BANG,
              position,
              position + 1
            );
          case 36:
            return createToken(
              lexer,
              _tokenKind.TokenKind.DOLLAR,
              position,
              position + 1
            );
          case 38:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AMP,
              position,
              position + 1
            );
          case 40:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_L,
              position,
              position + 1
            );
          case 41:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_R,
              position,
              position + 1
            );
          case 46:
            if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
              return createToken(
                lexer,
                _tokenKind.TokenKind.SPREAD,
                position,
                position + 3
              );
            }
            break;
          case 58:
            return createToken(
              lexer,
              _tokenKind.TokenKind.COLON,
              position,
              position + 1
            );
          case 61:
            return createToken(
              lexer,
              _tokenKind.TokenKind.EQUALS,
              position,
              position + 1
            );
          case 64:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AT,
              position,
              position + 1
            );
          case 91:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_L,
              position,
              position + 1
            );
          case 93:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_R,
              position,
              position + 1
            );
          case 123:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_L,
              position,
              position + 1
            );
          case 124:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PIPE,
              position,
              position + 1
            );
          case 125:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_R,
              position,
              position + 1
            );
          // StringValue
          case 34:
            if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
              return readBlockString(lexer, position);
            }
            return readString(lexer, position);
        }
        if ((0, _characterClasses.isDigit)(code) || code === 45) {
          return readNumber(lexer, position, code);
        }
        if ((0, _characterClasses.isNameStart)(code)) {
          return readName(lexer, position);
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
        );
      }
      return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
    }
    __name(readNextToken, "readNextToken");
    function readComment(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.COMMENT,
        start,
        position,
        body.slice(start + 1, position)
      );
    }
    __name(readComment, "readComment");
    function readNumber(lexer, start, firstCode) {
      const body = lexer.source.body;
      let position = start;
      let code = firstCode;
      let isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if ((0, _characterClasses.isDigit)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, unexpected digit after 0: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      } else {
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
      return createToken(
        lexer,
        isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
        start,
        position,
        body.slice(start, position)
      );
    }
    __name(readNumber, "readNumber");
    function readDigits(lexer, start, firstCode) {
      if (!(0, _characterClasses.isDigit)(firstCode)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          start,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            start
          )}.`
        );
      }
      const body = lexer.source.body;
      let position = start + 1;
      while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
        ++position;
      }
      return position;
    }
    __name(readDigits, "readDigits");
    function readString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      let chunkStart = position;
      let value = "";
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return createToken(
            lexer,
            _tokenKind.TokenKind.STRING,
            start,
            position + 1,
            value
          );
        }
        if (code === 92) {
          value += body.slice(chunkStart, position);
          const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
          value += escape.value;
          position += escape.size;
          chunkStart = position;
          continue;
        }
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    __name(readString, "readString");
    function readEscapedUnicodeVariableWidth(lexer, position) {
      const body = lexer.source.body;
      let point = 0;
      let size = 3;
      while (size < 12) {
        const code = body.charCodeAt(position + size++);
        if (code === 125) {
          if (size < 5 || !isUnicodeScalarValue(point)) {
            break;
          }
          return {
            value: String.fromCodePoint(point),
            size
          };
        }
        point = point << 4 | readHexDigit(code);
        if (point < 0) {
          break;
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(
          position,
          position + size
        )}".`
      );
    }
    __name(readEscapedUnicodeVariableWidth, "readEscapedUnicodeVariableWidth");
    function readEscapedUnicodeFixedWidth(lexer, position) {
      const body = lexer.source.body;
      const code = read16BitHexCode(body, position + 2);
      if (isUnicodeScalarValue(code)) {
        return {
          value: String.fromCodePoint(code),
          size: 6
        };
      }
      if (isLeadingSurrogate(code)) {
        if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
          const trailingCode = read16BitHexCode(body, position + 8);
          if (isTrailingSurrogate(trailingCode)) {
            return {
              value: String.fromCodePoint(code, trailingCode),
              size: 12
            };
          }
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
      );
    }
    __name(readEscapedUnicodeFixedWidth, "readEscapedUnicodeFixedWidth");
    function read16BitHexCode(body, position) {
      return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
    }
    __name(read16BitHexCode, "read16BitHexCode");
    function readHexDigit(code) {
      return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
    }
    __name(readHexDigit, "readHexDigit");
    function readEscapedCharacter(lexer, position) {
      const body = lexer.source.body;
      const code = body.charCodeAt(position + 1);
      switch (code) {
        case 34:
          return {
            value: '"',
            size: 2
          };
        case 92:
          return {
            value: "\\",
            size: 2
          };
        case 47:
          return {
            value: "/",
            size: 2
          };
        case 98:
          return {
            value: "\b",
            size: 2
          };
        case 102:
          return {
            value: "\f",
            size: 2
          };
        case 110:
          return {
            value: "\n",
            size: 2
          };
        case 114:
          return {
            value: "\r",
            size: 2
          };
        case 116:
          return {
            value: "	",
            size: 2
          };
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid character escape sequence: "${body.slice(
          position,
          position + 2
        )}".`
      );
    }
    __name(readEscapedCharacter, "readEscapedCharacter");
    function readBlockString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let lineStart = lexer.lineStart;
      let position = start + 3;
      let chunkStart = position;
      let currentLine = "";
      const blockLines = [];
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          const token = createToken(
            lexer,
            _tokenKind.TokenKind.BLOCK_STRING,
            start,
            position + 3,
            // Return a string of the lines joined with U+000A.
            (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
          );
          lexer.line += blockLines.length - 1;
          lexer.lineStart = lineStart;
          return token;
        }
        if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          currentLine += body.slice(chunkStart, position);
          chunkStart = position + 1;
          position += 4;
          continue;
        }
        if (code === 10 || code === 13) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          if (code === 13 && body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          currentLine = "";
          chunkStart = position;
          lineStart = position;
          continue;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    __name(readBlockString, "readBlockString");
    function readName(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if ((0, _characterClasses.isNameContinue)(code)) {
          ++position;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.NAME,
        start,
        position,
        body.slice(start, position)
      );
    }
    __name(readName, "readName");
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/graphql/jsutils/inspect.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.inspect = inspect2;
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    function inspect2(value) {
      return formatValue(value, []);
    }
    __name(inspect2, "inspect");
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    __name(formatValue, "formatValue");
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    __name(formatObjectValue, "formatObjectValue");
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    __name(isJSONable, "isJSONable");
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(
        ([key, value]) => key + ": " + formatValue(value, seenValues)
      );
      return "{ " + properties.join(", ") + " }";
    }
    __name(formatObject, "formatObject");
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = Math.min(MAX_ARRAY_LENGTH, array.length);
      const remaining = array.length - len;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    __name(formatArray, "formatArray");
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
    __name(getObjectTag, "getObjectTag");
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/graphql/jsutils/instanceOf.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceOf = void 0;
    var _inspect = require_inspect();
    var isProduction = globalThis.process && // eslint-disable-next-line no-undef
    false;
    var instanceOf = (
      /* c8 ignore next 6 */
      // FIXME: https://github.com/graphql/graphql-js/issues/2317
      isProduction ? /* @__PURE__ */ __name(function instanceOf2(value, constructor) {
        return value instanceof constructor;
      }, "instanceOf") : /* @__PURE__ */ __name(function instanceOf2(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = (
            // We still need to support constructor's name to detect conflicts with older versions of this library.
            Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
          );
          if (className === valueClassName) {
            const stringifiedValue = (0, _inspect.inspect)(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      }, "instanceOf")
    );
    exports2.instanceOf = instanceOf;
  }
});

// node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/graphql/language/source.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Source = void 0;
    exports2.isSource = isSource;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var Source = class {
      static {
        __name(this, "Source");
      }
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || (0, _devAssert.devAssert)(
          false,
          `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
        );
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
    exports2.Source = Source;
    function isSource(source) {
      return (0, _instanceOf.instanceOf)(source, Source);
    }
    __name(isSource, "isSource");
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/graphql/language/parser.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    exports2.parse = parse;
    exports2.parseConstValue = parseConstValue;
    exports2.parseType = parseType;
    exports2.parseValue = parseValue;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function parse(source, options) {
      const parser = new Parser(source, options);
      const document = parser.parseDocument();
      Object.defineProperty(document, "tokenCount", {
        enumerable: false,
        value: parser.tokenCount
      });
      return document;
    }
    __name(parse, "parse");
    function parseValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    __name(parseValue, "parseValue");
    function parseConstValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseConstValueLiteral();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    __name(parseConstValue, "parseConstValue");
    function parseType(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const type2 = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type2;
    }
    __name(parseType, "parseType");
    var Parser = class {
      static {
        __name(this, "Parser");
      }
      constructor(source, options = {}) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      get tokenCount() {
        return this._tokenCounter;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(_tokenKind.TokenKind.NAME);
        return this.node(token, {
          kind: _kinds.Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(
            _tokenKind.TokenKind.SOF,
            this.parseDefinition,
            _tokenKind.TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: _ast.OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return _ast.OperationTypeNode.QUERY;
          case "mutation":
            return _ast.OperationTypeNode.MUTATION;
          case "subscription":
            return _ast.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseVariableDefinition,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return this.node(start, {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseSelection,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          item,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.INT,
              value: token.value
            });
          case _tokenKind.TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.FLOAT,
              value: token.value
            });
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: _kinds.Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: _kinds.Kind.ENUM,
                  value: token.value
                });
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(_tokenKind.TokenKind.DOLLAR);
              if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw (0, _syntaxError.syntaxError)(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = /* @__PURE__ */ __name(() => this.parseValueLiteral(isConst), "item");
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.LIST,
          values: this.any(
            _tokenKind.TokenKind.BRACKET_L,
            item,
            _tokenKind.TokenKind.BRACKET_R
          )
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = /* @__PURE__ */ __name(() => this.parseObjectField(isConst), "item");
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(
            _tokenKind.TokenKind.BRACE_L,
            item,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type2;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type2 = this.node(start, {
            kind: _kinds.Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type2 = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return this.node(start, {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type: type2
          });
        }
        return type2;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type2 = this.parseNamedType();
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type: type2
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseFieldDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type2 = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type: type2,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type2 = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type: type2,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types3 = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types: types3
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types3 = this.parseUnionMemberTypes();
        if (directives.length === 0 && types3.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types: types3
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(
          _tokenKind.TokenKind.PIPE,
          this.parseDirectiveLocation
        );
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(
          _directiveLocation.DirectiveLocation,
          name.value
        )) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new _ast.Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          ++this._tokenCounter;
          if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
    exports2.Parser = Parser;
    function getTokenDesc(token) {
      const value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
    }
    __name(getTokenDesc, "getTokenDesc");
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
    }
    __name(getTokenKindDesc, "getTokenKindDesc");
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "node_modules/graphql/jsutils/didYouMean.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.didYouMean = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
      let message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      const suggestions = suggestionsArg.map((x) => `"${x}"`);
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      const selected = suggestions.slice(0, MAX_SUGGESTIONS);
      const lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
    __name(didYouMean, "didYouMean");
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "node_modules/graphql/jsutils/identityFunc.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.identityFunc = identityFunc;
    function identityFunc(x) {
      return x;
    }
    __name(identityFunc, "identityFunc");
  }
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "node_modules/graphql/jsutils/keyMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyMap = keyMap;
    function keyMap(list, keyFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = item;
      }
      return result;
    }
    __name(keyMap, "keyMap");
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "node_modules/graphql/jsutils/keyValMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyValMap = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = valFn(item);
      }
      return result;
    }
    __name(keyValMap, "keyValMap");
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "node_modules/graphql/jsutils/mapValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapValue = mapValue;
    function mapValue(map, fn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map)) {
        result[key] = fn(map[key], key);
      }
      return result;
    }
    __name(mapValue, "mapValue");
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "node_modules/graphql/jsutils/naturalCompare.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.naturalCompare = naturalCompare;
    function naturalCompare(aStr, bStr) {
      let aIndex = 0;
      let bIndex = 0;
      while (aIndex < aStr.length && bIndex < bStr.length) {
        let aChar = aStr.charCodeAt(aIndex);
        let bChar = bStr.charCodeAt(bIndex);
        if (isDigit(aChar) && isDigit(bChar)) {
          let aNum = 0;
          do {
            ++aIndex;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIndex);
          } while (isDigit(aChar) && aNum > 0);
          let bNum = 0;
          do {
            ++bIndex;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIndex);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIndex;
          ++bIndex;
        }
      }
      return aStr.length - bStr.length;
    }
    __name(naturalCompare, "naturalCompare");
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
    __name(isDigit, "isDigit");
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "node_modules/graphql/jsutils/suggestionList.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.suggestionList = suggestionList;
    var _naturalCompare = require_naturalCompare();
    function suggestionList(input, options) {
      const optionsByDistance = /* @__PURE__ */ Object.create(null);
      const lexicalDistance = new LexicalDistance(input);
      const threshold = Math.floor(input.length * 0.4) + 1;
      for (const option of options) {
        const distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort((a, b) => {
        const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
      });
    }
    __name(suggestionList, "suggestionList");
    var LexicalDistance = class {
      static {
        __name(this, "LexicalDistance");
      }
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              // delete
              currentRow[j - 1] + 1,
              // insert
              upRow[j - 1] + cost
              // substitute
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
    function stringToArray(str) {
      const strLength = str.length;
      const array = new Array(strLength);
      for (let i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
    __name(stringToArray, "stringToArray");
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "node_modules/graphql/jsutils/toObjMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toObjMap = toObjMap;
    function toObjMap(obj) {
      if (obj == null) {
        return /* @__PURE__ */ Object.create(null);
      }
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      const map = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        map[key] = value;
      }
      return map;
    }
    __name(toObjMap, "toObjMap");
  }
});

// node_modules/graphql/language/printString.js
var require_printString = __commonJS({
  "node_modules/graphql/language/printString.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printString = printString;
    function printString(str) {
      return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    __name(printString, "printString");
    var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
      return escapeSequences[str.charCodeAt(0)];
    }
    __name(escapedReplacer, "escapedReplacer");
    var escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "node_modules/graphql/language/visitor.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BREAK = void 0;
    exports2.getEnterLeaveForKind = getEnterLeaveForKind;
    exports2.getVisitFn = getVisitFn;
    exports2.visit = visit;
    exports2.visitInParallel = visitInParallel;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var BREAK = Object.freeze({});
    exports2.BREAK = BREAK;
    function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
      const enterLeaveMap = /* @__PURE__ */ new Map();
      for (const kind of Object.values(_kinds.Kind)) {
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
      }
      let stack = void 0;
      let inArray = Array.isArray(root);
      let keys = [root];
      let index = -1;
      let edits = [];
      let node = root;
      let key = void 0;
      let parent = void 0;
      const path = [];
      const ancestors = [];
      do {
        index++;
        const isLeaving = index === keys.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
              let editOffset = 0;
              for (const [editKey, editValue] of edits) {
                const arrayKey = editKey - editOffset;
                if (editValue === null) {
                  node.splice(arrayKey, 1);
                  editOffset++;
                } else {
                  node[arrayKey] = editValue;
                }
              }
            } else {
              node = { ...node };
              for (const [editKey, editValue] of edits) {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else if (parent) {
          key = inArray ? index : keys[index];
          node = parent[key];
          if (node === null || node === void 0) {
            continue;
          }
          path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
          var _enterLeaveMap$get, _enterLeaveMap$get2;
          (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
            false,
            `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
          );
          const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
          result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== void 0) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _node$kind;
          stack = {
            inArray,
            index,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        return edits[edits.length - 1][1];
      }
      return root;
    }
    __name(visit, "visit");
    function visitInParallel(visitors) {
      const skipping = new Array(visitors.length).fill(null);
      const mergedVisitor = /* @__PURE__ */ Object.create(null);
      for (const kind of Object.values(_kinds.Kind)) {
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(void 0);
        const leaveList = new Array(visitors.length).fill(void 0);
        for (let i = 0; i < visitors.length; ++i) {
          const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
          hasVisitor || (hasVisitor = enter != null || leave != null);
          enterList[i] = enter;
          leaveList[i] = leave;
        }
        if (!hasVisitor) {
          continue;
        }
        const mergedEnterLeave = {
          enter(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _enterList$i;
                const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          },
          leave(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _leaveList$i;
                const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              } else if (skipping[i] === node) {
                skipping[i] = null;
              }
            }
          }
        };
        mergedVisitor[kind] = mergedEnterLeave;
      }
      return mergedVisitor;
    }
    __name(visitInParallel, "visitInParallel");
    function getEnterLeaveForKind(visitor, kind) {
      const kindVisitor = visitor[kind];
      if (typeof kindVisitor === "object") {
        return kindVisitor;
      } else if (typeof kindVisitor === "function") {
        return {
          enter: kindVisitor,
          leave: void 0
        };
      }
      return {
        enter: visitor.enter,
        leave: visitor.leave
      };
    }
    __name(getEnterLeaveForKind, "getEnterLeaveForKind");
    function getVisitFn(visitor, kind, isLeaving) {
      const { enter, leave } = getEnterLeaveForKind(visitor, kind);
      return isLeaving ? leave : enter;
    }
    __name(getVisitFn, "getVisitFn");
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "node_modules/graphql/language/printer.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.print = print;
    var _blockString = require_blockString();
    var _printString = require_printString();
    var _visitor = require_visitor();
    function print(ast) {
      return (0, _visitor.visit)(ast, printDocASTReducer);
    }
    __name(print, "print");
    var MAX_LINE_LENGTH = 80;
    var printDocASTReducer = {
      Name: {
        leave: /* @__PURE__ */ __name((node) => node.value, "leave")
      },
      Variable: {
        leave: /* @__PURE__ */ __name((node) => "$" + node.name, "leave")
      },
      // Document
      Document: {
        leave: /* @__PURE__ */ __name((node) => join(node.definitions, "\n\n"), "leave")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: /* @__PURE__ */ __name(({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " ")), "leave")
      },
      SelectionSet: {
        leave: /* @__PURE__ */ __name(({ selections }) => block(selections), "leave")
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave")
      },
      // Fragments
      FragmentSpread: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => "..." + name + wrap(" ", join(directives, " ")), "leave")
      },
      InlineFragment: {
        leave: /* @__PURE__ */ __name(({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        ), "leave")
      },
      FragmentDefinition: {
        leave: /* @__PURE__ */ __name(({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        ), "leave")
      },
      // Value
      IntValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value, "leave")
      },
      FloatValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value, "leave")
      },
      StringValue: {
        leave: /* @__PURE__ */ __name(({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value), "leave")
      },
      BooleanValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value ? "true" : "false", "leave")
      },
      NullValue: {
        leave: /* @__PURE__ */ __name(() => "null", "leave")
      },
      EnumValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value, "leave")
      },
      ListValue: {
        leave: /* @__PURE__ */ __name(({ values }) => "[" + join(values, ", ") + "]", "leave")
      },
      ObjectValue: {
        leave: /* @__PURE__ */ __name(({ fields }) => "{" + join(fields, ", ") + "}", "leave")
      },
      ObjectField: {
        leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave")
      },
      // Directive
      Directive: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")"), "leave")
      },
      // Type
      NamedType: {
        leave: /* @__PURE__ */ __name(({ name }) => name, "leave")
      },
      ListType: {
        leave: /* @__PURE__ */ __name(({ type: type2 }) => "[" + type2 + "]", "leave")
      },
      NonNullType: {
        leave: /* @__PURE__ */ __name(({ type: type2 }) => type2 + "!", "leave")
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: /* @__PURE__ */ __name(({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      OperationTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ operation, type: type2 }) => operation + ": " + type2, "leave")
      },
      ScalarTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        ), "leave")
      },
      FieldDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, arguments: args, type: type2, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " ")), "leave")
      },
      InputValueDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, type: type2, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type2, wrap("= ", defaultValue), join(directives, " ")],
          " "
        ), "leave")
      },
      InterfaceTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        ), "leave")
      },
      UnionTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives, types: types3 }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types3, " | "))],
          " "
        ), "leave")
      },
      EnumTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      EnumValueDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " "), "leave")
      },
      InputObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " "), "leave")
      },
      DirectiveDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | "), "leave")
      },
      SchemaExtension: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        ), "leave")
      },
      ScalarTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        ), "leave")
      },
      InterfaceTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        ), "leave")
      },
      UnionTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types3, " | "))
          ],
          " "
        ), "leave")
      },
      EnumTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      InputObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " "), "leave")
      }
    };
    function join(maybeArray, separator = "") {
      var _maybeArray$filter$jo;
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    __name(join, "join");
    function block(array) {
      return wrap("{\n", indent(join(array, "\n")), "\n}");
    }
    __name(block, "block");
    function wrap(start, maybeString, end = "") {
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    __name(wrap, "wrap");
    function indent(str) {
      return wrap("  ", str.replace(/\n/g, "\n  "));
    }
    __name(indent, "indent");
    function hasMultilineItems(maybeArray) {
      var _maybeArray$some;
      return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
    __name(hasMultilineItems, "hasMultilineItems");
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromASTUntyped = valueFromASTUntyped;
    var _keyValMap = require_keyValMap();
    var _kinds = require_kinds();
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map(
            (node) => valueFromASTUntyped(node, variables)
          );
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.keyValMap)(
            valueNode.fields,
            (field) => field.name.value,
            (field) => valueFromASTUntyped(field.value, variables)
          );
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
    }
    __name(valueFromASTUntyped, "valueFromASTUntyped");
  }
});

// node_modules/graphql/type/assertName.js
var require_assertName = __commonJS({
  "node_modules/graphql/type/assertName.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertEnumValueName = assertEnumValueName;
    exports2.assertName = assertName;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _characterClasses = require_characterClasses();
    function assertName(name) {
      name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.length === 0) {
        throw new _GraphQLError.GraphQLError(
          "Expected name to be a non-empty string."
        );
      }
      for (let i = 1; i < name.length; ++i) {
        if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
          throw new _GraphQLError.GraphQLError(
            `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
          );
        }
      }
      if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
        throw new _GraphQLError.GraphQLError(
          `Names must start with [_a-zA-Z] but "${name}" does not.`
        );
      }
      return name;
    }
    __name(assertName, "assertName");
    function assertEnumValueName(name) {
      if (name === "true" || name === "false" || name === "null") {
        throw new _GraphQLError.GraphQLError(
          `Enum values cannot be named: ${name}`
        );
      }
      return assertName(name);
    }
    __name(assertEnumValueName, "assertEnumValueName");
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "node_modules/graphql/type/definition.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLUnionType = exports2.GraphQLScalarType = exports2.GraphQLObjectType = exports2.GraphQLNonNull = exports2.GraphQLList = exports2.GraphQLInterfaceType = exports2.GraphQLInputObjectType = exports2.GraphQLEnumType = void 0;
    exports2.argsToArgsConfig = argsToArgsConfig;
    exports2.assertAbstractType = assertAbstractType;
    exports2.assertCompositeType = assertCompositeType;
    exports2.assertEnumType = assertEnumType;
    exports2.assertInputObjectType = assertInputObjectType;
    exports2.assertInputType = assertInputType;
    exports2.assertInterfaceType = assertInterfaceType;
    exports2.assertLeafType = assertLeafType;
    exports2.assertListType = assertListType;
    exports2.assertNamedType = assertNamedType;
    exports2.assertNonNullType = assertNonNullType;
    exports2.assertNullableType = assertNullableType;
    exports2.assertObjectType = assertObjectType;
    exports2.assertOutputType = assertOutputType;
    exports2.assertScalarType = assertScalarType;
    exports2.assertType = assertType;
    exports2.assertUnionType = assertUnionType;
    exports2.assertWrappingType = assertWrappingType;
    exports2.defineArguments = defineArguments;
    exports2.getNamedType = getNamedType;
    exports2.getNullableType = getNullableType;
    exports2.isAbstractType = isAbstractType;
    exports2.isCompositeType = isCompositeType;
    exports2.isEnumType = isEnumType;
    exports2.isInputObjectType = isInputObjectType;
    exports2.isInputType = isInputType;
    exports2.isInterfaceType = isInterfaceType;
    exports2.isLeafType = isLeafType;
    exports2.isListType = isListType;
    exports2.isNamedType = isNamedType;
    exports2.isNonNullType = isNonNullType;
    exports2.isNullableType = isNullableType;
    exports2.isObjectType = isObjectType;
    exports2.isOutputType = isOutputType;
    exports2.isRequiredArgument = isRequiredArgument;
    exports2.isRequiredInputField = isRequiredInputField;
    exports2.isScalarType = isScalarType;
    exports2.isType = isType;
    exports2.isUnionType = isUnionType;
    exports2.isWrappingType = isWrappingType;
    exports2.resolveObjMapThunk = resolveObjMapThunk;
    exports2.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
    var _devAssert = require_devAssert();
    var _didYouMean = require_didYouMean();
    var _identityFunc = require_identityFunc();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _keyMap = require_keyMap();
    var _keyValMap = require_keyValMap();
    var _mapValue = require_mapValue();
    var _suggestionList = require_suggestionList();
    var _toObjMap = require_toObjMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _assertName = require_assertName();
    function isType(type2) {
      return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
    }
    __name(isType, "isType");
    function assertType(type2) {
      if (!isType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL type.`
        );
      }
      return type2;
    }
    __name(assertType, "assertType");
    function isScalarType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLScalarType);
    }
    __name(isScalarType, "isScalarType");
    function assertScalarType(type2) {
      if (!isScalarType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Scalar type.`
        );
      }
      return type2;
    }
    __name(assertScalarType, "assertScalarType");
    function isObjectType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLObjectType);
    }
    __name(isObjectType, "isObjectType");
    function assertObjectType(type2) {
      if (!isObjectType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Object type.`
        );
      }
      return type2;
    }
    __name(assertObjectType, "assertObjectType");
    function isInterfaceType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLInterfaceType);
    }
    __name(isInterfaceType, "isInterfaceType");
    function assertInterfaceType(type2) {
      if (!isInterfaceType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Interface type.`
        );
      }
      return type2;
    }
    __name(assertInterfaceType, "assertInterfaceType");
    function isUnionType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLUnionType);
    }
    __name(isUnionType, "isUnionType");
    function assertUnionType(type2) {
      if (!isUnionType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Union type.`
        );
      }
      return type2;
    }
    __name(assertUnionType, "assertUnionType");
    function isEnumType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLEnumType);
    }
    __name(isEnumType, "isEnumType");
    function assertEnumType(type2) {
      if (!isEnumType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Enum type.`
        );
      }
      return type2;
    }
    __name(assertEnumType, "assertEnumType");
    function isInputObjectType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLInputObjectType);
    }
    __name(isInputObjectType, "isInputObjectType");
    function assertInputObjectType(type2) {
      if (!isInputObjectType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(
            type2
          )} to be a GraphQL Input Object type.`
        );
      }
      return type2;
    }
    __name(assertInputObjectType, "assertInputObjectType");
    function isListType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLList);
    }
    __name(isListType, "isListType");
    function assertListType(type2) {
      if (!isListType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL List type.`
        );
      }
      return type2;
    }
    __name(assertListType, "assertListType");
    function isNonNullType(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLNonNull);
    }
    __name(isNonNullType, "isNonNullType");
    function assertNonNullType(type2) {
      if (!isNonNullType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Non-Null type.`
        );
      }
      return type2;
    }
    __name(assertNonNullType, "assertNonNullType");
    function isInputType(type2) {
      return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
    }
    __name(isInputType, "isInputType");
    function assertInputType(type2) {
      if (!isInputType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL input type.`
        );
      }
      return type2;
    }
    __name(assertInputType, "assertInputType");
    function isOutputType(type2) {
      return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
    }
    __name(isOutputType, "isOutputType");
    function assertOutputType(type2) {
      if (!isOutputType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL output type.`
        );
      }
      return type2;
    }
    __name(assertOutputType, "assertOutputType");
    function isLeafType(type2) {
      return isScalarType(type2) || isEnumType(type2);
    }
    __name(isLeafType, "isLeafType");
    function assertLeafType(type2) {
      if (!isLeafType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL leaf type.`
        );
      }
      return type2;
    }
    __name(assertLeafType, "assertLeafType");
    function isCompositeType(type2) {
      return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
    }
    __name(isCompositeType, "isCompositeType");
    function assertCompositeType(type2) {
      if (!isCompositeType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL composite type.`
        );
      }
      return type2;
    }
    __name(assertCompositeType, "assertCompositeType");
    function isAbstractType(type2) {
      return isInterfaceType(type2) || isUnionType(type2);
    }
    __name(isAbstractType, "isAbstractType");
    function assertAbstractType(type2) {
      if (!isAbstractType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL abstract type.`
        );
      }
      return type2;
    }
    __name(assertAbstractType, "assertAbstractType");
    var GraphQLList = class {
      static {
        __name(this, "GraphQLList");
      }
      constructor(ofType) {
        isType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLList = GraphQLList;
    var GraphQLNonNull = class {
      static {
        __name(this, "GraphQLNonNull");
      }
      constructor(ofType) {
        isNullableType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(
            ofType
          )} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLNonNull = GraphQLNonNull;
    function isWrappingType(type2) {
      return isListType(type2) || isNonNullType(type2);
    }
    __name(isWrappingType, "isWrappingType");
    function assertWrappingType(type2) {
      if (!isWrappingType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL wrapping type.`
        );
      }
      return type2;
    }
    __name(assertWrappingType, "assertWrappingType");
    function isNullableType(type2) {
      return isType(type2) && !isNonNullType(type2);
    }
    __name(isNullableType, "isNullableType");
    function assertNullableType(type2) {
      if (!isNullableType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL nullable type.`
        );
      }
      return type2;
    }
    __name(assertNullableType, "assertNullableType");
    function getNullableType(type2) {
      if (type2) {
        return isNonNullType(type2) ? type2.ofType : type2;
      }
    }
    __name(getNullableType, "getNullableType");
    function isNamedType(type2) {
      return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
    }
    __name(isNamedType, "isNamedType");
    function assertNamedType(type2) {
      if (!isNamedType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL named type.`
        );
      }
      return type2;
    }
    __name(assertNamedType, "assertNamedType");
    function getNamedType(type2) {
      if (type2) {
        let unwrappedType = type2;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    __name(getNamedType, "getNamedType");
    function resolveReadonlyArrayThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    __name(resolveReadonlyArrayThunk, "resolveReadonlyArrayThunk");
    function resolveObjMapThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    __name(resolveObjMapThunk, "resolveObjMapThunk");
    var GraphQLScalarType = class {
      static {
        __name(this, "GraphQLScalarType");
      }
      constructor(config2) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.specifiedByURL = config2.specifiedByURL;
        this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(
          (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
        );
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config2.specifiedByURL)}.`
        );
        config2.serialize == null || typeof config2.serialize === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config2.parseLiteral) {
          typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLScalarType = GraphQLScalarType;
    var GraphQLObjectType = class {
      static {
        __name(this, "GraphQLObjectType");
      }
      constructor(config2) {
        var _config$extensionASTN2;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.isTypeOf = config2.isTypeOf;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config2);
        this._interfaces = () => defineInterfaces(config2);
        config2.isTypeOf == null || typeof config2.isTypeOf === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config2.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLObjectType = GraphQLObjectType;
    function defineInterfaces(config2) {
      var _config$interfaces;
      const interfaces = resolveReadonlyArrayThunk(
        (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
      );
      Array.isArray(interfaces) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} interfaces must be an Array or a function which returns an Array.`
      );
      return interfaces;
    }
    __name(defineInterfaces, "defineInterfaces");
    function defineFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field config must be an object.`
        );
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
        );
        const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} args must be an object with argument names as keys.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          args: defineArguments(argsConfig),
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    __name(defineFieldMap, "defineFieldMap");
    function defineArguments(config2) {
      return Object.entries(config2).map(([argName, argConfig]) => ({
        name: (0, _assertName.assertName)(argName),
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
        astNode: argConfig.astNode
      }));
    }
    __name(defineArguments, "defineArguments");
    function isPlainObj(obj) {
      return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
    }
    __name(isPlainObj, "isPlainObj");
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.mapValue)(fields, (field) => ({
        description: field.description,
        type: field.type,
        args: argsToArgsConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
    }
    __name(fieldsToFieldsConfig, "fieldsToFieldsConfig");
    function argsToArgsConfig(args) {
      return (0, _keyValMap.keyValMap)(
        args,
        (arg) => arg.name,
        (arg) => ({
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        })
      );
    }
    __name(argsToArgsConfig, "argsToArgsConfig");
    function isRequiredArgument(arg) {
      return isNonNullType(arg.type) && arg.defaultValue === void 0;
    }
    __name(isRequiredArgument, "isRequiredArgument");
    var GraphQLInterfaceType = class {
      static {
        __name(this, "GraphQLInterfaceType");
      }
      constructor(config2) {
        var _config$extensionASTN3;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config2);
        this._interfaces = defineInterfaces.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInterfaceType = GraphQLInterfaceType;
    var GraphQLUnionType = class {
      static {
        __name(this, "GraphQLUnionType");
      }
      constructor(config2) {
        var _config$extensionASTN4;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLUnionType = GraphQLUnionType;
    function defineTypes(config2) {
      const types3 = resolveReadonlyArrayThunk(config2.types);
      Array.isArray(types3) || (0, _devAssert.devAssert)(
        false,
        `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
      );
      return types3;
    }
    __name(defineTypes, "defineTypes");
    var GraphQLEnumType = class {
      static {
        __name(this, "GraphQLEnumType");
      }
      /* <T> */
      constructor(config2) {
        var _config$extensionASTN5;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = typeof config2.values === "function" ? config2.values : defineEnumValues(this.name, config2.values);
        this._valueLookup = null;
        this._nameLookup = null;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        if (typeof this._values === "function") {
          this._values = defineEnumValues(this.name, this._values());
        }
        return this._values;
      }
      getValue(name) {
        if (this._nameLookup === null) {
          this._nameLookup = (0, _keyMap.keyMap)(
            this.getValues(),
            (value) => value.name
          );
        }
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        if (this._valueLookup === null) {
          this._valueLookup = new Map(
            this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
          );
        }
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
              outputValue
            )}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = (0, _inspect.inspect)(inputValue);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = (0, _keyValMap.keyValMap)(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLEnumType = GraphQLEnumType;
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      const allNames = enumType.getValues().map((value) => value.name);
      const suggestedValues = (0, _suggestionList.suggestionList)(
        unknownValueStr,
        allNames
      );
      return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
    }
    __name(didYouMeanEnumValue, "didYouMeanEnumValue");
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.devAssert)(
        false,
        `${typeName} values must be an object with value names as keys.`
      );
      return Object.entries(valueMap).map(([valueName, valueConfig]) => {
        isPlainObj(valueConfig) || (0, _devAssert.devAssert)(
          false,
          `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
            valueConfig
          )}.`
        );
        return {
          name: (0, _assertName.assertEnumValueName)(valueName),
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          deprecationReason: valueConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    __name(defineEnumValues, "defineEnumValues");
    var GraphQLInputObjectType = class {
      static {
        __name(this, "GraphQLInputObjectType");
      }
      constructor(config2) {
        var _config$extensionASTN6, _config$isOneOf;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this.isOneOf = (_config$isOneOf = config2.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
        this._fields = defineInputFieldMap.bind(void 0, config2);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          isOneOf: this.isOneOf
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInputObjectType = GraphQLInputObjectType;
    function defineInputFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    __name(defineInputFieldMap, "defineInputFieldMap");
    function isRequiredInputField(field) {
      return isNonNullType(field.type) && field.defaultValue === void 0;
    }
    __name(isRequiredInputField, "isRequiredInputField");
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "node_modules/graphql/utilities/typeComparators.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doTypesOverlap = doTypesOverlap;
    exports2.isEqualType = isEqualType;
    exports2.isTypeSubTypeOf = isTypeSubTypeOf;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    __name(isEqualType, "isEqualType");
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
    }
    __name(isTypeSubTypeOf, "isTypeSubTypeOf");
    function doTypesOverlap(schema, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
        }
        return schema.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.isSubType(typeB, typeA);
      }
      return false;
    }
    __name(doTypesOverlap, "doTypesOverlap");
  }
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "node_modules/graphql/type/scalars.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLString = exports2.GraphQLInt = exports2.GraphQLID = exports2.GraphQLFloat = exports2.GraphQLBoolean = exports2.GRAPHQL_MIN_INT = exports2.GRAPHQL_MAX_INT = void 0;
    exports2.isSpecifiedScalarType = isSpecifiedScalarType;
    exports2.specifiedScalarTypes = void 0;
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var GRAPHQL_MAX_INT = 2147483647;
    exports2.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
    var GRAPHQL_MIN_INT = -2147483648;
    exports2.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
    var GraphQLInt = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    exports2.GraphQLInt = GraphQLInt;
    var GraphQLFloat = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _printer.print)(
              valueNode
            )}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    exports2.GraphQLFloat = GraphQLFloat;
    var GraphQLString = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLString = GraphQLString;
    var GraphQLBoolean = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new _GraphQLError.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
            coercedValue
          )}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLBoolean = GraphQLBoolean;
    var GraphQLID = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
        );
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLID = GraphQLID;
    var specifiedScalarTypes = Object.freeze([
      GraphQLString,
      GraphQLInt,
      GraphQLFloat,
      GraphQLBoolean,
      GraphQLID
    ]);
    exports2.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType(type2) {
      return specifiedScalarTypes.some(({ name }) => type2.name === name);
    }
    __name(isSpecifiedScalarType, "isSpecifiedScalarType");
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.isObjectLike)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          const valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
    __name(serializeObject, "serializeObject");
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "node_modules/graphql/type/directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSpecifiedByDirective = exports2.GraphQLSkipDirective = exports2.GraphQLOneOfDirective = exports2.GraphQLIncludeDirective = exports2.GraphQLDirective = exports2.GraphQLDeprecatedDirective = exports2.DEFAULT_DEPRECATION_REASON = void 0;
    exports2.assertDirective = assertDirective;
    exports2.isDirective = isDirective;
    exports2.isSpecifiedDirective = isSpecifiedDirective;
    exports2.specifiedDirectives = void 0;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _directiveLocation = require_directiveLocation();
    var _assertName = require_assertName();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function isDirective(directive) {
      return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
    }
    __name(isDirective, "isDirective");
    function assertDirective(directive) {
      if (!isDirective(directive)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
        );
      }
      return directive;
    }
    __name(assertDirective, "assertDirective");
    var GraphQLDirective = class {
      static {
        __name(this, "GraphQLDirective");
      }
      constructor(config2) {
        var _config$isRepeatable, _config$args;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.locations = config2.locations;
        this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        Array.isArray(config2.locations) || (0, _devAssert.devAssert)(
          false,
          `@${config2.name} locations must be an Array.`
        );
        const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
          false,
          `@${config2.name} args must be an object with argument names as keys.`
        );
        this.args = (0, _definition.defineArguments)(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLDirective = GraphQLDirective;
    var GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports2.GraphQLIncludeDirective = GraphQLIncludeDirective;
    var GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports2.GraphQLSkipDirective = GraphQLSkipDirective;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports2.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports2.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
    var GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    exports2.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var GraphQLOneOfDirective = new GraphQLDirective({
      name: "oneOf",
      description: "Indicates exactly one field must be supplied and this field must not be `null`.",
      locations: [_directiveLocation.DirectiveLocation.INPUT_OBJECT],
      args: {}
    });
    exports2.GraphQLOneOfDirective = GraphQLOneOfDirective;
    var specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective,
      GraphQLSpecifiedByDirective,
      GraphQLOneOfDirective
    ]);
    exports2.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective(directive) {
      return specifiedDirectives.some(({ name }) => name === directive.name);
    }
    __name(isSpecifiedDirective, "isSpecifiedDirective");
  }
});

// node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS({
  "node_modules/graphql/jsutils/isIterableObject.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIterableObject = isIterableObject;
    function isIterableObject(maybeIterable) {
      return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
    }
    __name(isIterableObject, "isIterableObject");
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "node_modules/graphql/utilities/astFromValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.astFromValue = astFromValue;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function astFromValue(value, type2) {
      if ((0, _definition.isNonNullType)(type2)) {
        const astValue = astFromValue(value, type2.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type2)) {
        const itemType = type2.ofType;
        if ((0, _isIterableObject.isIterableObject)(value)) {
          const valuesNodes = [];
          for (const item of value) {
            const itemNode = astFromValue(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        if (!(0, _isObjectLike.isObjectLike)(value)) {
          return null;
        }
        const fieldNodes = [];
        for (const field of Object.values(type2.getFields())) {
          const fieldValue = astFromValue(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type2)) {
        const serialized = type2.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && Number.isFinite(serialized)) {
          const stringNum = String(serialized);
          return integerStringRegExp.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type2)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type2 === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError(
          `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
        );
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(astFromValue, "astFromValue");
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "node_modules/graphql/type/introspection.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionTypes = exports2.__TypeKind = exports2.__Type = exports2.__Schema = exports2.__InputValue = exports2.__Field = exports2.__EnumValue = exports2.__DirectiveLocation = exports2.__Directive = exports2.TypeNameMetaFieldDef = exports2.TypeMetaFieldDef = exports2.TypeKind = exports2.SchemaMetaFieldDef = void 0;
    exports2.isIntrospectionType = isIntrospectionType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _directiveLocation = require_directiveLocation();
    var _printer = require_printer();
    var _astFromValue = require_astFromValue();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: /* @__PURE__ */ __name(() => ({
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((schema) => schema.description, "resolve")
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))
          ),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new _definition.GraphQLNonNull(__Type),
          resolve: /* @__PURE__ */ __name((schema) => schema.getQueryType(), "resolve")
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: /* @__PURE__ */ __name((schema) => schema.getMutationType(), "resolve")
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: /* @__PURE__ */ __name((schema) => schema.getSubscriptionType(), "resolve")
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Directive)
            )
          ),
          resolve: /* @__PURE__ */ __name((schema) => schema.getDirectives(), "resolve")
        }
      }), "fields")
    });
    exports2.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((directive) => directive.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((directive) => directive.description, "resolve")
        },
        isRepeatable: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((directive) => directive.isRepeatable, "resolve")
        },
        locations: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__DirectiveLocation)
            )
          ),
          resolve: /* @__PURE__ */ __name((directive) => directive.locations, "resolve")
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      }), "fields")
    });
    exports2.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports2.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: /* @__PURE__ */ __name(() => ({
        kind: {
          type: new _definition.GraphQLNonNull(__TypeKind),
          resolve(type2) {
            if ((0, _definition.isScalarType)(type2)) {
              return TypeKind.SCALAR;
            }
            if ((0, _definition.isObjectType)(type2)) {
              return TypeKind.OBJECT;
            }
            if ((0, _definition.isInterfaceType)(type2)) {
              return TypeKind.INTERFACE;
            }
            if ((0, _definition.isUnionType)(type2)) {
              return TypeKind.UNION;
            }
            if ((0, _definition.isEnumType)(type2)) {
              return TypeKind.ENUM;
            }
            if ((0, _definition.isInputObjectType)(type2)) {
              return TypeKind.INPUT_OBJECT;
            }
            if ((0, _definition.isListType)(type2)) {
              return TypeKind.LIST;
            }
            if ((0, _definition.isNonNullType)(type2)) {
              return TypeKind.NON_NULL;
            }
            (0, _invariant.invariant)(
              false,
              `Unexpected type: "${(0, _inspect.inspect)(type2)}".`
            );
          }
        },
        name: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((type2) => "name" in type2 ? type2.name : void 0, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((type2) => (
            /* c8 ignore next */
            "description" in type2 ? type2.description : void 0
          ), "resolve")
        },
        specifiedByURL: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0, "resolve")
        },
        fields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__Field)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type2, { includeDeprecated }) {
            if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
              const fields = Object.values(type2.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type2) {
            if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
              return type2.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type2, _args, _context, { schema }) {
            if ((0, _definition.isAbstractType)(type2)) {
              return schema.getPossibleTypes(type2);
            }
          }
        },
        enumValues: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__EnumValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type2, { includeDeprecated }) {
            if ((0, _definition.isEnumType)(type2)) {
              const values = type2.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__InputValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type2, { includeDeprecated }) {
            if ((0, _definition.isInputObjectType)(type2)) {
              const values = Object.values(type2.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: /* @__PURE__ */ __name((type2) => "ofType" in type2 ? type2.ofType : void 0, "resolve")
        },
        isOneOf: {
          type: _scalars.GraphQLBoolean,
          resolve: /* @__PURE__ */ __name((type2) => {
            if ((0, _definition.isInputObjectType)(type2)) {
              return type2.isOneOf;
            }
          }, "resolve")
        }
      }), "fields")
    });
    exports2.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((field) => field.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((field) => field.description, "resolve")
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: /* @__PURE__ */ __name((field) => field.type, "resolve")
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((field) => field.deprecationReason != null, "resolve")
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((field) => field.deprecationReason, "resolve")
        }
      }), "fields")
    });
    exports2.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((inputValue) => inputValue.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((inputValue) => inputValue.description, "resolve")
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: /* @__PURE__ */ __name((inputValue) => inputValue.type, "resolve")
        },
        defaultValue: {
          type: _scalars.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type: type2, defaultValue } = inputValue;
            const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type2);
            return valueAST ? (0, _printer.print)(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((field) => field.deprecationReason != null, "resolve")
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((obj) => obj.deprecationReason, "resolve")
        }
      }), "fields")
    });
    exports2.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.description, "resolve")
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.deprecationReason != null, "resolve")
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.deprecationReason, "resolve")
        }
      }), "fields")
    });
    exports2.__EnumValue = __EnumValue;
    var TypeKind;
    exports2.TypeKind = TypeKind;
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (exports2.TypeKind = TypeKind = {}));
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports2.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: /* @__PURE__ */ __name((_source, _args, _context, { schema }) => schema, "resolve"),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.SchemaMetaFieldDef = SchemaMetaFieldDef;
    var TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: /* @__PURE__ */ __name((_source, { name }, _context, { schema }) => schema.getType(name), "resolve"),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeMetaFieldDef = TypeMetaFieldDef;
    var TypeNameMetaFieldDef = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: /* @__PURE__ */ __name((_source, _args, _context, { parentType }) => parentType.name, "resolve"),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
    var introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
    exports2.introspectionTypes = introspectionTypes;
    function isIntrospectionType(type2) {
      return introspectionTypes.some(({ name }) => type2.name === name);
    }
    __name(isIntrospectionType, "isIntrospectionType");
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "node_modules/graphql/type/schema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSchema = void 0;
    exports2.assertSchema = assertSchema;
    exports2.isSchema = isSchema;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _ast = require_ast();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    function isSchema(schema) {
      return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
    }
    __name(isSchema, "isSchema");
    function assertSchema(schema) {
      if (!isSchema(schema)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`
        );
      }
      return schema;
    }
    __name(assertSchema, "assertSchema");
    var GraphQLSchema = class {
      static {
        __name(this, "GraphQLSchema");
      }
      // Used as a cache for validateSchema().
      constructor(config2) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config2.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.isObjectLike)(config2) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
        !config2.types || Array.isArray(config2.types) || (0, _devAssert.devAssert)(
          false,
          `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
            config2.types
          )}.`
        );
        !config2.directives || Array.isArray(config2.directives) || (0, _devAssert.devAssert)(
          false,
          `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config2.directives)}.`
        );
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config2.query;
        this._mutationType = config2.mutation;
        this._subscriptionType = config2.subscription;
        this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        const allReferencedTypes = new Set(config2.types);
        if (config2.types != null) {
          for (const type2 of config2.types) {
            allReferencedTypes.delete(type2);
            collectReferencedTypes(type2, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if ((0, _directives.isDirective)(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || (0, _devAssert.devAssert)(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return this.getQueryType();
          case _ast.OperationTypeNode.MUTATION:
            return this.getMutationType();
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (const type2 of abstractType.getTypes()) {
              map[type2.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type2 of implementations.objects) {
              map[type2.name] = true;
            }
            for (const type2 of implementations.interfaces) {
              map[type2.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
    exports2.GraphQLSchema = GraphQLSchema;
    function collectReferencedTypes(type2, typeSet) {
      const namedType = (0, _definition.getNamedType)(type2);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (const memberType of namedType.getTypes()) {
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (const interfaceType of namedType.getInterfaces()) {
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
            for (const arg of field.args) {
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
    __name(collectReferencedTypes, "collectReferencedTypes");
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "node_modules/graphql/type/validate.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSchema = assertValidSchema;
    exports2.validateSchema = validateSchema;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _typeComparators = require_typeComparators();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function validateSchema(schema) {
      (0, _schema.assertSchema)(schema);
      if (schema.__validationErrors) {
        return schema.__validationErrors;
      }
      const context2 = new SchemaValidationContext(schema);
      validateRootTypes(context2);
      validateDirectives(context2);
      validateTypes(context2);
      const errors = context2.getErrors();
      schema.__validationErrors = errors;
      return errors;
    }
    __name(validateSchema, "validateSchema");
    function assertValidSchema(schema) {
      const errors = validateSchema(schema);
      if (errors.length !== 0) {
        throw new Error(errors.map((error3) => error3.message).join("\n\n"));
      }
    }
    __name(assertValidSchema, "assertValidSchema");
    var SchemaValidationContext = class {
      static {
        __name(this, "SchemaValidationContext");
      }
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
    function validateRootTypes(context2) {
      const schema = context2.schema;
      const queryType = schema.getQueryType();
      if (!queryType) {
        context2.reportError("Query root type must be provided.", schema.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context2.reportError(
          `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
          (_getOperationTypeNode = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.QUERY
          )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
        );
      }
      const mutationType = schema.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context2.reportError(
          `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
          (_getOperationTypeNode2 = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.MUTATION
          )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
        );
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context2.reportError(
          `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
          (_getOperationTypeNode3 = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.SUBSCRIPTION
          )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
        );
      }
    }
    __name(validateRootTypes, "validateRootTypes");
    function getOperationTypeNode(schema, operation) {
      var _flatMap$find;
      return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (schemaNode) => {
          var _schemaNode$operation;
          return (
            /* c8 ignore next */
            (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
          );
        }
      ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
    }
    __name(getOperationTypeNode, "getOperationTypeNode");
    function validateDirectives(context2) {
      for (const directive of context2.schema.getDirectives()) {
        if (!(0, _directives.isDirective)(directive)) {
          context2.reportError(
            `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
            directive === null || directive === void 0 ? void 0 : directive.astNode
          );
          continue;
        }
        validateName(context2, directive);
        if (directive.locations.length === 0) {
          context2.reportError(
            `Directive @${directive.name} must include 1 or more locations.`,
            directive.astNode
          );
        }
        for (const arg of directive.args) {
          validateName(context2, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context2.reportError(
              `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              arg.astNode
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context2.reportError(
              `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
              ]
            );
          }
        }
      }
    }
    __name(validateDirectives, "validateDirectives");
    function validateName(context2, node) {
      if (node.name.startsWith("__")) {
        context2.reportError(
          `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
          node.astNode
        );
      }
    }
    __name(validateName, "validateName");
    function validateTypes(context2) {
      const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context2);
      const typeMap = context2.schema.getTypeMap();
      for (const type2 of Object.values(typeMap)) {
        if (!(0, _definition.isNamedType)(type2)) {
          context2.reportError(
            `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type2)}.`,
            type2.astNode
          );
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type2)) {
          validateName(context2, type2);
        }
        if ((0, _definition.isObjectType)(type2)) {
          validateFields(context2, type2);
          validateInterfaces(context2, type2);
        } else if ((0, _definition.isInterfaceType)(type2)) {
          validateFields(context2, type2);
          validateInterfaces(context2, type2);
        } else if ((0, _definition.isUnionType)(type2)) {
          validateUnionMembers(context2, type2);
        } else if ((0, _definition.isEnumType)(type2)) {
          validateEnumValues(context2, type2);
        } else if ((0, _definition.isInputObjectType)(type2)) {
          validateInputFields(context2, type2);
          validateInputObjectCircularRefs(type2);
        }
      }
    }
    __name(validateTypes, "validateTypes");
    function validateFields(context2, type2) {
      const fields = Object.values(type2.getFields());
      if (fields.length === 0) {
        context2.reportError(`Type ${type2.name} must define one or more fields.`, [
          type2.astNode,
          ...type2.extensionASTNodes
        ]);
      }
      for (const field of fields) {
        validateName(context2, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context2.reportError(
            `The type of ${type2.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
          );
        }
        for (const arg of field.args) {
          const argName = arg.name;
          validateName(context2, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context2.reportError(
              `The type of ${type2.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context2.reportError(
              `Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
              ]
            );
          }
        }
      }
    }
    __name(validateFields, "validateFields");
    function validateInterfaces(context2, type2) {
      const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
      for (const iface of type2.getInterfaces()) {
        if (!(0, _definition.isInterfaceType)(iface)) {
          context2.reportError(
            `Type ${(0, _inspect.inspect)(
              type2
            )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
            getAllImplementsInterfaceNodes(type2, iface)
          );
          continue;
        }
        if (type2 === iface) {
          context2.reportError(
            `Type ${type2.name} cannot implement itself because it would create a circular reference.`,
            getAllImplementsInterfaceNodes(type2, iface)
          );
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context2.reportError(
            `Type ${type2.name} can only implement ${iface.name} once.`,
            getAllImplementsInterfaceNodes(type2, iface)
          );
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context2, type2, iface);
        validateTypeImplementsInterface(context2, type2, iface);
      }
    }
    __name(validateInterfaces, "validateInterfaces");
    function validateTypeImplementsInterface(context2, type2, iface) {
      const typeFieldMap = type2.getFields();
      for (const ifaceField of Object.values(iface.getFields())) {
        const fieldName = ifaceField.name;
        const typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context2.reportError(
            `Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`,
            [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]
          );
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(
          context2.schema,
          typeField.type,
          ifaceField.type
        )) {
          var _ifaceField$astNode, _typeField$astNode;
          context2.reportError(
            `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type2.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
            [
              (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
              (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]
          );
        }
        for (const ifaceArg of ifaceField.args) {
          const argName = ifaceArg.name;
          const typeArg = typeField.args.find((arg) => arg.name === argName);
          if (!typeArg) {
            context2.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`,
              [ifaceArg.astNode, typeField.astNode]
            );
            continue;
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context2.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type2.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
              [
                (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
              ]
            );
          }
        }
        for (const typeArg of typeField.args) {
          const argName = typeArg.name;
          const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context2.reportError(
              `Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
              [typeArg.astNode, ifaceField.astNode]
            );
          }
        }
      }
    }
    __name(validateTypeImplementsInterface, "validateTypeImplementsInterface");
    function validateTypeImplementsAncestors(context2, type2, iface) {
      const ifaceInterfaces = type2.getInterfaces();
      for (const transitive of iface.getInterfaces()) {
        if (!ifaceInterfaces.includes(transitive)) {
          context2.reportError(
            transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
            [
              ...getAllImplementsInterfaceNodes(iface, transitive),
              ...getAllImplementsInterfaceNodes(type2, iface)
            ]
          );
        }
      }
    }
    __name(validateTypeImplementsAncestors, "validateTypeImplementsAncestors");
    function validateUnionMembers(context2, union) {
      const memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context2.reportError(
          `Union type ${union.name} must define one or more member types.`,
          [union.astNode, ...union.extensionASTNodes]
        );
      }
      const includedTypeNames = /* @__PURE__ */ Object.create(null);
      for (const memberType of memberTypes) {
        if (includedTypeNames[memberType.name]) {
          context2.reportError(
            `Union type ${union.name} can only include type ${memberType.name} once.`,
            getUnionMemberTypeNodes(union, memberType.name)
          );
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context2.reportError(
            `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
            getUnionMemberTypeNodes(union, String(memberType))
          );
        }
      }
    }
    __name(validateUnionMembers, "validateUnionMembers");
    function validateEnumValues(context2, enumType) {
      const enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context2.reportError(
          `Enum type ${enumType.name} must define one or more values.`,
          [enumType.astNode, ...enumType.extensionASTNodes]
        );
      }
      for (const enumValue of enumValues) {
        validateName(context2, enumValue);
      }
    }
    __name(validateEnumValues, "validateEnumValues");
    function validateInputFields(context2, inputObj) {
      const fields = Object.values(inputObj.getFields());
      if (fields.length === 0) {
        context2.reportError(
          `Input Object type ${inputObj.name} must define one or more fields.`,
          [inputObj.astNode, ...inputObj.extensionASTNodes]
        );
      }
      for (const field of fields) {
        validateName(context2, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context2.reportError(
            `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
          );
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context2.reportError(
            `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(field.astNode),
              (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]
          );
        }
        if (inputObj.isOneOf) {
          validateOneOfInputObjectField(inputObj, field, context2);
        }
      }
    }
    __name(validateInputFields, "validateInputFields");
    function validateOneOfInputObjectField(type2, field, context2) {
      if ((0, _definition.isNonNullType)(field.type)) {
        var _field$astNode4;
        context2.reportError(
          `OneOf input field ${type2.name}.${field.name} must be nullable.`,
          (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
        );
      }
      if (field.defaultValue !== void 0) {
        context2.reportError(
          `OneOf input field ${type2.name}.${field.name} cannot have a default value.`,
          field.astNode
        );
      }
    }
    __name(validateOneOfInputObjectField, "validateOneOfInputObjectField");
    function createInputObjectCircularRefsValidator(context2) {
      const visitedTypes = /* @__PURE__ */ Object.create(null);
      const fieldPath = [];
      const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        const fields = Object.values(inputObj.getFields());
        for (const field of fields) {
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            const fieldType = field.type.ofType;
            const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              const cyclePath = fieldPath.slice(cycleIndex);
              const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
              context2.reportError(
                `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                cyclePath.map((fieldObj) => fieldObj.astNode)
              );
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
      __name(detectCycleRecursive, "detectCycleRecursive");
    }
    __name(createInputObjectCircularRefsValidator, "createInputObjectCircularRefsValidator");
    function getAllImplementsInterfaceNodes(type2, iface) {
      const { astNode, extensionASTNodes } = type2;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((typeNode) => {
        var _typeNode$interfaces;
        return (
          /* c8 ignore next */
          (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
        );
      }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
    }
    __name(getAllImplementsInterfaceNodes, "getAllImplementsInterfaceNodes");
    function getUnionMemberTypeNodes(union, typeName) {
      const { astNode, extensionASTNodes } = union;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((unionNode) => {
        var _unionNode$types;
        return (
          /* c8 ignore next */
          (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
        );
      }).filter((typeNode) => typeNode.name.value === typeName);
    }
    __name(getUnionMemberTypeNodes, "getUnionMemberTypeNodes");
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
        (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
      );
    }
    __name(getDeprecatedDirectiveNode, "getDeprecatedDirectiveNode");
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "node_modules/graphql/utilities/typeFromAST.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeFromAST = typeFromAST;
    var _kinds = require_kinds();
    var _definition = require_definition();
    function typeFromAST(schema, typeNode) {
      switch (typeNode.kind) {
        case _kinds.Kind.LIST_TYPE: {
          const innerType = typeFromAST(schema, typeNode.type);
          return innerType && new _definition.GraphQLList(innerType);
        }
        case _kinds.Kind.NON_NULL_TYPE: {
          const innerType = typeFromAST(schema, typeNode.type);
          return innerType && new _definition.GraphQLNonNull(innerType);
        }
        case _kinds.Kind.NAMED_TYPE:
          return schema.getType(typeNode.name.value);
      }
    }
    __name(typeFromAST, "typeFromAST");
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "node_modules/graphql/utilities/TypeInfo.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TypeInfo = void 0;
    exports2.visitWithTypeInfo = visitWithTypeInfo;
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    var TypeInfo = class {
      static {
        __name(this, "TypeInfo");
      }
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            const namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push(
              (0, _definition.isCompositeType)(namedType) ? namedType : void 0
            );
            break;
          }
          case _kinds.Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(
              (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
            );
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(
              (0, _definition.isObjectType)(rootType) ? rootType : void 0
            );
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push(
              (0, _definition.isOutputType)(outputType) ? outputType : void 0
            );
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputType) ? inputType : void 0
            );
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(argType) ? argType : void 0
            );
            break;
          }
          case _kinds.Kind.LIST: {
            const listType = (0, _definition.getNullableType)(this.getInputType());
            const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(itemType) ? itemType : void 0
            );
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            const objectType = (0, _definition.getNamedType)(this.getInputType());
            let inputFieldType;
            let inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case _kinds.Kind.ENUM: {
            const enumType = (0, _definition.getNamedType)(this.getInputType());
            let enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
    exports2.TypeInfo = TypeInfo;
    function getFieldDef(schema, parentType, fieldNode) {
      const name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    __name(getFieldDef, "getFieldDef");
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter(...args) {
          const node = args[0];
          typeInfo.enter(node);
          const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
          if (fn) {
            const result = fn.apply(visitor, args);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave(...args) {
          const node = args[0];
          const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
          let result;
          if (fn) {
            result = fn.apply(visitor, args);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
    __name(visitWithTypeInfo, "visitWithTypeInfo");
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "node_modules/graphql/language/predicates.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isConstValueNode = isConstValueNode;
    exports2.isDefinitionNode = isDefinitionNode;
    exports2.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports2.isSelectionNode = isSelectionNode;
    exports2.isTypeDefinitionNode = isTypeDefinitionNode;
    exports2.isTypeExtensionNode = isTypeExtensionNode;
    exports2.isTypeNode = isTypeNode;
    exports2.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    exports2.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports2.isValueNode = isValueNode;
    var _kinds = require_kinds();
    function isDefinitionNode(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
    }
    __name(isDefinitionNode, "isDefinitionNode");
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    __name(isExecutableDefinitionNode, "isExecutableDefinitionNode");
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    __name(isSelectionNode, "isSelectionNode");
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    __name(isValueNode, "isValueNode");
    function isConstValueNode(node) {
      return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
    }
    __name(isConstValueNode, "isConstValueNode");
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    __name(isTypeNode, "isTypeNode");
    function isTypeSystemDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    __name(isTypeSystemDefinitionNode, "isTypeSystemDefinitionNode");
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    __name(isTypeDefinitionNode, "isTypeDefinitionNode");
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    __name(isTypeSystemExtensionNode, "isTypeSystemExtensionNode");
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    __name(isTypeExtensionNode, "isTypeExtensionNode");
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context2) {
      return {
        Document(node) {
          for (const definition of node.definitions) {
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `The ${defName} definition is not executable.`,
                  {
                    nodes: definition
                  }
                )
              );
            }
          }
          return false;
        }
      };
    }
    __name(ExecutableDefinitionsRule, "ExecutableDefinitionsRule");
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _naturalCompare = require_naturalCompare();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function FieldsOnCorrectTypeRule(context2) {
      return {
        Field(node) {
          const type2 = context2.getParentType();
          if (type2) {
            const fieldDef = context2.getFieldDef();
            if (!fieldDef) {
              const schema = context2.getSchema();
              const fieldName = node.name.value;
              let suggestion = (0, _didYouMean.didYouMean)(
                "to use an inline fragment on",
                getSuggestedTypeNames(schema, type2, fieldName)
              );
              if (suggestion === "") {
                suggestion = (0, _didYouMean.didYouMean)(
                  getSuggestedFieldNames(type2, fieldName)
                );
              }
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(FieldsOnCorrectTypeRule, "FieldsOnCorrectTypeRule");
    function getSuggestedTypeNames(schema, type2, fieldName) {
      if (!(0, _definition.isAbstractType)(type2)) {
        return [];
      }
      const suggestedTypes = /* @__PURE__ */ new Set();
      const usageCount = /* @__PURE__ */ Object.create(null);
      for (const possibleType of schema.getPossibleTypes(type2)) {
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (const possibleInterface of possibleType.getInterfaces()) {
          var _usageCount$possibleI;
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return [...suggestedTypes].sort((typeA, typeB) => {
        const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
      }).map((x) => x.name);
    }
    __name(getSuggestedTypeNames, "getSuggestedTypeNames");
    function getSuggestedFieldNames(type2, fieldName) {
      if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
        const possibleFieldNames = Object.keys(type2.getFields());
        return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
      }
      return [];
    }
    __name(getSuggestedFieldNames, "getSuggestedFieldNames");
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context2) {
      return {
        InlineFragment(node) {
          const typeCondition = node.typeCondition;
          if (typeCondition) {
            const type2 = (0, _typeFromAST.typeFromAST)(
              context2.getSchema(),
              typeCondition
            );
            if (type2 && !(0, _definition.isCompositeType)(type2)) {
              const typeStr = (0, _printer.print)(typeCondition);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: typeCondition
                  }
                )
              );
            }
          }
        },
        FragmentDefinition(node) {
          const type2 = (0, _typeFromAST.typeFromAST)(
            context2.getSchema(),
            node.typeCondition
          );
          if (type2 && !(0, _definition.isCompositeType)(type2)) {
            const typeStr = (0, _printer.print)(node.typeCondition);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                {
                  nodes: node.typeCondition
                }
              )
            );
          }
        }
      };
    }
    __name(FragmentsOnCompositeTypesRule, "FragmentsOnCompositeTypesRule");
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    exports2.KnownArgumentNamesRule = KnownArgumentNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownArgumentNamesRule(context2) {
      return {
        // eslint-disable-next-line new-cap
        ...KnownArgumentNamesOnDirectivesRule(context2),
        Argument(argNode) {
          const argDef = context2.getArgument();
          const fieldDef = context2.getFieldDef();
          const parentType = context2.getParentType();
          if (!argDef && fieldDef && parentType) {
            const argName = argNode.name.value;
            const knownArgsNames = fieldDef.args.map((arg) => arg.name);
            const suggestions = (0, _suggestionList.suggestionList)(
              argName,
              knownArgsNames
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      };
    }
    __name(KnownArgumentNamesRule, "KnownArgumentNamesRule");
    function KnownArgumentNamesOnDirectivesRule(context2) {
      const directiveArgs = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
        }
      }
      return {
        Directive(directiveNode) {
          const directiveName = directiveNode.name.value;
          const knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (const argNode of directiveNode.arguments) {
              const argName = argNode.name.value;
              if (!knownArgs.includes(argName)) {
                const suggestions = (0, _suggestionList.suggestionList)(
                  argName,
                  knownArgs
                );
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                    {
                      nodes: argNode
                    }
                  )
                );
              }
            }
          }
          return false;
        }
      };
    }
    __name(KnownArgumentNamesOnDirectivesRule, "KnownArgumentNamesOnDirectivesRule");
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownDirectivesRule(context2) {
      const locationsMap = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        locationsMap[directive.name] = directive.locations;
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map((name) => name.value);
        }
      }
      return {
        Directive(node, _key, _parent, _path, ancestors) {
          const name = node.name.value;
          const locations = locationsMap[name];
          if (!locations) {
            context2.reportError(
              new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                nodes: node
              })
            );
            return;
          }
          const candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && !locations.includes(candidateLocation)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${name}" may not be used on ${candidateLocation}.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(KnownDirectivesRule, "KnownDirectivesRule");
    function getDirectiveLocationForASTPath(ancestors) {
      const appliedTo = ancestors[ancestors.length - 1];
      "kind" in appliedTo || (0, _invariant.invariant)(false);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          const parentNode = ancestors[ancestors.length - 3];
          "kind" in parentNode || (0, _invariant.invariant)(false);
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
        // Not reachable, all possible types have been considered.
        /* c8 ignore next */
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
          );
      }
    }
    __name(getDirectiveLocationForASTPath, "getDirectiveLocationForASTPath");
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return _directiveLocation.DirectiveLocation.QUERY;
        case _ast.OperationTypeNode.MUTATION:
          return _directiveLocation.DirectiveLocation.MUTATION;
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
    }
    __name(getDirectiveLocationForOperation, "getDirectiveLocationForOperation");
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context2) {
      return {
        FragmentSpread(node) {
          const fragmentName = node.name.value;
          const fragment = context2.getFragment(fragmentName);
          if (!fragment) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown fragment "${fragmentName}".`,
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      };
    }
    __name(KnownFragmentNamesRule, "KnownFragmentNamesRule");
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    function KnownTypeNamesRule(context2) {
      const schema = context2.getSchema();
      const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context2.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      const typeNames = [
        ...Object.keys(existingTypesMap),
        ...Object.keys(definedTypes)
      ];
      return {
        NamedType(node, _1, parent, _2, ancestors) {
          const typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            const isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && standardTypeNames.includes(typeName)) {
              return;
            }
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              isSDL ? standardTypeNames.concat(typeNames) : typeNames
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(KnownTypeNamesRule, "KnownTypeNamesRule");
    var standardTypeNames = [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ].map((type2) => type2.name);
    function isSDLNode(value) {
      return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
    __name(isSDLNode, "isSDLNode");
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    function LoneAnonymousOperationRule(context2) {
      let operationCount = 0;
      return {
        Document(node) {
          operationCount = node.definitions.filter(
            (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
          ).length;
        },
        OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                "This anonymous operation must be the only defined operation.",
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(LoneAnonymousOperationRule, "LoneAnonymousOperationRule");
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context2) {
      var _ref, _ref2, _oldSchema$astNode;
      const oldSchema = context2.getSchema();
      const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      let schemaDefinitionsCount = 0;
      return {
        SchemaDefinition(node) {
          if (alreadyDefined) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                "Cannot define a new schema within a schema extension.",
                {
                  nodes: node
                }
              )
            );
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                "Must provide only one schema definition.",
                {
                  nodes: node
                }
              )
            );
          }
          ++schemaDefinitionsCount;
        }
      };
    }
    __name(LoneSchemaDefinitionRule, "LoneSchemaDefinitionRule");
  }
});

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js
var require_MaxIntrospectionDepthRule = __commonJS({
  "node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var MAX_LISTS_DEPTH = 3;
    function MaxIntrospectionDepthRule(context2) {
      function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
        if (node.kind === _kinds.Kind.FRAGMENT_SPREAD) {
          const fragmentName = node.name.value;
          if (visitedFragments[fragmentName] === true) {
            return false;
          }
          const fragment = context2.getFragment(fragmentName);
          if (!fragment) {
            return false;
          }
          try {
            visitedFragments[fragmentName] = true;
            return checkDepth(fragment, visitedFragments, depth);
          } finally {
            visitedFragments[fragmentName] = void 0;
          }
        }
        if (node.kind === _kinds.Kind.FIELD && // check all introspection lists
        (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
          depth++;
          if (depth >= MAX_LISTS_DEPTH) {
            return true;
          }
        }
        if ("selectionSet" in node && node.selectionSet) {
          for (const child of node.selectionSet.selections) {
            if (checkDepth(child, visitedFragments, depth)) {
              return true;
            }
          }
        }
        return false;
      }
      __name(checkDepth, "checkDepth");
      return {
        Field(node) {
          if (node.name.value === "__schema" || node.name.value === "__type") {
            if (checkDepth(node)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  "Maximum introspection depth exceeded",
                  {
                    nodes: [node]
                  }
                )
              );
              return false;
            }
          }
        }
      };
    }
    __name(MaxIntrospectionDepthRule, "MaxIntrospectionDepthRule");
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context2) {
      const visitedFrags = /* @__PURE__ */ Object.create(null);
      const spreadPath = [];
      const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: /* @__PURE__ */ __name(() => false, "OperationDefinition"),
        FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        const fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        const spreadNodes = context2.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (const spreadNode of spreadNodes) {
          const spreadName = spreadNode.name.value;
          const cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            const spreadFragment = context2.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            const cyclePath = spreadPath.slice(cycleIndex);
            const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                {
                  nodes: cyclePath
                }
              )
            );
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
      __name(detectCycleRecursive, "detectCycleRecursive");
    }
    __name(NoFragmentCyclesRule, "NoFragmentCyclesRule");
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context2) {
      let variableNameDefined = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            variableNameDefined = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context2.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              const varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                    {
                      nodes: [node, operation]
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
    __name(NoUndefinedVariablesRule, "NoUndefinedVariablesRule");
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context2) {
      const operationDefs = [];
      const fragmentDefs = [];
      return {
        OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave() {
            const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
            for (const operation of operationDefs) {
              for (const fragment of context2.getRecursivelyReferencedFragments(
                operation
              )) {
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (const fragmentDef of fragmentDefs) {
              const fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment "${fragName}" is never used.`,
                    {
                      nodes: fragmentDef
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    __name(NoUnusedFragmentsRule, "NoUnusedFragmentsRule");
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context2) {
      let variableDefs = [];
      return {
        OperationDefinition: {
          enter() {
            variableDefs = [];
          },
          leave(operation) {
            const variableNameUsed = /* @__PURE__ */ Object.create(null);
            const usages = context2.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              variableNameUsed[node.name.value] = true;
            }
            for (const variableDef of variableDefs) {
              const variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                    {
                      nodes: variableDef
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
    __name(NoUnusedVariablesRule, "NoUnusedVariablesRule");
  }
});

// node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS({
  "node_modules/graphql/utilities/sortValueNode.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sortValueNode = sortValueNode;
    var _naturalCompare = require_naturalCompare();
    var _kinds = require_kinds();
    function sortValueNode(valueNode) {
      switch (valueNode.kind) {
        case _kinds.Kind.OBJECT:
          return { ...valueNode, fields: sortFields(valueNode.fields) };
        case _kinds.Kind.LIST:
          return { ...valueNode, values: valueNode.values.map(sortValueNode) };
        case _kinds.Kind.INT:
        case _kinds.Kind.FLOAT:
        case _kinds.Kind.STRING:
        case _kinds.Kind.BOOLEAN:
        case _kinds.Kind.NULL:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.VARIABLE:
          return valueNode;
      }
    }
    __name(sortValueNode, "sortValueNode");
    function sortFields(fields) {
      return fields.map((fieldNode) => ({
        ...fieldNode,
        value: sortValueNode(fieldNode.value)
      })).sort(
        (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
      );
    }
    __name(sortFields, "sortFields");
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _sortValueNode = require_sortValueNode();
    var _typeFromAST = require_typeFromAST();
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(
          ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
        ).join(" and ");
      }
      return reason;
    }
    __name(reasonMessage, "reasonMessage");
    function OverlappingFieldsCanBeMergedRule(context2) {
      const comparedFieldsAndFragmentPairs = new OrderedPairSet();
      const comparedFragmentPairs = new PairSet();
      const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
      return {
        SelectionSet(selectionSet) {
          const conflicts = findConflictsWithinSelectionSet(
            context2,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            context2.getParentType(),
            selectionSet
          );
          for (const [[responseName, reason], fields1, fields2] of conflicts) {
            const reasonMsg = reasonMessage(reason);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                {
                  nodes: fields1.concat(fields2)
                }
              )
            );
          }
        }
      };
    }
    __name(OverlappingFieldsCanBeMergedRule, "OverlappingFieldsCanBeMergedRule");
    function findConflictsWithinSelectionSet(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
      const conflicts = [];
      const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        parentType,
        selectionSet
      );
      collectConflictsWithin(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        fieldMap
      );
      if (fragmentNames.length !== 0) {
        for (let i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            fieldMap,
            fragmentNames[i]
          );
          for (let j = i + 1; j < fragmentNames.length; j++) {
            collectConflictsBetweenFragments(
              context2,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              false,
              fragmentNames[i],
              fragmentNames[j]
            );
          }
        }
      }
      return conflicts;
    }
    __name(findConflictsWithinSelectionSet, "findConflictsWithinSelectionSet");
    function collectConflictsBetweenFieldsAndFragment(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      if (comparedFieldsAndFragmentPairs.has(
        fieldMap,
        fragmentName,
        areMutuallyExclusive
      )) {
        return;
      }
      comparedFieldsAndFragmentPairs.add(
        fieldMap,
        fragmentName,
        areMutuallyExclusive
      );
      const fragment = context2.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragment
      );
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        fieldMap2
      );
      for (const referencedFragmentName of referencedFragmentNames) {
        collectConflictsBetweenFieldsAndFragment(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          referencedFragmentName
        );
      }
    }
    __name(collectConflictsBetweenFieldsAndFragment, "collectConflictsBetweenFieldsAndFragment");
    function collectConflictsBetweenFragments(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(
        fragmentName1,
        fragmentName2,
        areMutuallyExclusive
      )) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      const fragment1 = context2.getFragment(fragmentName1);
      const fragment2 = context2.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragment1
      );
      const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragment2
      );
      collectConflictsBetween(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const referencedFragmentName2 of referencedFragmentNames2) {
        collectConflictsBetweenFragments(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fragmentName1,
          referencedFragmentName2
        );
      }
      for (const referencedFragmentName1 of referencedFragmentNames1) {
        collectConflictsBetweenFragments(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          referencedFragmentName1,
          fragmentName2
        );
      }
    }
    __name(collectConflictsBetweenFragments, "collectConflictsBetweenFragments");
    function findConflictsBetweenSubSelectionSets(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      const conflicts = [];
      const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        parentType1,
        selectionSet1
      );
      const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        parentType2,
        selectionSet2
      );
      collectConflictsBetween(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFieldsAndFragment(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fragmentName2
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        collectConflictsBetweenFieldsAndFragment(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap2,
          fragmentName1
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFragments(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            fragmentName2
          );
        }
      }
      return conflicts;
    }
    __name(findConflictsBetweenSubSelectionSets, "findConflictsBetweenSubSelectionSets");
    function collectConflictsWithin(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
      for (const [responseName, fields] of Object.entries(fieldMap)) {
        if (fields.length > 1) {
          for (let i = 0; i < fields.length; i++) {
            for (let j = i + 1; j < fields.length; j++) {
              const conflict = findConflict(
                context2,
                cachedFieldsAndFragmentNames,
                comparedFieldsAndFragmentPairs,
                comparedFragmentPairs,
                false,
                // within one collection is never mutually exclusive
                responseName,
                fields[i],
                fields[j]
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    __name(collectConflictsWithin, "collectConflictsWithin");
    function collectConflictsBetween(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (const [responseName, fields1] of Object.entries(fieldMap1)) {
        const fields2 = fieldMap2[responseName];
        if (fields2) {
          for (const field1 of fields1) {
            for (const field2 of fields2) {
              const conflict = findConflict(
                context2,
                cachedFieldsAndFragmentNames,
                comparedFieldsAndFragmentPairs,
                comparedFragmentPairs,
                parentFieldsAreMutuallyExclusive,
                responseName,
                field1,
                field2
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    __name(collectConflictsBetween, "collectConflictsBetween");
    function findConflict(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      const [parentType1, node1, def1] = field1;
      const [parentType2, node2, def2] = field2;
      const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        const name1 = node1.name.value;
        const name2 = node2.name.value;
        if (name1 !== name2) {
          return [
            [responseName, `"${name1}" and "${name2}" are different fields`],
            [node1],
            [node2]
          ];
        }
        if (!sameArguments(node1, node2)) {
          return [
            [responseName, "they have differing arguments"],
            [node1],
            [node2]
          ];
        }
      }
      const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
          [
            responseName,
            `they return conflicting types "${(0, _inspect.inspect)(
              type1
            )}" and "${(0, _inspect.inspect)(type2)}"`
          ],
          [node1],
          [node2]
        ];
      }
      const selectionSet1 = node1.selectionSet;
      const selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        const conflicts = findConflictsBetweenSubSelectionSets(
          context2,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          (0, _definition.getNamedType)(type1),
          selectionSet1,
          (0, _definition.getNamedType)(type2),
          selectionSet2
        );
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    __name(findConflict, "findConflict");
    function sameArguments(node1, node2) {
      const args1 = node1.arguments;
      const args2 = node2.arguments;
      if (args1 === void 0 || args1.length === 0) {
        return args2 === void 0 || args2.length === 0;
      }
      if (args2 === void 0 || args2.length === 0) {
        return false;
      }
      if (args1.length !== args2.length) {
        return false;
      }
      const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
      return args1.every((arg1) => {
        const value1 = arg1.value;
        const value2 = values2.get(arg1.name.value);
        if (value2 === void 0) {
          return false;
        }
        return stringifyValue(value1) === stringifyValue(value2);
      });
    }
    __name(sameArguments, "sameArguments");
    function stringifyValue(value) {
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(value));
    }
    __name(stringifyValue, "stringifyValue");
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    __name(doTypesConflict, "doTypesConflict");
    function getFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      const cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (cached) {
        return cached;
      }
      const nodeAndDefs = /* @__PURE__ */ Object.create(null);
      const fragmentNames = /* @__PURE__ */ Object.create(null);
      _collectFieldsAndFragmentNames(
        context2,
        parentType,
        selectionSet,
        nodeAndDefs,
        fragmentNames
      );
      const result = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, result);
      return result;
    }
    __name(getFieldsAndFragmentNames, "getFieldsAndFragmentNames");
    function getReferencedFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, fragment) {
      const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      const fragmentType = (0, _typeFromAST.typeFromAST)(
        context2.getSchema(),
        fragment.typeCondition
      );
      return getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragmentType,
        fragment.selectionSet
      );
    }
    __name(getReferencedFieldsAndFragmentNames, "getReferencedFieldsAndFragmentNames");
    function _collectFieldsAndFragmentNames(context2, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            const fieldName = selection.name.value;
            let fieldDef;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            const responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            const typeCondition = selection.typeCondition;
            const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context2.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(
              context2,
              inlineFragmentType,
              selection.selectionSet,
              nodeAndDefs,
              fragmentNames
            );
            break;
          }
        }
      }
    }
    __name(_collectFieldsAndFragmentNames, "_collectFieldsAndFragmentNames");
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [
          [responseName, conflicts.map(([reason]) => reason)],
          [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
          [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
        ];
      }
    }
    __name(subfieldConflicts, "subfieldConflicts");
    var OrderedPairSet = class {
      static {
        __name(this, "OrderedPairSet");
      }
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, weaklyPresent) {
        var _this$_data$get;
        const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
        if (result === void 0) {
          return false;
        }
        return weaklyPresent ? true : weaklyPresent === result;
      }
      add(a, b, weaklyPresent) {
        const map = this._data.get(a);
        if (map === void 0) {
          this._data.set(a, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
        } else {
          map.set(b, weaklyPresent);
        }
      }
    };
    var PairSet = class {
      static {
        __name(this, "PairSet");
      }
      constructor() {
        this._orderedPairSet = new OrderedPairSet();
      }
      has(a, b, weaklyPresent) {
        return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);
      }
      add(a, b, weaklyPresent) {
        if (a < b) {
          this._orderedPairSet.add(a, b, weaklyPresent);
        } else {
          this._orderedPairSet.add(b, a, weaklyPresent);
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function PossibleFragmentSpreadsRule(context2) {
      return {
        InlineFragment(node) {
          const fragType = context2.getType();
          const parentType = context2.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
            context2.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        FragmentSpread(node) {
          const fragName = node.name.value;
          const fragType = getFragmentType(context2, fragName);
          const parentType = context2.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
            context2.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(PossibleFragmentSpreadsRule, "PossibleFragmentSpreadsRule");
    function getFragmentType(context2, name) {
      const frag = context2.getFragment(name);
      if (frag) {
        const type2 = (0, _typeFromAST.typeFromAST)(
          context2.getSchema(),
          frag.typeCondition
        );
        if ((0, _definition.isCompositeType)(type2)) {
          return type2;
        }
      }
    }
    __name(getFragmentType, "getFragmentType");
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    function PossibleTypeExtensionsRule(context2) {
      const schema = context2.getSchema();
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context2.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        const typeName = node.name.value;
        const defNode = definedTypes[typeName];
        const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        let expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            const kindStr = extensionKindToTypeName(node.kind);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend non-${kindStr} type "${typeName}".`,
                {
                  nodes: defNode ? [defNode, node] : node
                }
              )
            );
          }
        } else {
          const allTypeNames = Object.keys({
            ...definedTypes,
            ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
          });
          const suggestedTypes = (0, _suggestionList.suggestionList)(
            typeName,
            allTypeNames
          );
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
              {
                nodes: node.name
              }
            )
          );
        }
      }
      __name(checkExtension, "checkExtension");
    }
    __name(PossibleTypeExtensionsRule, "PossibleTypeExtensionsRule");
    var defKindToExtKind = {
      [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
      [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
      [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
    function typeToExtKind(type2) {
      if ((0, _definition.isScalarType)(type2)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type2)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type2)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type2)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(typeToExtKind, "typeToExtKind");
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
        // Not reachable. All possible types have been considered
        /* c8 ignore next */
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(kind)
          );
      }
    }
    __name(extensionKindToTypeName, "extensionKindToTypeName");
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    exports2.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    function ProvidedRequiredArgumentsRule(context2) {
      return {
        // eslint-disable-next-line new-cap
        ...ProvidedRequiredArgumentsOnDirectivesRule(context2),
        Field: {
          // Validate on leave to allow for deeper errors to appear first.
          leave(fieldNode) {
            var _fieldNode$arguments;
            const fieldDef = context2.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            const providedArgs = new Set(
              // FIXME: https://github.com/graphql/graphql-js/issues/2203
              /* c8 ignore next */
              (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
            );
            for (const argDef of fieldDef.args) {
              if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                const argTypeStr = (0, _inspect.inspect)(argDef.type);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                    {
                      nodes: fieldNode
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    __name(ProvidedRequiredArgumentsRule, "ProvidedRequiredArgumentsRule");
    function ProvidedRequiredArgumentsOnDirectivesRule(context2) {
      var _schema$getDirectives;
      const requiredArgsMap = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
          directive.args.filter(_definition.isRequiredArgument),
          (arg) => arg.name
        );
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
            argNodes.filter(isRequiredArgumentNode),
            (arg) => arg.name.value
          );
        }
      }
      return {
        Directive: {
          // Validate on leave to allow for deeper errors to appear first.
          leave(directiveNode) {
            const directiveName = directiveNode.name.value;
            const requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
              for (const [argName, argDef] of Object.entries(requiredArgs)) {
                if (!argNodeMap.has(argName)) {
                  const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                      {
                        nodes: directiveNode
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    __name(ProvidedRequiredArgumentsOnDirectivesRule, "ProvidedRequiredArgumentsOnDirectivesRule");
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
    __name(isRequiredArgumentNode, "isRequiredArgumentNode");
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function ScalarLeafsRule(context2) {
      return {
        Field(node) {
          const type2 = context2.getType();
          const selectionSet = node.selectionSet;
          if (type2) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type2))) {
              if (selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type2);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                    {
                      nodes: selectionSet
                    }
                  )
                );
              }
            } else if (!selectionSet) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type2);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                  {
                    nodes: node
                  }
                )
              );
            } else if (selectionSet.selections.length === 0) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type2);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(ScalarLeafsRule, "ScalarLeafsRule");
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "node_modules/graphql/jsutils/printPathArray.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printPathArray = printPathArray;
    function printPathArray(path) {
      return path.map(
        (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
      ).join("");
    }
    __name(printPathArray, "printPathArray");
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "node_modules/graphql/jsutils/Path.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addPath = addPath;
    exports2.pathToArray = pathToArray;
    function addPath(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    __name(addPath, "addPath");
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    __name(pathToArray, "pathToArray");
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "node_modules/graphql/utilities/coerceInputValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.coerceInputValue = coerceInputValue;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _Path = require_Path();
    var _printPathArray = require_printPathArray();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function coerceInputValue(inputValue, type2, onError = defaultOnError) {
      return coerceInputValueImpl(inputValue, type2, onError, void 0);
    }
    __name(coerceInputValue, "coerceInputValue");
    function defaultOnError(path, invalidValue, error3) {
      let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
      if (path.length > 0) {
        errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
      }
      error3.message = errorPrefix + ": " + error3.message;
      throw error3;
    }
    __name(defaultOnError, "defaultOnError");
    function coerceInputValueImpl(inputValue, type2, onError, path) {
      if ((0, _definition.isNonNullType)(type2)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type2.ofType, onError, path);
        }
        onError(
          (0, _Path.pathToArray)(path),
          inputValue,
          new _GraphQLError.GraphQLError(
            `Expected non-nullable type "${(0, _inspect.inspect)(
              type2
            )}" not to be null.`
          )
        );
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type2)) {
        const itemType = type2.ofType;
        if ((0, _isIterableObject.isIterableObject)(inputValue)) {
          return Array.from(inputValue, (itemValue, index) => {
            const itemPath = (0, _Path.addPath)(path, index, void 0);
            return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
          });
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        if (!(0, _isObjectLike.isObjectLike)(inputValue) || Array.isArray(inputValue)) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected type "${type2.name}" to be an object.`
            )
          );
          return;
        }
        const coercedValue = {};
        const fieldDefs = type2.getFields();
        for (const field of Object.values(fieldDefs)) {
          const fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              const typeStr = (0, _inspect.inspect)(field.type);
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${field.name}" of required type "${typeStr}" was not provided.`
                )
              );
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(
            fieldValue,
            field.type,
            onError,
            (0, _Path.addPath)(path, field.name, type2.name)
          );
        }
        for (const fieldName of Object.keys(inputValue)) {
          if (!fieldDefs[fieldName]) {
            const suggestions = (0, _suggestionList.suggestionList)(
              fieldName,
              Object.keys(type2.getFields())
            );
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Field "${fieldName}" is not defined by type "${type2.name}".` + (0, _didYouMean.didYouMean)(suggestions)
              )
            );
          }
        }
        if (type2.isOneOf) {
          const keys = Object.keys(coercedValue);
          if (keys.length !== 1) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Exactly one key must be specified for OneOf type "${type2.name}".`
              )
            );
          }
          const key = keys[0];
          const value = coercedValue[key];
          if (value === null) {
            onError(
              (0, _Path.pathToArray)(path).concat(key),
              value,
              new _GraphQLError.GraphQLError(`Field "${key}" must be non-null.`)
            );
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type2)) {
        let parseResult;
        try {
          parseResult = type2.parseValue(inputValue);
        } catch (error3) {
          if (error3 instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error3);
          } else {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type2.name}". ` + error3.message,
                {
                  originalError: error3
                }
              )
            );
          }
          return;
        }
        if (parseResult === void 0) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(`Expected type "${type2.name}".`)
          );
        }
        return parseResult;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(coerceInputValueImpl, "coerceInputValueImpl");
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "node_modules/graphql/utilities/valueFromAST.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromAST = valueFromAST;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _kinds = require_kinds();
    var _definition = require_definition();
    function valueFromAST(valueNode, type2, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        const variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type2)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST(valueNode, type2.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type2)) {
        const itemType = type2.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          const coercedValues = [];
          for (const itemNode of valueNode.values) {
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              const itemValue = valueFromAST(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        const coercedValue = valueFromAST(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        const coercedObj = /* @__PURE__ */ Object.create(null);
        const fieldNodes = (0, _keyMap.keyMap)(
          valueNode.fields,
          (field) => field.name.value
        );
        for (const field of Object.values(type2.getFields())) {
          const fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        if (type2.isOneOf) {
          const keys = Object.keys(coercedObj);
          if (keys.length !== 1) {
            return;
          }
          if (coercedObj[keys[0]] === null) {
            return;
          }
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type2)) {
        let result;
        try {
          result = type2.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(valueFromAST, "valueFromAST");
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
    __name(isMissingVariable, "isMissingVariable");
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "node_modules/graphql/execution/values.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getArgumentValues = getArgumentValues;
    exports2.getDirectiveValues = getDirectiveValues;
    exports2.getVariableValues = getVariableValues;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _printPathArray = require_printPathArray();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _coerceInputValue = require_coerceInputValue();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    function getVariableValues(schema, varDefNodes, inputs, options) {
      const errors = [];
      const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
      try {
        const coerced = coerceVariableValues(
          schema,
          varDefNodes,
          inputs,
          (error3) => {
            if (maxErrors != null && errors.length >= maxErrors) {
              throw new _GraphQLError.GraphQLError(
                "Too many errors processing variables, error limit reached. Execution aborted."
              );
            }
            errors.push(error3);
          }
        );
        if (errors.length === 0) {
          return {
            coerced
          };
        }
      } catch (error3) {
        errors.push(error3);
      }
      return {
        errors
      };
    }
    __name(getVariableValues, "getVariableValues");
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
      const coercedValues = {};
      for (const varDefNode of varDefNodes) {
        const varName = varDefNode.variable.name.value;
        const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          const varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
              {
                nodes: varDefNode.type
              }
            )
          );
          continue;
        }
        if (!hasOwnProperty(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
              varDefNode.defaultValue,
              varType
            );
          } else if ((0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                {
                  nodes: varDefNode
                }
              )
            );
          }
          continue;
        }
        const value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
              {
                nodes: varDefNode
              }
            )
          );
          continue;
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
          value,
          varType,
          (path, invalidValue, error3) => {
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
              prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                path
              )}"`;
            }
            onError(
              new _GraphQLError.GraphQLError(prefix + "; " + error3.message, {
                nodes: varDefNode,
                originalError: error3
              })
            );
          }
        );
      }
      return coercedValues;
    }
    __name(coerceVariableValues, "coerceVariableValues");
    function getArgumentValues(def, node, variableValues) {
      var _node$arguments;
      const coercedValues = {};
      const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      const argNodeMap = (0, _keyMap.keyMap)(
        argumentNodes,
        (arg) => arg.name.value
      );
      for (const argDef of def.args) {
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" of required type "${(0, _inspect.inspect)(
                argType
              )}" was not provided.`,
              {
                nodes: node
              }
            );
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                {
                  nodes: valueNode
                }
              );
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" of non-null type "${(0, _inspect.inspect)(
              argType
            )}" must not be null.`,
            {
              nodes: valueNode
            }
          );
        }
        const coercedValue = (0, _valueFromAST.valueFromAST)(
          valueNode,
          argType,
          variableValues
        );
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" has invalid value ${(0, _printer.print)(
              valueNode
            )}.`,
            {
              nodes: valueNode
            }
          );
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    __name(getArgumentValues, "getArgumentValues");
    function getDirectiveValues(directiveDef, node, variableValues) {
      var _node$directives;
      const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
        (directive) => directive.name.value === directiveDef.name
      );
      if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
      }
    }
    __name(getDirectiveValues, "getDirectiveValues");
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    __name(hasOwnProperty, "hasOwnProperty");
  }
});

// node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS({
  "node_modules/graphql/execution/collectFields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.collectFields = collectFields;
    exports2.collectSubfields = collectSubfields;
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _directives = require_directives();
    var _typeFromAST = require_typeFromAST();
    var _values = require_values();
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = /* @__PURE__ */ new Map();
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        runtimeType,
        selectionSet,
        fields,
        /* @__PURE__ */ new Set()
      );
      return fields;
    }
    __name(collectFields, "collectFields");
    function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            returnType,
            node.selectionSet,
            subFieldNodes,
            visitedFragmentNames
          );
        }
      }
      return subFieldNodes;
    }
    __name(collectSubfields, "collectSubfields");
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              runtimeType,
              selection.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              runtimeType,
              fragment.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
        }
      }
    }
    __name(collectFieldsImpl, "collectFieldsImpl");
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, _values.getDirectiveValues)(
        _directives.GraphQLSkipDirective,
        node,
        variableValues
      );
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      const include = (0, _values.getDirectiveValues)(
        _directives.GraphQLIncludeDirective,
        node,
        variableValues
      );
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    __name(shouldIncludeNode, "shouldIncludeNode");
    function doesFragmentConditionMatch(schema, fragment, type2) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, _typeFromAST.typeFromAST)(
        schema,
        typeConditionNode
      );
      if (conditionalType === type2) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return schema.isSubType(conditionalType, type2);
      }
      return false;
    }
    __name(doesFragmentConditionMatch, "doesFragmentConditionMatch");
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    __name(getFieldEntryKey, "getFieldEntryKey");
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _collectFields = require_collectFields();
    function SingleFieldSubscriptionsRule(context2) {
      return {
        OperationDefinition(node) {
          if (node.operation === "subscription") {
            const schema = context2.getSchema();
            const subscriptionType = schema.getSubscriptionType();
            if (subscriptionType) {
              const operationName = node.name ? node.name.value : null;
              const variableValues = /* @__PURE__ */ Object.create(null);
              const document = context2.getDocument();
              const fragments = /* @__PURE__ */ Object.create(null);
              for (const definition of document.definitions) {
                if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                  fragments[definition.name.value] = definition;
                }
              }
              const fields = (0, _collectFields.collectFields)(
                schema,
                fragments,
                variableValues,
                subscriptionType,
                node.selectionSet
              );
              if (fields.size > 1) {
                const fieldSelectionLists = [...fields.values()];
                const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                const extraFieldSelections = extraFieldSelectionLists.flat();
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                    {
                      nodes: extraFieldSelections
                    }
                  )
                );
              }
              for (const fieldNodes of fields.values()) {
                const field = fieldNodes[0];
                const fieldName = field.name.value;
                if (fieldName.startsWith("__")) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                      {
                        nodes: fieldNodes
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    __name(SingleFieldSubscriptionsRule, "SingleFieldSubscriptionsRule");
  }
});

// node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/graphql/jsutils/groupBy.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.groupBy = groupBy;
    function groupBy(list, keyFn) {
      const result = /* @__PURE__ */ new Map();
      for (const item of list) {
        const key = keyFn(item);
        const group3 = result.get(key);
        if (group3 === void 0) {
          result.set(key, [item]);
        } else {
          group3.push(item);
        }
      }
      return result;
    }
    __name(groupBy, "groupBy");
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentDefinitionNamesRule(context2) {
      return {
        DirectiveDefinition(directiveNode) {
          var _directiveNode$argume;
          const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField
      };
      function checkArgUniquenessPerField(typeNode) {
        var _typeNode$fields;
        const typeName = typeNode.name.value;
        const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
        for (const fieldDef of fieldNodes) {
          var _fieldDef$arguments;
          const fieldName = fieldDef.name.value;
          const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
          checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
        }
        return false;
      }
      __name(checkArgUniquenessPerField, "checkArgUniquenessPerField");
      function checkArgUniqueness(parentName, argumentNodes) {
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Argument "${parentName}(${argName}:)" can only be defined once.`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
        return false;
      }
      __name(checkArgUniqueness, "checkArgUniqueness");
    }
    __name(UniqueArgumentDefinitionNamesRule, "UniqueArgumentDefinitionNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context2) {
      return {
        Field: checkArgUniqueness,
        Directive: checkArgUniqueness
      };
      function checkArgUniqueness(parentNode) {
        var _parentNode$arguments;
        const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one argument named "${argName}".`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
      }
      __name(checkArgUniqueness, "checkArgUniqueness");
    }
    __name(UniqueArgumentNamesRule, "UniqueArgumentNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context2) {
      const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      return {
        DirectiveDefinition(node) {
          const directiveName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one directive named "@${directiveName}".`,
                {
                  nodes: [knownDirectiveNames[directiveName], node.name]
                }
              )
            );
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
    __name(UniqueDirectiveNamesRule, "UniqueDirectiveNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context2) {
      const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      const schemaDirectives = /* @__PURE__ */ Object.create(null);
      const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
      return {
        // Many different AST nodes may contain directives. Rather than listing
        // them all, just listen for entering any node, and check to see if it
        // defines any directives.
        enter(node) {
          if (!("directives" in node) || !node.directives) {
            return;
          }
          let seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            const typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
            }
          } else {
            seenDirectives = /* @__PURE__ */ Object.create(null);
          }
          for (const directive of node.directives) {
            const directiveName = directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `The directive "@${directiveName}" can only be used once at this location.`,
                    {
                      nodes: [seenDirectives[directiveName], directive]
                    }
                  )
                );
              } else {
                seenDirectives[directiveName] = directive;
              }
            }
          }
        }
      };
    }
    __name(UniqueDirectivesPerLocationRule, "UniqueDirectivesPerLocationRule");
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context2) {
      const schema = context2.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownValueNames = /* @__PURE__ */ Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        const typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        const valueNames = knownValueNames[typeName];
        for (const valueDef of valueNodes) {
          const valueName = valueDef.name.value;
          const existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: valueDef.name
                }
              )
            );
          } else if (valueNames[valueName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" can only be defined once.`,
                {
                  nodes: [valueNames[valueName], valueDef.name]
                }
              )
            );
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
      __name(checkValueUniqueness, "checkValueUniqueness");
    }
    __name(UniqueEnumValueNamesRule, "UniqueEnumValueNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context2) {
      const schema = context2.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownFieldNames = /* @__PURE__ */ Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        const typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        const fieldNames = knownFieldNames[typeName];
        for (const fieldDef of fieldNodes) {
          const fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: fieldDef.name
                }
              )
            );
          } else if (fieldNames[fieldName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" can only be defined once.`,
                {
                  nodes: [fieldNames[fieldName], fieldDef.name]
                }
              )
            );
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
      __name(checkFieldUniqueness, "checkFieldUniqueness");
    }
    __name(UniqueFieldDefinitionNamesRule, "UniqueFieldDefinitionNamesRule");
    function hasField(type2, fieldName) {
      if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2) || (0, _definition.isInputObjectType)(type2)) {
        return type2.getFields()[fieldName] != null;
      }
      return false;
    }
    __name(hasField, "hasField");
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context2) {
      const knownFragmentNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: /* @__PURE__ */ __name(() => false, "OperationDefinition"),
        FragmentDefinition(node) {
          const fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one fragment named "${fragmentName}".`,
                {
                  nodes: [knownFragmentNames[fragmentName], node.name]
                }
              )
            );
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
    __name(UniqueFragmentNamesRule, "UniqueFragmentNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context2) {
      const knownNameStack = [];
      let knownNames = /* @__PURE__ */ Object.create(null);
      return {
        ObjectValue: {
          enter() {
            knownNameStack.push(knownNames);
            knownNames = /* @__PURE__ */ Object.create(null);
          },
          leave() {
            const prevKnownNames = knownNameStack.pop();
            prevKnownNames || (0, _invariant.invariant)(false);
            knownNames = prevKnownNames;
          }
        },
        ObjectField(node) {
          const fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one input field named "${fieldName}".`,
                {
                  nodes: [knownNames[fieldName], node.name]
                }
              )
            );
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
    __name(UniqueInputFieldNamesRule, "UniqueInputFieldNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context2) {
      const knownOperationNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition(node) {
          const operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one operation named "${operationName.value}".`,
                  {
                    nodes: [
                      knownOperationNames[operationName.value],
                      operationName
                    ]
                  }
                )
              );
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: /* @__PURE__ */ __name(() => false, "FragmentDefinition")
      };
    }
    __name(UniqueOperationNamesRule, "UniqueOperationNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context2) {
      const schema = context2.getSchema();
      const definedOperationTypes = /* @__PURE__ */ Object.create(null);
      const existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          const operation = operationType.operation;
          const alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                {
                  nodes: operationType
                }
              )
            );
          } else if (alreadyDefinedOperationType) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one ${operation} type in schema.`,
                {
                  nodes: [alreadyDefinedOperationType, operationType]
                }
              )
            );
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
      __name(checkOperationTypes, "checkOperationTypes");
    }
    __name(UniqueOperationTypesRule, "UniqueOperationTypesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context2) {
      const knownTypeNames = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        const typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
              {
                nodes: node.name
              }
            )
          );
          return;
        }
        if (knownTypeNames[typeName]) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `There can be only one type named "${typeName}".`,
              {
                nodes: [knownTypeNames[typeName], node.name]
              }
            )
          );
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
      __name(checkTypeName, "checkTypeName");
    }
    __name(UniqueTypeNamesRule, "UniqueTypeNamesRule");
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context2) {
      return {
        OperationDefinition(operationNode) {
          var _operationNode$variab;
          const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
          const seenVariableDefinitions = (0, _groupBy.groupBy)(
            variableDefinitions,
            (node) => node.variable.name.value
          );
          for (const [variableName, variableNodes] of seenVariableDefinitions) {
            if (variableNodes.length > 1) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one variable named "$${variableName}".`,
                  {
                    nodes: variableNodes.map((node) => node.variable.name)
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(UniqueVariableNamesRule, "UniqueVariableNamesRule");
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    function ValuesOfCorrectTypeRule(context2) {
      let variableDefinitions = {};
      return {
        OperationDefinition: {
          enter() {
            variableDefinitions = {};
          }
        },
        VariableDefinition(definition) {
          variableDefinitions[definition.variable.name.value] = definition;
        },
        ListValue(node) {
          const type2 = (0, _definition.getNullableType)(
            context2.getParentInputType()
          );
          if (!(0, _definition.isListType)(type2)) {
            isValidValueNode(context2, node);
            return false;
          }
        },
        ObjectValue(node) {
          const type2 = (0, _definition.getNamedType)(context2.getInputType());
          if (!(0, _definition.isInputObjectType)(type2)) {
            isValidValueNode(context2, node);
            return false;
          }
          const fieldNodeMap = (0, _keyMap.keyMap)(
            node.fields,
            (field) => field.name.value
          );
          for (const fieldDef of Object.values(type2.getFields())) {
            const fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              const typeStr = (0, _inspect.inspect)(fieldDef.type);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
          if (type2.isOneOf) {
            validateOneOfInputObject(
              context2,
              node,
              type2,
              fieldNodeMap,
              variableDefinitions
            );
          }
        },
        ObjectField(node) {
          const parentType = (0, _definition.getNamedType)(
            context2.getParentInputType()
          );
          const fieldType = context2.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            const suggestions = (0, _suggestionList.suggestionList)(
              node.name.value,
              Object.keys(parentType.getFields())
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: node
                }
              )
            );
          }
        },
        NullValue(node) {
          const type2 = context2.getInputType();
          if ((0, _definition.isNonNullType)(type2)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${(0, _inspect.inspect)(
                  type2
                )}", found ${(0, _printer.print)(node)}.`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        EnumValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "EnumValue"),
        IntValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "IntValue"),
        FloatValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "FloatValue"),
        StringValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "StringValue"),
        BooleanValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "BooleanValue")
      };
    }
    __name(ValuesOfCorrectTypeRule, "ValuesOfCorrectTypeRule");
    function isValidValueNode(context2, node) {
      const locationType = context2.getInputType();
      if (!locationType) {
        return;
      }
      const type2 = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type2)) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context2.reportError(
          new _GraphQLError.GraphQLError(
            `Expected value of type "${typeStr}", found ${(0, _printer.print)(
              node
            )}.`,
            {
              nodes: node
            }
          )
        );
        return;
      }
      try {
        const parseResult = type2.parseLiteral(
          node,
          void 0
          /* variables */
        );
        if (parseResult === void 0) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
        }
      } catch (error3) {
        const typeStr = (0, _inspect.inspect)(locationType);
        if (error3 instanceof _GraphQLError.GraphQLError) {
          context2.reportError(error3);
        } else {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}; ` + error3.message,
              {
                nodes: node,
                originalError: error3
              }
            )
          );
        }
      }
    }
    __name(isValidValueNode, "isValidValueNode");
    function validateOneOfInputObject(context2, node, type2, fieldNodeMap, variableDefinitions) {
      var _fieldNodeMap$keys$;
      const keys = Object.keys(fieldNodeMap);
      const isNotExactlyOneField = keys.length !== 1;
      if (isNotExactlyOneField) {
        context2.reportError(
          new _GraphQLError.GraphQLError(
            `OneOf Input Object "${type2.name}" must specify exactly one key.`,
            {
              nodes: [node]
            }
          )
        );
        return;
      }
      const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
      const isNullLiteral = !value || value.kind === _kinds.Kind.NULL;
      const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === _kinds.Kind.VARIABLE;
      if (isNullLiteral) {
        context2.reportError(
          new _GraphQLError.GraphQLError(
            `Field "${type2.name}.${keys[0]}" must be non-null.`,
            {
              nodes: [node]
            }
          )
        );
        return;
      }
      if (isVariable) {
        const variableName = value.name.value;
        const definition = variableDefinitions[variableName];
        const isNullableVariable = definition.type.kind !== _kinds.Kind.NON_NULL_TYPE;
        if (isNullableVariable) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
              {
                nodes: [node]
              }
            )
          );
        }
      }
    }
    __name(validateOneOfInputObject, "validateOneOfInputObject");
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context2) {
      return {
        VariableDefinition(node) {
          const type2 = (0, _typeFromAST.typeFromAST)(
            context2.getSchema(),
            node.type
          );
          if (type2 !== void 0 && !(0, _definition.isInputType)(type2)) {
            const variableName = node.variable.name.value;
            const typeName = (0, _printer.print)(node.type);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                {
                  nodes: node.type
                }
              )
            );
          }
        }
      };
    }
    __name(VariablesAreInputTypesRule, "VariablesAreInputTypesRule");
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function VariablesInAllowedPositionRule(context2) {
      let varDefMap = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            varDefMap = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context2.getRecursiveVariableUsages(operation);
            for (const { node, type: type2, defaultValue, parentType } of usages) {
              const varName = node.name.value;
              const varDef = varDefMap[varName];
              if (varDef && type2) {
                const schema = context2.getSchema();
                const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                if (varType && !allowedVariableUsage(
                  schema,
                  varType,
                  varDef.defaultValue,
                  type2,
                  defaultValue
                )) {
                  const varTypeStr = (0, _inspect.inspect)(varType);
                  const typeStr = (0, _inspect.inspect)(type2);
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                      {
                        nodes: [varDef, node]
                      }
                    )
                  );
                }
                if ((0, _definition.isInputObjectType)(parentType) && parentType.isOneOf && (0, _definition.isNullableType)(varType)) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`,
                      {
                        nodes: [varDef, node]
                      }
                    )
                  );
                }
              }
            }
          }
        },
        VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    __name(VariablesInAllowedPositionRule, "VariablesInAllowedPositionRule");
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        const hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        const nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(
          schema,
          varType,
          nullableLocationType
        );
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
    }
    __name(allowedVariableUsage, "allowedVariableUsage");
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "node_modules/graphql/validation/specifiedRules.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.specifiedSDLRules = exports2.specifiedRules = exports2.recommendedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var recommendedRules = Object.freeze([
      _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule
    ]);
    exports2.recommendedRules = recommendedRules;
    var specifiedRules = Object.freeze([
      _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
      _UniqueOperationNamesRule.UniqueOperationNamesRule,
      _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
      _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
      _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
      _ScalarLeafsRule.ScalarLeafsRule,
      _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
      _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
      _KnownFragmentNamesRule.KnownFragmentNamesRule,
      _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
      _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
      _NoFragmentCyclesRule.NoFragmentCyclesRule,
      _UniqueVariableNamesRule.UniqueVariableNamesRule,
      _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
      _NoUnusedVariablesRule.NoUnusedVariablesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _KnownArgumentNamesRule.KnownArgumentNamesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
      _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
      _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      ...recommendedRules
    ]);
    exports2.specifiedRules = specifiedRules;
    var specifiedSDLRules = Object.freeze([
      _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
      _UniqueOperationTypesRule.UniqueOperationTypesRule,
      _UniqueTypeNamesRule.UniqueTypeNamesRule,
      _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
      _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
      _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
      _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
      _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
    ]);
    exports2.specifiedSDLRules = specifiedSDLRules;
  }
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "node_modules/graphql/validation/ValidationContext.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValidationContext = exports2.SDLValidationContext = exports2.ASTValidationContext = void 0;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    var ASTValidationContext = class {
      static {
        __name(this, "ASTValidationContext");
      }
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error3) {
        this._onError(error3);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    exports2.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = class extends ASTValidationContext {
      static {
        __name(this, "SDLValidationContext");
      }
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    exports2.SDLValidationContext = SDLValidationContext;
    var ValidationContext = class extends ASTValidationContext {
      static {
        __name(this, "ValidationContext");
      }
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(
            node,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
              VariableDefinition: /* @__PURE__ */ __name(() => false, "VariableDefinition"),
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue(),
                  parentType: typeInfo.getParentInputType()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
    exports2.ValidationContext = ValidationContext;
  }
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "node_modules/graphql/validation/validate.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSDL = assertValidSDL;
    exports2.assertValidSDLExtension = assertValidSDLExtension;
    exports2.validate = validate;
    exports2.validateSDL = validateSDL;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
      var _options$maxErrors;
      const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
      documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      const abortObj = Object.freeze({});
      const errors = [];
      const context2 = new _ValidationContext.ValidationContext(
        schema,
        documentAST,
        typeInfo,
        (error3) => {
          if (errors.length >= maxErrors) {
            errors.push(
              new _GraphQLError.GraphQLError(
                "Too many validation errors, error limit reached. Validation aborted."
              )
            );
            throw abortObj;
          }
          errors.push(error3);
        }
      );
      const visitor = (0, _visitor.visitInParallel)(
        rules.map((rule) => rule(context2))
      );
      try {
        (0, _visitor.visit)(
          documentAST,
          (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
        );
      } catch (e) {
        if (e !== abortObj) {
          throw e;
        }
      }
      return errors;
    }
    __name(validate, "validate");
    function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
      const errors = [];
      const context2 = new _ValidationContext.SDLValidationContext(
        documentAST,
        schemaToExtend,
        (error3) => {
          errors.push(error3);
        }
      );
      const visitors = rules.map((rule) => rule(context2));
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors;
    }
    __name(validateSDL, "validateSDL");
    function assertValidSDL(documentAST) {
      const errors = validateSDL(documentAST);
      if (errors.length !== 0) {
        throw new Error(errors.map((error3) => error3.message).join("\n\n"));
      }
    }
    __name(assertValidSDL, "assertValidSDL");
    function assertValidSDLExtension(documentAST, schema) {
      const errors = validateSDL(documentAST, schema);
      if (errors.length !== 0) {
        throw new Error(errors.map((error3) => error3.message).join("\n\n"));
      }
    }
    __name(assertValidSDLExtension, "assertValidSDLExtension");
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "node_modules/graphql/jsutils/memoize3.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.memoize3 = memoize3;
    function memoize3(fn) {
      let cache0;
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3) {
        if (cache0 === void 0) {
          cache0 = /* @__PURE__ */ new WeakMap();
        }
        let cache1 = cache0.get(a1);
        if (cache1 === void 0) {
          cache1 = /* @__PURE__ */ new WeakMap();
          cache0.set(a1, cache1);
        }
        let cache2 = cache1.get(a2);
        if (cache2 === void 0) {
          cache2 = /* @__PURE__ */ new WeakMap();
          cache1.set(a2, cache2);
        }
        let fnResult = cache2.get(a3);
        if (fnResult === void 0) {
          fnResult = fn(a1, a2, a3);
          cache2.set(a3, fnResult);
        }
        return fnResult;
      }, "memoized");
    }
    __name(memoize3, "memoize3");
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "node_modules/graphql/jsutils/promiseForObject.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseForObject = promiseForObject;
    function promiseForObject(object) {
      return Promise.all(Object.values(object)).then((resolvedValues) => {
        const resolvedObject = /* @__PURE__ */ Object.create(null);
        for (const [i, key] of Object.keys(object).entries()) {
          resolvedObject[key] = resolvedValues[i];
        }
        return resolvedObject;
      });
    }
    __name(promiseForObject, "promiseForObject");
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "node_modules/graphql/jsutils/promiseReduce.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseReduce = promiseReduce;
    var _isPromise = require_isPromise();
    function promiseReduce(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    __name(promiseReduce, "promiseReduce");
  }
});

// node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS({
  "node_modules/graphql/jsutils/toError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toError = toError;
    var _inspect = require_inspect();
    function toError(thrownValue) {
      return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
    }
    __name(toError, "toError");
    var NonErrorThrown = class extends Error {
      static {
        __name(this, "NonErrorThrown");
      }
      constructor(thrownValue) {
        super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "node_modules/graphql/error/locatedError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.locatedError = locatedError;
    var _toError = require_toError();
    var _GraphQLError = require_GraphQLError();
    function locatedError(rawOriginalError, nodes, path) {
      var _nodes;
      const originalError = (0, _toError.toError)(rawOriginalError);
      if (isLocatedGraphQLError(originalError)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, {
        nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
        source: originalError.source,
        positions: originalError.positions,
        path,
        originalError
      });
    }
    __name(locatedError, "locatedError");
    function isLocatedGraphQLError(error3) {
      return Array.isArray(error3.path);
    }
    __name(isLocatedGraphQLError, "isLocatedGraphQLError");
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "node_modules/graphql/execution/execute.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidExecutionArguments = assertValidExecutionArguments;
    exports2.buildExecutionContext = buildExecutionContext;
    exports2.buildResolveInfo = buildResolveInfo;
    exports2.defaultTypeResolver = exports2.defaultFieldResolver = void 0;
    exports2.execute = execute;
    exports2.executeSync = executeSync;
    exports2.getFieldDef = getFieldDef;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _isPromise = require_isPromise();
    var _memoize = require_memoize3();
    var _Path = require_Path();
    var _promiseForObject = require_promiseForObject();
    var _promiseReduce = require_promiseReduce();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _collectFields = require_collectFields();
    var _values = require_values();
    var collectSubfields = (0, _memoize.memoize3)(
      (exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    function execute(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const { schema, document, variableValues, rootValue } = args;
      assertValidExecutionArguments(schema, document, variableValues);
      const exeContext = buildExecutionContext(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const { operation } = exeContext;
        const result = executeOperation(exeContext, operation, rootValue);
        if ((0, _isPromise.isPromise)(result)) {
          return result.then(
            (data) => buildResponse(data, exeContext.errors),
            (error3) => {
              exeContext.errors.push(error3);
              return buildResponse(null, exeContext.errors);
            }
          );
        }
        return buildResponse(result, exeContext.errors);
      } catch (error3) {
        exeContext.errors.push(error3);
        return buildResponse(null, exeContext.errors);
      }
    }
    __name(execute, "execute");
    function executeSync(args) {
      const result = execute(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    __name(executeSync, "executeSync");
    function buildResponse(data, errors) {
      return errors.length === 0 ? {
        data
      } : {
        errors,
        data
      };
    }
    __name(buildResponse, "buildResponse");
    function assertValidExecutionArguments(schema, document, rawVariableValues) {
      document || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(
        false,
        "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
      );
    }
    __name(assertValidExecutionArguments, "assertValidExecutionArguments");
    function buildExecutionContext(args) {
      var _definition$name, _operation$variableDe, _options$maxCoercionE;
      const {
        schema,
        document,
        rootValue,
        contextValue,
        variableValues: rawVariableValues,
        operationName,
        fieldResolver,
        typeResolver,
        subscribeFieldResolver,
        options
      } = args;
      let operation;
      const fragments = /* @__PURE__ */ Object.create(null);
      for (const definition of document.definitions) {
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [
                  new _GraphQLError.GraphQLError(
                    "Must provide operation name if query contains multiple operations."
                  )
                ];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
          default:
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [
            new _GraphQLError.GraphQLError(
              `Unknown operation named "${operationName}".`
            )
          ];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      const coercedVariableValues = (0, _values.getVariableValues)(
        schema,
        variableDefinitions,
        rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
        {
          maxErrors: (_options$maxCoercionE = options === null || options === void 0 ? void 0 : options.maxCoercionErrors) !== null && _options$maxCoercionE !== void 0 ? _options$maxCoercionE : 50
        }
      );
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
        errors: []
      };
    }
    __name(buildExecutionContext, "buildExecutionContext");
    function executeOperation(exeContext, operation, rootValue) {
      const rootType = exeContext.schema.getRootType(operation.operation);
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          `Schema is not configured to execute ${operation.operation} operation.`,
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        rootType,
        operation.selectionSet
      );
      const path = void 0;
      switch (operation.operation) {
        case _ast.OperationTypeNode.QUERY:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.MUTATION:
          return executeFieldsSerially(
            exeContext,
            rootType,
            rootValue,
            path,
            rootFields
          );
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
      }
    }
    __name(executeOperation, "executeOperation");
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.promiseReduce)(
        fields.entries(),
        (results, [responseName, fieldNodes]) => {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result === void 0) {
            return results;
          }
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult) => {
              results[responseName] = resolvedResult;
              return results;
            });
          }
          results[responseName] = result;
          return results;
        },
        /* @__PURE__ */ Object.create(null)
      );
    }
    __name(executeFieldsSerially, "executeFieldsSerially");
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
      const results = /* @__PURE__ */ Object.create(null);
      let containsPromise = false;
      try {
        for (const [responseName, fieldNodes] of fields.entries()) {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result !== void 0) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
              containsPromise = true;
            }
          }
        }
      } catch (error3) {
        if (containsPromise) {
          return (0, _promiseForObject.promiseForObject)(results).finally(() => {
            throw error3;
          });
        }
        throw error3;
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.promiseForObject)(results);
    }
    __name(executeFields, "executeFields");
    function executeField(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
      if (!fieldDef) {
        return;
      }
      const returnType = fieldDef.type;
      const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      const info3 = buildResolveInfo(
        exeContext,
        fieldDef,
        fieldNodes,
        parentType,
        path
      );
      try {
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          exeContext.variableValues
        );
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info3);
        let completed;
        if ((0, _isPromise.isPromise)(result)) {
          completed = result.then(
            (resolved) => completeValue(exeContext, returnType, fieldNodes, info3, path, resolved)
          );
        } else {
          completed = completeValue(
            exeContext,
            returnType,
            fieldNodes,
            info3,
            path,
            result
          );
        }
        if ((0, _isPromise.isPromise)(completed)) {
          return completed.then(void 0, (rawError) => {
            const error3 = (0, _locatedError.locatedError)(
              rawError,
              fieldNodes,
              (0, _Path.pathToArray)(path)
            );
            return handleFieldError(error3, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        const error3 = (0, _locatedError.locatedError)(
          rawError,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
        return handleFieldError(error3, returnType, exeContext);
      }
    }
    __name(executeField, "executeField");
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    __name(buildResolveInfo, "buildResolveInfo");
    function handleFieldError(error3, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error3;
      }
      exeContext.errors.push(error3);
      return null;
    }
    __name(handleFieldError, "handleFieldError");
    function completeValue(exeContext, returnType, fieldNodes, info3, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        const completed = completeValue(
          exeContext,
          returnType.ofType,
          fieldNodes,
          info3,
          path,
          result
        );
        if (completed === null) {
          throw new Error(
            `Cannot return null for non-nullable field ${info3.parentType.name}.${info3.fieldName}.`
          );
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue(
          exeContext,
          returnType,
          fieldNodes,
          info3,
          path,
          result
        );
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(
          exeContext,
          returnType,
          fieldNodes,
          info3,
          path,
          result
        );
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(
          exeContext,
          returnType,
          fieldNodes,
          info3,
          path,
          result
        );
      }
      (0, _invariant.invariant)(
        false,
        "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType)
      );
    }
    __name(completeValue, "completeValue");
    function completeListValue(exeContext, returnType, fieldNodes, info3, path, result) {
      if (!(0, _isIterableObject.isIterableObject)(result)) {
        throw new _GraphQLError.GraphQLError(
          `Expected Iterable, but did not find one for field "${info3.parentType.name}.${info3.fieldName}".`
        );
      }
      const itemType = returnType.ofType;
      let containsPromise = false;
      const completedResults = Array.from(result, (item, index) => {
        const itemPath = (0, _Path.addPath)(path, index, void 0);
        try {
          let completedItem;
          if ((0, _isPromise.isPromise)(item)) {
            completedItem = item.then(
              (resolved) => completeValue(
                exeContext,
                itemType,
                fieldNodes,
                info3,
                itemPath,
                resolved
              )
            );
          } else {
            completedItem = completeValue(
              exeContext,
              itemType,
              fieldNodes,
              info3,
              itemPath,
              item
            );
          }
          if ((0, _isPromise.isPromise)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, (rawError) => {
              const error3 = (0, _locatedError.locatedError)(
                rawError,
                fieldNodes,
                (0, _Path.pathToArray)(itemPath)
              );
              return handleFieldError(error3, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          const error3 = (0, _locatedError.locatedError)(
            rawError,
            fieldNodes,
            (0, _Path.pathToArray)(itemPath)
          );
          return handleFieldError(error3, itemType, exeContext);
        }
      });
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    __name(completeListValue, "completeListValue");
    function completeLeafValue(returnType, result) {
      const serializedResult = returnType.serialize(result);
      if (serializedResult == null) {
        throw new Error(
          `Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(
            serializedResult
          )}`
        );
      }
      return serializedResult;
    }
    __name(completeLeafValue, "completeLeafValue");
    function completeAbstractValue(exeContext, returnType, fieldNodes, info3, path, result) {
      var _returnType$resolveTy;
      const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      const contextValue = exeContext.contextValue;
      const runtimeType = resolveTypeFn(result, contextValue, info3, returnType);
      if ((0, _isPromise.isPromise)(runtimeType)) {
        return runtimeType.then(
          (resolvedRuntimeType) => completeObjectValue(
            exeContext,
            ensureValidRuntimeType(
              resolvedRuntimeType,
              exeContext,
              returnType,
              fieldNodes,
              info3,
              result
            ),
            fieldNodes,
            info3,
            path,
            result
          )
        );
      }
      return completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          runtimeType,
          exeContext,
          returnType,
          fieldNodes,
          info3,
          result
        ),
        fieldNodes,
        info3,
        path,
        result
      );
    }
    __name(completeAbstractValue, "completeAbstractValue");
    function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info3, result) {
      if (runtimeTypeName == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info3.parentType.name}.${info3.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
          fieldNodes
        );
      }
      if ((0, _definition.isObjectType)(runtimeTypeName)) {
        throw new _GraphQLError.GraphQLError(
          "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
        );
      }
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info3.parentType.name}.${info3.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`
        );
      }
      const runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      return runtimeType;
    }
    __name(ensureValidRuntimeType, "ensureValidRuntimeType");
    function completeObjectValue(exeContext, returnType, fieldNodes, info3, path, result) {
      const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
      if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info3);
        if ((0, _isPromise.isPromise)(isTypeOf)) {
          return isTypeOf.then((resolvedIsTypeOf) => {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return executeFields(
              exeContext,
              returnType,
              result,
              path,
              subFieldNodes
            );
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
      }
      return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    __name(completeObjectValue, "completeObjectValue");
    function invalidReturnTypeError(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError(
        `Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`,
        {
          nodes: fieldNodes
        }
      );
    }
    __name(invalidReturnTypeError, "invalidReturnTypeError");
    var defaultTypeResolver = /* @__PURE__ */ __name(function(value, contextValue, info3, abstractType) {
      if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info3.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type2 = possibleTypes[i];
        if (type2.isTypeOf) {
          const isTypeOfResult = type2.isTypeOf(value, contextValue, info3);
          if ((0, _isPromise.isPromise)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type2.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    }, "defaultTypeResolver");
    exports2.defaultTypeResolver = defaultTypeResolver;
    var defaultFieldResolver = /* @__PURE__ */ __name(function(source, args, contextValue, info3) {
      if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
        const property = source[info3.fieldName];
        if (typeof property === "function") {
          return source[info3.fieldName](args, contextValue, info3);
        }
        return property;
      }
    }, "defaultFieldResolver");
    exports2.defaultFieldResolver = defaultFieldResolver;
    function getFieldDef(schema, parentType, fieldNode) {
      const fieldName = fieldNode.name.value;
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
    __name(getFieldDef, "getFieldDef");
  }
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS({
  "node_modules/graphql/graphql.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.graphql = graphql;
    exports2.graphqlSync = graphqlSync;
    var _devAssert = require_devAssert();
    var _isPromise = require_isPromise();
    var _parser = require_parser();
    var _validate = require_validate();
    var _validate2 = require_validate2();
    var _execute = require_execute();
    function graphql(args) {
      return new Promise((resolve) => resolve(graphqlImpl(args)));
    }
    __name(graphql, "graphql");
    function graphqlSync(args) {
      const result = graphqlImpl(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    __name(graphqlSync, "graphqlSync");
    function graphqlImpl(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const {
        schema,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      } = args;
      const schemaValidationErrors = (0, _validate.validateSchema)(schema);
      if (schemaValidationErrors.length > 0) {
        return {
          errors: schemaValidationErrors
        };
      }
      let document;
      try {
        document = (0, _parser.parse)(source);
      } catch (syntaxError) {
        return {
          errors: [syntaxError]
        };
      }
      const validationErrors = (0, _validate2.validate)(schema, document);
      if (validationErrors.length > 0) {
        return {
          errors: validationErrors
        };
      }
      return (0, _execute.execute)({
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
    __name(graphqlImpl, "graphqlImpl");
  }
});

// node_modules/graphql/type/index.js
var require_type = __commonJS({
  "node_modules/graphql/type/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.DEFAULT_DEPRECATION_REASON;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GRAPHQL_MAX_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GRAPHQL_MIN_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLBoolean;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLDeprecatedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLFloat;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLID;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLIncludeDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLInt;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLList;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLNonNull;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLOneOfDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLOneOfDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _schema.GraphQLSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLSkipDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLSpecifiedByDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLString;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.SchemaMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.TypeMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.TypeNameMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Directive;
      }, "get")
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__EnumValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Field;
      }, "get")
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__InputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Schema;
      }, "get")
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Type;
      }, "get")
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.assertDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertName.assertEnumValueName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertListType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertName.assertName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _schema.assertSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _validate.assertValidSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.getNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.getNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.introspectionTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.isDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.isIntrospectionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isListType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isRequiredArgument;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isRequiredInputField;
      }, "get")
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _schema.isSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.isSpecifiedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.isSpecifiedScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isType;
      }, "get")
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.resolveObjMapThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.resolveReadonlyArrayThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.specifiedDirectives;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.specifiedScalarTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _validate.validateSchema;
      }, "get")
    });
    var _schema = require_schema();
    var _definition = require_definition();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _assertName = require_assertName();
  }
});

// node_modules/graphql/language/index.js
var require_language = __commonJS({
  "node_modules/graphql/language/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.BREAK;
      }, "get")
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directiveLocation.DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _kinds.Kind;
      }, "get")
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _lexer.Lexer;
      }, "get")
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ast.Location;
      }, "get")
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ast.OperationTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _source.Source;
      }, "get")
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ast.Token;
      }, "get")
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _tokenKind.TokenKind;
      }, "get")
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.getEnterLeaveForKind;
      }, "get")
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _location.getLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.getVisitFn;
      }, "get")
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isConstValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isExecutableDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isSelectionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeSystemDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeSystemExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parse;
      }, "get")
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parseConstValue;
      }, "get")
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parseType;
      }, "get")
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parseValue;
      }, "get")
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printer.print;
      }, "get")
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printLocation.printLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printLocation.printSourceLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.visit;
      }, "get")
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.visitInParallel;
      }, "get")
    });
    var _source = require_source();
    var _location = require_location();
    var _printLocation = require_printLocation();
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _parser = require_parser();
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _ast = require_ast();
    var _predicates = require_predicates();
    var _directiveLocation = require_directiveLocation();
  }
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/graphql/jsutils/isAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = isAsyncIterable;
    function isAsyncIterable(maybeAsyncIterable) {
      return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
    }
    __name(isAsyncIterable, "isAsyncIterable");
  }
});

// node_modules/graphql/execution/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/graphql/execution/mapAsyncIterator.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapAsyncIterator = mapAsyncIterator;
    function mapAsyncIterator(iterable, callback) {
      const iterator = iterable[Symbol.asyncIterator]();
      async function mapResult(result) {
        if (result.done) {
          return result;
        }
        try {
          return {
            value: await callback(result.value),
            done: false
          };
        } catch (error3) {
          if (typeof iterator.return === "function") {
            try {
              await iterator.return();
            } catch (_e) {
            }
          }
          throw error3;
        }
      }
      __name(mapResult, "mapResult");
      return {
        async next() {
          return mapResult(await iterator.next());
        },
        async return() {
          return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
            value: void 0,
            done: true
          };
        },
        async throw(error3) {
          if (typeof iterator.throw === "function") {
            return mapResult(await iterator.throw(error3));
          }
          throw error3;
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(mapAsyncIterator, "mapAsyncIterator");
  }
});

// node_modules/graphql/execution/subscribe.js
var require_subscribe = __commonJS({
  "node_modules/graphql/execution/subscribe.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSourceEventStream = createSourceEventStream;
    exports2.subscribe = subscribe;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isAsyncIterable = require_isAsyncIterable();
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _collectFields = require_collectFields();
    var _execute = require_execute();
    var _mapAsyncIterator = require_mapAsyncIterator();
    var _values = require_values();
    async function subscribe(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const resultOrStream = await createSourceEventStream(args);
      if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
        return resultOrStream;
      }
      const mapSourceToResponse = /* @__PURE__ */ __name((payload) => (0, _execute.execute)({ ...args, rootValue: payload }), "mapSourceToResponse");
      return (0, _mapAsyncIterator.mapAsyncIterator)(
        resultOrStream,
        mapSourceToResponse
      );
    }
    __name(subscribe, "subscribe");
    function toNormalizedArgs(args) {
      const firstArg = args[0];
      if (firstArg && "document" in firstArg) {
        return firstArg;
      }
      return {
        schema: firstArg,
        // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        subscribeFieldResolver: args[6]
      };
    }
    __name(toNormalizedArgs, "toNormalizedArgs");
    async function createSourceEventStream(...rawArgs) {
      const args = toNormalizedArgs(rawArgs);
      const { schema, document, variableValues } = args;
      (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
      const exeContext = (0, _execute.buildExecutionContext)(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const eventStream = await executeSubscription(exeContext);
        if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
          throw new Error(
            `Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`
          );
        }
        return eventStream;
      } catch (error3) {
        if (error3 instanceof _GraphQLError.GraphQLError) {
          return {
            errors: [error3]
          };
        }
        throw error3;
      }
    }
    __name(createSourceEventStream, "createSourceEventStream");
    async function executeSubscription(exeContext) {
      const { schema, fragments, operation, variableValues, rootValue } = exeContext;
      const rootType = schema.getSubscriptionType();
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          "Schema is not configured to execute subscription operation.",
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        schema,
        fragments,
        variableValues,
        rootType,
        operation.selectionSet
      );
      const [responseName, fieldNodes] = [...rootFields.entries()][0];
      const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
      if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new _GraphQLError.GraphQLError(
          `The subscription field "${fieldName}" is not defined.`,
          {
            nodes: fieldNodes
          }
        );
      }
      const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
      const info3 = (0, _execute.buildResolveInfo)(
        exeContext,
        fieldDef,
        fieldNodes,
        rootType,
        path
      );
      try {
        var _fieldDef$subscribe;
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          variableValues
        );
        const contextValue = exeContext.contextValue;
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = await resolveFn(rootValue, args, contextValue, info3);
        if (eventStream instanceof Error) {
          throw eventStream;
        }
        return eventStream;
      } catch (error3) {
        throw (0, _locatedError.locatedError)(
          error3,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
      }
    }
    __name(executeSubscription, "executeSubscription");
  }
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS({
  "node_modules/graphql/execution/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _subscribe.createSourceEventStream;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.defaultFieldResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.defaultTypeResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.execute;
      }, "get")
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.executeSync;
      }, "get")
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _values.getArgumentValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _values.getDirectiveValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _values.getVariableValues;
      }, "get")
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _Path.pathToArray;
      }, "get")
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _subscribe.subscribe;
      }, "get")
    });
    var _Path = require_Path();
    var _execute = require_execute();
    var _subscribe = require_subscribe();
    var _values = require_values();
  }
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function NoDeprecatedCustomRule(context2) {
      return {
        Field(node) {
          const fieldDef = context2.getFieldDef();
          const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
          if (fieldDef && deprecationReason != null) {
            const parentType = context2.getParentType();
            parentType != null || (0, _invariant.invariant)(false);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        Argument(node) {
          const argDef = context2.getArgument();
          const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
          if (argDef && deprecationReason != null) {
            const directiveDef = context2.getDirective();
            if (directiveDef != null) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            } else {
              const parentType = context2.getParentType();
              const fieldDef = context2.getFieldDef();
              parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        ObjectField(node) {
          const inputObjectDef = (0, _definition.getNamedType)(
            context2.getParentInputType()
          );
          if ((0, _definition.isInputObjectType)(inputObjectDef)) {
            const inputFieldDef = inputObjectDef.getFields()[node.name.value];
            const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
            if (deprecationReason != null) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        EnumValue(node) {
          const enumValueDef = context2.getEnumValue();
          const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
          if (enumValueDef && deprecationReason != null) {
            const enumTypeDef = (0, _definition.getNamedType)(
              context2.getInputType()
            );
            enumTypeDef != null || (0, _invariant.invariant)(false);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(NoDeprecatedCustomRule, "NoDeprecatedCustomRule");
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _introspection = require_introspection();
    function NoSchemaIntrospectionCustomRule(context2) {
      return {
        Field(node) {
          const type2 = (0, _definition.getNamedType)(context2.getType());
          if (type2 && (0, _introspection.isIntrospectionType)(type2)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(NoSchemaIntrospectionCustomRule, "NoSchemaIntrospectionCustomRule");
  }
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS({
  "node_modules/graphql/validation/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownDirectivesRule.KnownDirectivesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "MaxIntrospectionDepthRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ScalarLeafsRule.ScalarLeafsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ValidationContext.ValidationContext;
      }, "get")
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "recommendedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _specifiedRules.recommendedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _specifiedRules.specifiedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _validate.validate;
      }, "get")
    });
    var _validate = require_validate2();
    var _ValidationContext = require_ValidationContext();
    var _specifiedRules = require_specifiedRules();
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/graphql/error/index.js
var require_error = __commonJS({
  "node_modules/graphql/error/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _GraphQLError.GraphQLError;
      }, "get")
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _GraphQLError.formatError;
      }, "get")
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _locatedError.locatedError;
      }, "get")
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _GraphQLError.printError;
      }, "get")
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _syntaxError.syntaxError;
      }, "get")
    });
    var _GraphQLError = require_GraphQLError();
    var _syntaxError = require_syntaxError();
    var _locatedError = require_locatedError();
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getIntrospectionQuery = getIntrospectionQuery;
    function getIntrospectionQuery(options) {
      const optionsWithDefault = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        oneOf: false,
        ...options
      };
      const descriptions = optionsWithDefault.descriptions ? "description" : "";
      const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
      const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      __name(inputDeprecation, "inputDeprecation");
      const oneOf = optionsWithDefault.oneOf ? "isOneOf" : "";
      return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    }
    __name(getIntrospectionQuery, "getIntrospectionQuery");
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "node_modules/graphql/utilities/getOperationAST.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationAST = getOperationAST;
    var _kinds = require_kinds();
    function getOperationAST(documentAST, operationName) {
      let operation = null;
      for (const definition of documentAST.definitions) {
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
    __name(getOperationAST, "getOperationAST");
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "node_modules/graphql/utilities/getOperationRootType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationRootType = getOperationRootType;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType(schema, operation) {
      if (operation.operation === "query") {
        const queryType = schema.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError(
            "Schema does not define the required query root type.",
            {
              nodes: operation
            }
          );
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        const mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for mutations.",
            {
              nodes: operation
            }
          );
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        const subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for subscriptions.",
            {
              nodes: operation
            }
          );
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError(
        "Can only have query, mutation and subscription operations.",
        {
          nodes: operation
        }
      );
    }
    __name(getOperationRootType, "getOperationRootType");
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "node_modules/graphql/utilities/introspectionFromSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionFromSchema = introspectionFromSchema;
    var _invariant = require_invariant();
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function introspectionFromSchema(schema, options) {
      const optionsWithDefaults = {
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true,
        oneOf: true,
        ...options
      };
      const document = (0, _parser.parse)(
        (0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults)
      );
      const result = (0, _execute.executeSync)({
        schema,
        document
      });
      !result.errors && result.data || (0, _invariant.invariant)(false);
      return result.data;
    }
    __name(introspectionFromSchema, "introspectionFromSchema");
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "node_modules/graphql/utilities/buildClientSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildClientSchema = buildClientSchema;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _keyValMap = require_keyValMap();
    var _parser = require_parser();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _valueFromAST = require_valueFromAST();
    function buildClientSchema(introspection, options) {
      (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(
        false,
        `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`
      );
      const schemaIntrospection = introspection.__schema;
      const typeMap = (0, _keyValMap.keyValMap)(
        schemaIntrospection.types,
        (typeIntrospection) => typeIntrospection.name,
        (typeIntrospection) => buildType(typeIntrospection)
      );
      for (const stdType of [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ]) {
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: Object.values(typeMap),
        directives,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
      function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          const itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          const nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          const nullableType = getType(nullableRef);
          return new _definition.GraphQLNonNull(
            (0, _definition.assertNullableType)(nullableType)
          );
        }
        return getNamedType(typeRef);
      }
      __name(getType, "getType");
      function getNamedType(typeRef) {
        const typeName = typeRef.name;
        if (!typeName) {
          throw new Error(
            `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`
          );
        }
        const type2 = typeMap[typeName];
        if (!type2) {
          throw new Error(
            `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
          );
        }
        return type2;
      }
      __name(getNamedType, "getNamedType");
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType(typeRef));
      }
      __name(getObjectType, "getObjectType");
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
      }
      __name(getInterfaceType, "getInterfaceType");
      function buildType(type2) {
        if (type2 != null && type2.name != null && type2.kind != null) {
          switch (type2.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type2);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type2);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type2);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type2);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type2);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type2);
          }
        }
        const typeStr = (0, _inspect.inspect)(type2);
        throw new Error(
          `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
        );
      }
      __name(buildType, "buildType");
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByURL: scalarIntrospection.specifiedByURL
        });
      }
      __name(buildScalarDef, "buildScalarDef");
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          const implementingIntrospectionStr = (0, _inspect.inspect)(
            implementingIntrospection
          );
          throw new Error(
            `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
          );
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      __name(buildImplementationsList, "buildImplementationsList");
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: /* @__PURE__ */ __name(() => buildImplementationsList(objectIntrospection), "interfaces"),
          fields: /* @__PURE__ */ __name(() => buildFieldDefMap(objectIntrospection), "fields")
        });
      }
      __name(buildObjectDef, "buildObjectDef");
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: /* @__PURE__ */ __name(() => buildImplementationsList(interfaceIntrospection), "interfaces"),
          fields: /* @__PURE__ */ __name(() => buildFieldDefMap(interfaceIntrospection), "fields")
        });
      }
      __name(buildInterfaceDef, "buildInterfaceDef");
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
          throw new Error(
            `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: /* @__PURE__ */ __name(() => unionIntrospection.possibleTypes.map(getObjectType), "types")
        });
      }
      __name(buildUnionDef, "buildUnionDef");
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
          throw new Error(
            `Introspection result missing enumValues: ${enumIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.keyValMap)(
            enumIntrospection.enumValues,
            (valueIntrospection) => valueIntrospection.name,
            (valueIntrospection) => ({
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            })
          )
        });
      }
      __name(buildEnumDef, "buildEnumDef");
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          const inputObjectIntrospectionStr = (0, _inspect.inspect)(
            inputObjectIntrospection
          );
          throw new Error(
            `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: /* @__PURE__ */ __name(() => buildInputValueDefMap(inputObjectIntrospection.inputFields), "fields"),
          isOneOf: inputObjectIntrospection.isOneOf
        });
      }
      __name(buildInputObjectDef, "buildInputObjectDef");
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error(
            `Introspection result missing fields: ${(0, _inspect.inspect)(
              typeIntrospection
            )}.`
          );
        }
        return (0, _keyValMap.keyValMap)(
          typeIntrospection.fields,
          (fieldIntrospection) => fieldIntrospection.name,
          buildField
        );
      }
      __name(buildFieldDefMap, "buildFieldDefMap");
      function buildField(fieldIntrospection) {
        const type2 = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type2)) {
          const typeStr = (0, _inspect.inspect)(type2);
          throw new Error(
            `Introspection must provide output type for fields, but received: ${typeStr}.`
          );
        }
        if (!fieldIntrospection.args) {
          const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
          throw new Error(
            `Introspection result missing field args: ${fieldIntrospectionStr}.`
          );
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type: type2,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      __name(buildField, "buildField");
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.keyValMap)(
          inputValueIntrospections,
          (inputValue) => inputValue.name,
          buildInputValue
        );
      }
      __name(buildInputValueDefMap, "buildInputValueDefMap");
      function buildInputValue(inputValueIntrospection) {
        const type2 = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type2)) {
          const typeStr = (0, _inspect.inspect)(type2);
          throw new Error(
            `Introspection must provide input type for arguments, but received: ${typeStr}.`
          );
        }
        const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)(
          (0, _parser.parseValue)(inputValueIntrospection.defaultValue),
          type2
        ) : void 0;
        return {
          description: inputValueIntrospection.description,
          type: type2,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      __name(buildInputValue, "buildInputValue");
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive args: ${directiveIntrospectionStr}.`
          );
        }
        if (!directiveIntrospection.locations) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
          );
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
      __name(buildDirective, "buildDirective");
    }
    __name(buildClientSchema, "buildClientSchema");
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "node_modules/graphql/utilities/extendSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendSchema = extendSchema;
    exports2.extendSchemaImpl = extendSchemaImpl;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _mapValue = require_mapValue();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _values = require_values();
    var _valueFromAST = require_valueFromAST();
    function extendSchema(schema, documentAST, options) {
      (0, _schema.assertSchema)(schema);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
      }
      const schemaConfig = schema.toConfig();
      const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
      return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
    }
    __name(extendSchema, "extendSchema");
    function extendSchemaImpl(schemaConfig, documentAST, options) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      const typeDefs2 = [];
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directiveDefs = [];
      let schemaDef;
      const schemaExtensions = [];
      for (const def of documentAST.definitions) {
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs2.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          const extendedTypeName = def.name.value;
          const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs2.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      const typeMap = /* @__PURE__ */ Object.create(null);
      for (const existingType of schemaConfig.types) {
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (const typeNode of typeDefs2) {
        var _stdTypeMap$name;
        const name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      const operationTypes = {
        // Get the extended root operation types.
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
        // Then, incorporate schema definition and all schema extensions.
        ...schemaDef && getOperationTypes([schemaDef]),
        ...getOperationTypes(schemaExtensions)
      };
      return {
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
        ...operationTypes,
        types: Object.values(typeMap),
        directives: [
          ...schemaConfig.directives.map(replaceDirective),
          ...directiveDefs.map(buildDirective)
        ],
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      };
      function replaceType(type2) {
        if ((0, _definition.isListType)(type2)) {
          return new _definition.GraphQLList(replaceType(type2.ofType));
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return new _definition.GraphQLNonNull(replaceType(type2.ofType));
        }
        return replaceNamedType(type2);
      }
      __name(replaceType, "replaceType");
      function replaceNamedType(type2) {
        return typeMap[type2.name];
      }
      __name(replaceNamedType, "replaceNamedType");
      function replaceDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          args: (0, _mapValue.mapValue)(config2.args, extendArg)
        });
      }
      __name(replaceDirective, "replaceDirective");
      function extendNamedType(type2) {
        if ((0, _introspection.isIntrospectionType)(type2) || (0, _scalars.isSpecifiedScalarType)(type2)) {
          return type2;
        }
        if ((0, _definition.isScalarType)(type2)) {
          return extendScalarType(type2);
        }
        if ((0, _definition.isObjectType)(type2)) {
          return extendObjectType(type2);
        }
        if ((0, _definition.isInterfaceType)(type2)) {
          return extendInterfaceType(type2);
        }
        if ((0, _definition.isUnionType)(type2)) {
          return extendUnionType(type2);
        }
        if ((0, _definition.isEnumType)(type2)) {
          return extendEnumType(type2);
        }
        if ((0, _definition.isInputObjectType)(type2)) {
          return extendInputObjectType(type2);
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type2)
        );
      }
      __name(extendNamedType, "extendNamedType");
      function extendInputObjectType(type2) {
        var _typeExtensionsMap$co;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType({
          ...config2,
          fields: /* @__PURE__ */ __name(() => ({
            ...(0, _mapValue.mapValue)(config2.fields, (field) => ({
              ...field,
              type: replaceType(field.type)
            })),
            ...buildInputFieldMap(extensions)
          }), "fields"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendInputObjectType, "extendInputObjectType");
      function extendEnumType(type2) {
        var _typeExtensionsMap$ty;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType({
          ...config2,
          values: { ...config2.values, ...buildEnumValueMap(extensions) },
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendEnumType, "extendEnumType");
      function extendScalarType(type2) {
        var _typeExtensionsMap$co2;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        let specifiedByURL = config2.specifiedByURL;
        for (const extensionNode of extensions) {
          var _getSpecifiedByURL;
          specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
        }
        return new _definition.GraphQLScalarType({
          ...config2,
          specifiedByURL,
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendScalarType, "extendScalarType");
      function extendObjectType(type2) {
        var _typeExtensionsMap$co3;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType({
          ...config2,
          interfaces: /* @__PURE__ */ __name(() => [
            ...type2.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ], "interfaces"),
          fields: /* @__PURE__ */ __name(() => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }), "fields"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendObjectType, "extendObjectType");
      function extendInterfaceType(type2) {
        var _typeExtensionsMap$co4;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType({
          ...config2,
          interfaces: /* @__PURE__ */ __name(() => [
            ...type2.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ], "interfaces"),
          fields: /* @__PURE__ */ __name(() => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }), "fields"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendInterfaceType, "extendInterfaceType");
      function extendUnionType(type2) {
        var _typeExtensionsMap$co5;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType({
          ...config2,
          types: /* @__PURE__ */ __name(() => [
            ...type2.getTypes().map(replaceNamedType),
            ...buildUnionTypes(extensions)
          ], "types"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendUnionType, "extendUnionType");
      function extendField(field) {
        return {
          ...field,
          type: replaceType(field.type),
          args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
        };
      }
      __name(extendField, "extendField");
      function extendArg(arg) {
        return { ...arg, type: replaceType(arg.type) };
      }
      __name(extendArg, "extendArg");
      function getOperationTypes(nodes) {
        const opTypes = {};
        for (const node of nodes) {
          var _node$operationTypes;
          const operationTypesNodes = (
            /* c8 ignore next */
            (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
          );
          for (const operationType of operationTypesNodes) {
            opTypes[operationType.operation] = getNamedType(operationType.type);
          }
        }
        return opTypes;
      }
      __name(getOperationTypes, "getOperationTypes");
      function getNamedType(node) {
        var _stdTypeMap$name2;
        const name = node.name.value;
        const type2 = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
        if (type2 === void 0) {
          throw new Error(`Unknown type: "${name}".`);
        }
        return type2;
      }
      __name(getNamedType, "getNamedType");
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType(node);
      }
      __name(getWrappedType, "getWrappedType");
      function buildDirective(node) {
        var _node$description;
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
          // @ts-expect-error
          locations: node.locations.map(({ value }) => value),
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      __name(buildDirective, "buildDirective");
      function buildFieldMap(nodes) {
        const fieldConfigMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields;
          const nodeFields = (
            /* c8 ignore next */
            (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
          );
          for (const field of nodeFields) {
            var _field$description;
            fieldConfigMap[field.name.value] = {
              // Note: While this could make assertions to get the correctly typed
              // value, that would throw immediately while type system validation
              // with validateSchema() will produce more actionable results.
              type: getWrappedType(field.type),
              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      __name(buildFieldMap, "buildFieldMap");
      function buildArgumentMap(args) {
        const argsNodes = (
          /* c8 ignore next */
          args !== null && args !== void 0 ? args : []
        );
        const argConfigMap = /* @__PURE__ */ Object.create(null);
        for (const arg of argsNodes) {
          var _arg$description;
          const type2 = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type: type2,
            description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type2),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      __name(buildArgumentMap, "buildArgumentMap");
      function buildInputFieldMap(nodes) {
        const inputFieldMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields2;
          const fieldsNodes = (
            /* c8 ignore next */
            (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
          );
          for (const field of fieldsNodes) {
            var _field$description2;
            const type2 = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type: type2,
              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(
                field.defaultValue,
                type2
              ),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      __name(buildInputFieldMap, "buildInputFieldMap");
      function buildEnumValueMap(nodes) {
        const enumValueMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$values;
          const valuesNodes = (
            /* c8 ignore next */
            (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
          );
          for (const value of valuesNodes) {
            var _value$description;
            enumValueMap[value.name.value] = {
              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      __name(buildEnumValueMap, "buildEnumValueMap");
      function buildInterfaces(nodes) {
        return nodes.flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (node) => {
            var _node$interfaces$map, _node$interfaces;
            return (
              /* c8 ignore next */
              (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
            );
          }
        );
      }
      __name(buildInterfaces, "buildInterfaces");
      function buildUnionTypes(nodes) {
        return nodes.flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (node) => {
            var _node$types$map, _node$types;
            return (
              /* c8 ignore next */
              (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []
            );
          }
        );
      }
      __name(buildUnionTypes, "buildUnionTypes");
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        const name = astNode.name.value;
        const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var _astNode$description;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLObjectType({
              name,
              description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
              interfaces: /* @__PURE__ */ __name(() => buildInterfaces(allNodes), "interfaces"),
              fields: /* @__PURE__ */ __name(() => buildFieldMap(allNodes), "fields"),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _astNode$description2;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInterfaceType({
              name,
              description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
              interfaces: /* @__PURE__ */ __name(() => buildInterfaces(allNodes), "interfaces"),
              fields: /* @__PURE__ */ __name(() => buildFieldMap(allNodes), "fields"),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _astNode$description3;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLEnumType({
              name,
              description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
              values: buildEnumValueMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _astNode$description4;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLUnionType({
              name,
              description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
              types: /* @__PURE__ */ __name(() => buildUnionTypes(allNodes), "types"),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _astNode$description5;
            return new _definition.GraphQLScalarType({
              name,
              description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
              specifiedByURL: getSpecifiedByURL(astNode),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _astNode$description6;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInputObjectType({
              name,
              description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
              fields: /* @__PURE__ */ __name(() => buildInputFieldMap(allNodes), "fields"),
              astNode,
              extensionASTNodes,
              isOneOf: isOneOf(astNode)
            });
          }
        }
      }
      __name(buildType, "buildType");
    }
    __name(extendSchemaImpl, "extendSchemaImpl");
    var stdTypeMap = (0, _keyMap.keyMap)(
      [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],
      (type2) => type2.name
    );
    function getDeprecationReason(node) {
      const deprecated = (0, _values.getDirectiveValues)(
        _directives.GraphQLDeprecatedDirective,
        node
      );
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    __name(getDeprecationReason, "getDeprecationReason");
    function getSpecifiedByURL(node) {
      const specifiedBy = (0, _values.getDirectiveValues)(
        _directives.GraphQLSpecifiedByDirective,
        node
      );
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
    __name(getSpecifiedByURL, "getSpecifiedByURL");
    function isOneOf(node) {
      return Boolean(
        (0, _values.getDirectiveValues)(_directives.GraphQLOneOfDirective, node)
      );
    }
    __name(isOneOf, "isOneOf");
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "node_modules/graphql/utilities/buildASTSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildASTSchema = buildASTSchema;
    exports2.buildSchema = buildSchema;
    var _devAssert = require_devAssert();
    var _kinds = require_kinds();
    var _parser = require_parser();
    var _directives = require_directives();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _extendSchema = require_extendSchema();
    function buildASTSchema(documentAST, options) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      const emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: /* @__PURE__ */ Object.create(null),
        extensionASTNodes: [],
        assumeValid: false
      };
      const config2 = (0, _extendSchema.extendSchemaImpl)(
        emptySchemaConfig,
        documentAST,
        options
      );
      if (config2.astNode == null) {
        for (const type2 of config2.types) {
          switch (type2.name) {
            // Note: While this could make early assertions to get the correctly
            // typed values below, that would throw immediately while type system
            // validation with validateSchema() will produce more actionable results.
            case "Query":
              config2.query = type2;
              break;
            case "Mutation":
              config2.mutation = type2;
              break;
            case "Subscription":
              config2.subscription = type2;
              break;
          }
        }
      }
      const directives = [
        ...config2.directives,
        // If specified directives were not explicitly declared, add them.
        ..._directives.specifiedDirectives.filter(
          (stdDirective) => config2.directives.every(
            (directive) => directive.name !== stdDirective.name
          )
        )
      ];
      return new _schema.GraphQLSchema({ ...config2, directives });
    }
    __name(buildASTSchema, "buildASTSchema");
    function buildSchema(source, options) {
      const document = (0, _parser.parse)(source, {
        noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
        allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
      });
      return buildASTSchema(document, {
        assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
    }
    __name(buildSchema, "buildSchema");
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lexicographicSortSchema = lexicographicSortSchema;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyValMap = require_keyValMap();
    var _naturalCompare = require_naturalCompare();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function lexicographicSortSchema(schema) {
      const schemaConfig = schema.toConfig();
      const typeMap = (0, _keyValMap.keyValMap)(
        sortByName(schemaConfig.types),
        (type2) => type2.name,
        sortNamedType
      );
      return new _schema.GraphQLSchema({
        ...schemaConfig,
        types: Object.values(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      });
      function replaceType(type2) {
        if ((0, _definition.isListType)(type2)) {
          return new _definition.GraphQLList(replaceType(type2.ofType));
        } else if ((0, _definition.isNonNullType)(type2)) {
          return new _definition.GraphQLNonNull(replaceType(type2.ofType));
        }
        return replaceNamedType(type2);
      }
      __name(replaceType, "replaceType");
      function replaceNamedType(type2) {
        return typeMap[type2.name];
      }
      __name(replaceNamedType, "replaceNamedType");
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      __name(replaceMaybeType, "replaceMaybeType");
      function sortDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          locations: sortBy(config2.locations, (x) => x),
          args: sortArgs(config2.args)
        });
      }
      __name(sortDirective, "sortDirective");
      function sortArgs(args) {
        return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
      }
      __name(sortArgs, "sortArgs");
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type),
          args: field.args && sortArgs(field.args)
        }));
      }
      __name(sortFields, "sortFields");
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type)
        }));
      }
      __name(sortInputFields, "sortInputFields");
      function sortTypes(array) {
        return sortByName(array).map(replaceNamedType);
      }
      __name(sortTypes, "sortTypes");
      function sortNamedType(type2) {
        if ((0, _definition.isScalarType)(type2) || (0, _introspection.isIntrospectionType)(type2)) {
          return type2;
        }
        if ((0, _definition.isObjectType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLObjectType({
            ...config2,
            interfaces: /* @__PURE__ */ __name(() => sortTypes(config2.interfaces), "interfaces"),
            fields: /* @__PURE__ */ __name(() => sortFields(config2.fields), "fields")
          });
        }
        if ((0, _definition.isInterfaceType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLInterfaceType({
            ...config2,
            interfaces: /* @__PURE__ */ __name(() => sortTypes(config2.interfaces), "interfaces"),
            fields: /* @__PURE__ */ __name(() => sortFields(config2.fields), "fields")
          });
        }
        if ((0, _definition.isUnionType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLUnionType({
            ...config2,
            types: /* @__PURE__ */ __name(() => sortTypes(config2.types), "types")
          });
        }
        if ((0, _definition.isEnumType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLEnumType({
            ...config2,
            values: sortObjMap(config2.values, (value) => value)
          });
        }
        if ((0, _definition.isInputObjectType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLInputObjectType({
            ...config2,
            fields: /* @__PURE__ */ __name(() => sortInputFields(config2.fields), "fields")
          });
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type2)
        );
      }
      __name(sortNamedType, "sortNamedType");
    }
    __name(lexicographicSortSchema, "lexicographicSortSchema");
    function sortObjMap(map, sortValueFn) {
      const sortedMap = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
        sortedMap[key] = sortValueFn(map[key]);
      }
      return sortedMap;
    }
    __name(sortObjMap, "sortObjMap");
    function sortByName(array) {
      return sortBy(array, (obj) => obj.name);
    }
    __name(sortByName, "sortByName");
    function sortBy(array, mapToKey) {
      return array.slice().sort((obj1, obj2) => {
        const key1 = mapToKey(obj1);
        const key2 = mapToKey(obj2);
        return (0, _naturalCompare.naturalCompare)(key1, key2);
      });
    }
    __name(sortBy, "sortBy");
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "node_modules/graphql/utilities/printSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printIntrospectionSchema = printIntrospectionSchema;
    exports2.printSchema = printSchema;
    exports2.printType = printType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _blockString = require_blockString();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    function printSchema(schema) {
      return printFilteredSchema(
        schema,
        (n) => !(0, _directives.isSpecifiedDirective)(n),
        isDefinedType
      );
    }
    __name(printSchema, "printSchema");
    function printIntrospectionSchema(schema) {
      return printFilteredSchema(
        schema,
        _directives.isSpecifiedDirective,
        _introspection.isIntrospectionType
      );
    }
    __name(printIntrospectionSchema, "printIntrospectionSchema");
    function isDefinedType(type2) {
      return !(0, _scalars.isSpecifiedScalarType)(type2) && !(0, _introspection.isIntrospectionType)(type2);
    }
    __name(isDefinedType, "isDefinedType");
    function printFilteredSchema(schema, directiveFilter, typeFilter) {
      const directives = schema.getDirectives().filter(directiveFilter);
      const types3 = Object.values(schema.getTypeMap()).filter(typeFilter);
      return [
        printSchemaDefinition(schema),
        ...directives.map((directive) => printDirective(directive)),
        ...types3.map((type2) => printType(type2))
      ].filter(Boolean).join("\n\n");
    }
    __name(printFilteredSchema, "printFilteredSchema");
    function printSchemaDefinition(schema) {
      if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
      }
      const operationTypes = [];
      const queryType = schema.getQueryType();
      if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
      }
      return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
    }
    __name(printSchemaDefinition, "printSchemaDefinition");
    function isSchemaOfCommonNames(schema) {
      const queryType = schema.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      const mutationType = schema.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    __name(isSchemaOfCommonNames, "isSchemaOfCommonNames");
    function printType(type2) {
      if ((0, _definition.isScalarType)(type2)) {
        return printScalar(type2);
      }
      if ((0, _definition.isObjectType)(type2)) {
        return printObject(type2);
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return printInterface(type2);
      }
      if ((0, _definition.isUnionType)(type2)) {
        return printUnion(type2);
      }
      if ((0, _definition.isEnumType)(type2)) {
        return printEnum(type2);
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return printInputObject(type2);
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(printType, "printType");
    function printScalar(type2) {
      return printDescription(type2) + `scalar ${type2.name}` + printSpecifiedByURL(type2);
    }
    __name(printScalar, "printScalar");
    function printImplementedInterfaces(type2) {
      const interfaces = type2.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
    }
    __name(printImplementedInterfaces, "printImplementedInterfaces");
    function printObject(type2) {
      return printDescription(type2) + `type ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
    }
    __name(printObject, "printObject");
    function printInterface(type2) {
      return printDescription(type2) + `interface ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
    }
    __name(printInterface, "printInterface");
    function printUnion(type2) {
      const types3 = type2.getTypes();
      const possibleTypes = types3.length ? " = " + types3.join(" | ") : "";
      return printDescription(type2) + "union " + type2.name + possibleTypes;
    }
    __name(printUnion, "printUnion");
    function printEnum(type2) {
      const values = type2.getValues().map(
        (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
      );
      return printDescription(type2) + `enum ${type2.name}` + printBlock(values);
    }
    __name(printEnum, "printEnum");
    function printInputObject(type2) {
      const fields = Object.values(type2.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
      );
      return printDescription(type2) + `input ${type2.name}` + (type2.isOneOf ? " @oneOf" : "") + printBlock(fields);
    }
    __name(printInputObject, "printInputObject");
    function printFields(type2) {
      const fields = Object.values(type2.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
      );
      return printBlock(fields);
    }
    __name(printFields, "printFields");
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    __name(printBlock, "printBlock");
    function printArgs(args, indentation = "") {
      if (args.length === 0) {
        return "";
      }
      if (args.every((arg) => !arg.description)) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map(
        (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
      ).join("\n") + "\n" + indentation + ")";
    }
    __name(printArgs, "printArgs");
    function printInputValue(arg) {
      const defaultAST = (0, _astFromValue.astFromValue)(
        arg.defaultValue,
        arg.type
      );
      let argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    __name(printInputValue, "printInputValue");
    function printDirective(directive) {
      return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    __name(printDirective, "printDirective");
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: reason
        });
        return ` @deprecated(reason: ${astValue})`;
      }
      return " @deprecated";
    }
    __name(printDeprecated, "printDeprecated");
    function printSpecifiedByURL(scalar) {
      if (scalar.specifiedByURL == null) {
        return "";
      }
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: scalar.specifiedByURL
      });
      return ` @specifiedBy(url: ${astValue})`;
    }
    __name(printSpecifiedByURL, "printSpecifiedByURL");
    function printDescription(def, indentation = "", firstInBlock = true) {
      const { description } = def;
      if (description == null) {
        return "";
      }
      const blockString = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: description,
        block: (0, _blockString.isPrintableAsBlockString)(description)
      });
      const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
    __name(printDescription, "printDescription");
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "node_modules/graphql/utilities/concatAST.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.concatAST = concatAST;
    var _kinds = require_kinds();
    function concatAST(documents) {
      const definitions = [];
      for (const doc of documents) {
        definitions.push(...doc.definitions);
      }
      return {
        kind: _kinds.Kind.DOCUMENT,
        definitions
      };
    }
    __name(concatAST, "concatAST");
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "node_modules/graphql/utilities/separateOperations.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.separateOperations = separateOperations;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      const operations = [];
      const depGraph = /* @__PURE__ */ Object.create(null);
      for (const definitionNode of documentAST.definitions) {
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(
              definitionNode.selectionSet
            );
            break;
          default:
        }
      }
      const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
      for (const operation of operations) {
        const dependencies = /* @__PURE__ */ new Set();
        for (const fragmentName of collectDependencies(operation.selectionSet)) {
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        const operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter(
            (node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
          )
        };
      }
      return separatedDocumentASTs;
    }
    __name(separateOperations, "separateOperations");
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        const immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (const toName of immediateDeps) {
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    __name(collectTransitiveDependencies, "collectTransitiveDependencies");
    function collectDependencies(selectionSet) {
      const dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
    __name(collectDependencies, "collectDependencies");
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.stripIgnoredCharacters = stripIgnoredCharacters;
    var _blockString = require_blockString();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function stripIgnoredCharacters(source) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      const body = sourceObj.body;
      const lexer = new _lexer.Lexer(sourceObj);
      let strippedBody = "";
      let wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        const currentToken = lexer.token;
        const tokenKind = currentToken.kind;
        const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(
          currentToken.kind
        );
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        const tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
            minimize: true
          });
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
    __name(stripIgnoredCharacters, "stripIgnoredCharacters");
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "node_modules/graphql/utilities/assertValidName.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidName = assertValidName;
    exports2.isValidNameError = isValidNameError;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _assertName = require_assertName();
    function assertValidName(name) {
      const error3 = isValidNameError(name);
      if (error3) {
        throw error3;
      }
      return name;
    }
    __name(assertValidName, "assertValidName");
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.startsWith("__")) {
        return new _GraphQLError.GraphQLError(
          `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
        );
      }
      try {
        (0, _assertName.assertName)(name);
      } catch (error3) {
        return error3;
      }
    }
    __name(isValidNameError, "isValidNameError");
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "node_modules/graphql/utilities/findBreakingChanges.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DangerousChangeType = exports2.BreakingChangeType = void 0;
    exports2.findBreakingChanges = findBreakingChanges;
    exports2.findDangerousChanges = findDangerousChanges;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _printer = require_printer();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    var _sortValueNode = require_sortValueNode();
    var BreakingChangeType;
    exports2.BreakingChangeType = BreakingChangeType;
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(
      BreakingChangeType || (exports2.BreakingChangeType = BreakingChangeType = {})
    );
    var DangerousChangeType;
    exports2.DangerousChangeType = DangerousChangeType;
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(
      DangerousChangeType || (exports2.DangerousChangeType = DangerousChangeType = {})
    );
    function findBreakingChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in BreakingChangeType
      );
    }
    __name(findBreakingChanges, "findBreakingChanges");
    function findDangerousChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in DangerousChangeType
      );
    }
    __name(findDangerousChanges, "findDangerousChanges");
    function findSchemaChanges(oldSchema, newSchema) {
      return [
        ...findTypeChanges(oldSchema, newSchema),
        ...findDirectiveChanges(oldSchema, newSchema)
      ];
    }
    __name(findSchemaChanges, "findSchemaChanges");
    function findDirectiveChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const directivesDiff = diff(
        oldSchema.getDirectives(),
        newSchema.getDirectives()
      );
      for (const oldDirective of directivesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: `${oldDirective.name} was removed.`
        });
      }
      for (const [oldDirective, newDirective] of directivesDiff.persisted) {
        const argsDiff = diff(oldDirective.args, newDirective.args);
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
            });
          }
        }
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: `${oldArg.name} was removed from ${oldDirective.name}.`
          });
        }
        if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: `Repeatable flag was removed from ${oldDirective.name}.`
          });
        }
        for (const location of oldDirective.locations) {
          if (!newDirective.locations.includes(location)) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: `${location} was removed from ${oldDirective.name}.`
            });
          }
        }
      }
      return schemaChanges;
    }
    __name(findDirectiveChanges, "findDirectiveChanges");
    function findTypeChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const typesDiff = diff(
        Object.values(oldSchema.getTypeMap()),
        Object.values(newSchema.getTypeMap())
      );
      for (const oldType of typesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
        });
      }
      for (const [oldType, newType] of typesDiff.persisted) {
        if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push(...findEnumTypeChanges(oldType, newType));
        } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push(...findUnionTypeChanges(oldType, newType));
        } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
        } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if (oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findTypeChanges, "findTypeChanges");
    function findInputObjectTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const newField of fieldsDiff.added) {
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: `A required field ${newField.name} on input type ${oldType.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
          });
        }
      }
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findInputObjectTypeChanges, "findInputObjectTypeChanges");
    function findUnionTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (const newPossibleType of possibleTypesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: `${newPossibleType.name} was added to union type ${oldType.name}.`
        });
      }
      for (const oldPossibleType of possibleTypesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findUnionTypeChanges, "findUnionTypeChanges");
    function findEnumTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (const newValue of valuesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: `${newValue.name} was added to enum type ${oldType.name}.`
        });
      }
      for (const oldValue of valuesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: `${oldValue.name} was removed from enum type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findEnumTypeChanges, "findEnumTypeChanges");
    function findImplementedInterfacesChanges(oldType, newType) {
      const schemaChanges = [];
      const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (const newInterface of interfacesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
        });
      }
      for (const oldInterface of interfacesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findImplementedInterfacesChanges, "findImplementedInterfacesChanges");
    function findFieldChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        schemaChanges.push(...findArgChanges(oldType, oldField, newField));
        const isSafe = isChangeSafeForObjectOrInterfaceField(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findFieldChanges, "findFieldChanges");
    function findArgChanges(oldType, oldField, newField) {
      const schemaChanges = [];
      const argsDiff = diff(oldField.args, newField.args);
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
        });
      }
      for (const [oldArg, newArg] of argsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldArg.type,
          newArg.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
          });
        } else if (oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
            });
          } else {
            const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
            const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
              });
            }
          }
        }
      }
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findArgChanges, "findArgChanges");
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (
          // if they're both lists, make sure the underlying types are compatible
          (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(
            oldType.ofType,
            newType.ofType
          ) || // moving from nullable to non-null of the same underlying type is safe
          (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
        );
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (
        // if they're both named types, see if their names are equivalent
        (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
        (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
      );
    }
    __name(isChangeSafeForObjectOrInterfaceField, "isChangeSafeForObjectOrInterfaceField");
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (
          // if they're both non-null, make sure the underlying types are
          // compatible
          (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
            oldType.ofType,
            newType.ofType
          ) || // moving from non-null to nullable of the same underlying type is safe
          !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
        );
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    __name(isChangeSafeForInputObjectFieldOrFieldArg, "isChangeSafeForInputObjectFieldOrFieldArg");
    function typeKindName(type2) {
      if ((0, _definition.isScalarType)(type2)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type2)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type2)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type2)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return "an Input type";
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(typeKindName, "typeKindName");
    function stringifyValue(value, type2) {
      const ast = (0, _astFromValue.astFromValue)(value, type2);
      ast != null || (0, _invariant.invariant)(false);
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
    }
    __name(stringifyValue, "stringifyValue");
    function diff(oldArray, newArray) {
      const added = [];
      const removed = [];
      const persisted = [];
      const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
      const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
      for (const oldItem of oldArray) {
        const newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (const newItem of newArray) {
        if (oldMap[newItem.name] === void 0) {
          added.push(newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
    __name(diff, "diff");
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/graphql/utilities/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.BreakingChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.DangerousChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _TypeInfo.TypeInfo;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertValidName.assertValidName;
      }, "get")
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _astFromValue.astFromValue;
      }, "get")
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _buildASTSchema.buildASTSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _buildClientSchema.buildClientSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _buildASTSchema.buildSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _coerceInputValue.coerceInputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _concatAST.concatAST;
      }, "get")
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeComparators.doTypesOverlap;
      }, "get")
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _extendSchema.extendSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.findBreakingChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.findDangerousChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _getOperationAST.getOperationAST;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _getOperationRootType.getOperationRootType;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspectionFromSchema.introspectionFromSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeComparators.isEqualType;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeComparators.isTypeSubTypeOf;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertValidName.isValidNameError;
      }, "get")
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printSchema.printIntrospectionSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printSchema.printSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printSchema.printType;
      }, "get")
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _separateOperations.separateOperations;
      }, "get")
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }, "get")
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeFromAST.typeFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _valueFromAST.valueFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }, "get")
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _TypeInfo.visitWithTypeInfo;
      }, "get")
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
  }
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS({
  "node_modules/graphql/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.BREAK;
      }, "get")
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.BreakingChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.DEFAULT_DEPRECATION_REASON;
      }, "get")
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.DangerousChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ExecutableDefinitionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.FieldsOnCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.FragmentsOnCompositeTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GRAPHQL_MAX_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GRAPHQL_MIN_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLBoolean;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLDeprecatedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.GraphQLError;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLFloat;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLID;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLIncludeDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLInt;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLList;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLNonNull;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLOneOfDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLOneOfDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLSkipDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLSpecifiedByDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLString;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Kind;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownDirectivesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Lexer;
      }, "get")
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Location;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.LoneAnonymousOperationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.LoneSchemaDefinitionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "MaxIntrospectionDepthRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.MaxIntrospectionDepthRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoDeprecatedCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoFragmentCyclesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoSchemaIntrospectionCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoUndefinedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoUnusedFragmentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoUnusedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.OperationTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.OverlappingFieldsCanBeMergedRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.PossibleFragmentSpreadsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.PossibleTypeExtensionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ProvidedRequiredArgumentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ScalarLeafsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.SchemaMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.SingleFieldSubscriptionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Source;
      }, "get")
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Token;
      }, "get")
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.TokenKind;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.TypeInfo;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.TypeMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.TypeNameMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueArgumentDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueDirectiveNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueDirectivesPerLocationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueEnumValueNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueFieldDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueInputFieldNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueOperationNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueOperationTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueVariableNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ValidationContext;
      }, "get")
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ValuesOfCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.VariablesAreInputTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.VariablesInAllowedPositionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Directive;
      }, "get")
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__EnumValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Field;
      }, "get")
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__InputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Schema;
      }, "get")
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Type;
      }, "get")
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertEnumValueName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertListType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.assertValidName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertValidSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.astFromValue;
      }, "get")
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.buildASTSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.buildClientSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.buildSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.coerceInputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.concatAST;
      }, "get")
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.createSourceEventStream;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.defaultFieldResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.defaultTypeResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.doTypesOverlap;
      }, "get")
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.execute;
      }, "get")
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.executeSync;
      }, "get")
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.extendSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.findBreakingChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.findDangerousChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.formatError;
      }, "get")
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.getArgumentValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.getDirectiveValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.getEnterLeaveForKind;
      }, "get")
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.getIntrospectionQuery;
      }, "get")
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.getLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.getNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.getNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.getOperationAST;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.getOperationRootType;
      }, "get")
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.getVariableValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.getVisitFn;
      }, "get")
    });
    Object.defineProperty(exports2, "graphql", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _graphql.graphql;
      }, "get")
    });
    Object.defineProperty(exports2, "graphqlSync", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _graphql.graphqlSync;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.introspectionFromSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.introspectionTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isConstValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.isEqualType;
      }, "get")
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isExecutableDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isIntrospectionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isListType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isRequiredArgument;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isRequiredInputField;
      }, "get")
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isSelectionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isSpecifiedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isSpecifiedScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isType;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.isTypeSubTypeOf;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeSystemDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeSystemExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.isValidNameError;
      }, "get")
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.lexicographicSortSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.locatedError;
      }, "get")
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parse;
      }, "get")
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parseConstValue;
      }, "get")
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parseType;
      }, "get")
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parseValue;
      }, "get")
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.print;
      }, "get")
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.printError;
      }, "get")
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.printIntrospectionSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.printLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.printSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.printSourceLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.printType;
      }, "get")
    });
    Object.defineProperty(exports2, "recommendedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.recommendedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.resolveObjMapThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.resolveReadonlyArrayThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.responsePathAsArray;
      }, "get")
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.separateOperations;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.specifiedDirectives;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.specifiedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.specifiedScalarTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.stripIgnoredCharacters;
      }, "get")
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.subscribe;
      }, "get")
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.syntaxError;
      }, "get")
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.typeFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.validate;
      }, "get")
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.validateSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.valueFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.valueFromASTUntyped;
      }, "get")
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _version.version;
      }, "get")
    });
    Object.defineProperty(exports2, "versionInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _version.versionInfo;
      }, "get")
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.visit;
      }, "get")
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.visitInParallel;
      }, "get")
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.visitWithTypeInfo;
      }, "get")
    });
    var _version = require_version();
    var _graphql = require_graphql();
    var _index = require_type();
    var _index2 = require_language();
    var _index3 = require_execution();
    var _index4 = require_validation();
    var _index5 = require_error();
    var _index6 = require_utilities();
  }
});

// node_modules/apollo-server-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/apollo-server-errors/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatApolloErrors = exports2.UserInputError = exports2.PersistedQueryNotSupportedError = exports2.PersistedQueryNotFoundError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.fromGraphQLError = exports2.toApolloError = exports2.ApolloError = void 0;
    var graphql_1 = require_graphql2();
    var ApolloError = class extends Error {
      static {
        __name(this, "ApolloError");
      }
      constructor(message, code, extensions) {
        super(message);
        if (!this.name) {
          Object.defineProperty(this, "name", { value: "ApolloError" });
        }
        if (extensions === null || extensions === void 0 ? void 0 : extensions.extensions) {
          throw Error("Pass extensions directly as the third argument of the ApolloError constructor: `new ApolloError(message, code, {myExt: value})`, not `new ApolloError(message, code, {extensions: {myExt: value}})`");
        }
        this.extensions = { ...extensions, code };
      }
      toJSON() {
        return (0, graphql_1.formatError)(toGraphQLError(this));
      }
      toString() {
        return (0, graphql_1.printError)(toGraphQLError(this));
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    exports2.ApolloError = ApolloError;
    function toGraphQLError(error3) {
      return new graphql_1.GraphQLError(error3.message, error3.nodes, error3.source, error3.positions, error3.path, error3.originalError, error3.extensions);
    }
    __name(toGraphQLError, "toGraphQLError");
    function enrichError(error3, debug4 = false) {
      var _a, _b, _c;
      const expanded = Object.create(Object.getPrototypeOf(error3), {
        name: {
          value: error3.name
        },
        message: {
          value: error3.message,
          enumerable: true,
          writable: true
        },
        locations: {
          value: error3.locations || void 0,
          enumerable: true
        },
        path: {
          value: error3.path || void 0,
          enumerable: true
        },
        nodes: {
          value: error3.nodes || void 0
        },
        source: {
          value: error3.source || void 0
        },
        positions: {
          value: error3.positions || void 0
        },
        originalError: {
          value: error3.originalError
        }
      });
      expanded.extensions = {
        ...error3.extensions,
        code: ((_a = error3.extensions) === null || _a === void 0 ? void 0 : _a.code) || "INTERNAL_SERVER_ERROR",
        exception: {
          ...(_b = error3.extensions) === null || _b === void 0 ? void 0 : _b.exception,
          ...error3.originalError
        }
      };
      delete expanded.extensions.exception.extensions;
      if (debug4 && !expanded.extensions.exception.stacktrace) {
        const stack = ((_c = error3.originalError) === null || _c === void 0 ? void 0 : _c.stack) || error3.stack;
        expanded.extensions.exception.stacktrace = stack === null || stack === void 0 ? void 0 : stack.split("\n");
      }
      if (Object.keys(expanded.extensions.exception).length === 0) {
        delete expanded.extensions.exception;
      }
      return expanded;
    }
    __name(enrichError, "enrichError");
    function toApolloError(error3, code = "INTERNAL_SERVER_ERROR") {
      let err = error3;
      if (err.extensions) {
        err.extensions.code = code;
      } else {
        err.extensions = { code };
      }
      return err;
    }
    __name(toApolloError, "toApolloError");
    exports2.toApolloError = toApolloError;
    function fromGraphQLError(error3, options) {
      const copy = (options === null || options === void 0 ? void 0 : options.errorClass) ? new options.errorClass(error3.message) : new ApolloError(error3.message);
      Object.entries(error3).forEach(([key, value]) => {
        if (key === "extensions") {
          return;
        }
        copy[key] = value;
      });
      copy.extensions = {
        ...copy.extensions,
        ...error3.extensions
      };
      if (!copy.extensions.code) {
        copy.extensions.code = (options === null || options === void 0 ? void 0 : options.code) || "INTERNAL_SERVER_ERROR";
      }
      Object.defineProperty(copy, "originalError", { value: {} });
      Object.getOwnPropertyNames(error3).forEach((key) => {
        Object.defineProperty(copy.originalError, key, {
          value: error3[key]
        });
      });
      return copy;
    }
    __name(fromGraphQLError, "fromGraphQLError");
    exports2.fromGraphQLError = fromGraphQLError;
    var SyntaxError = class extends ApolloError {
      static {
        __name(this, "SyntaxError");
      }
      constructor(message) {
        super(message, "GRAPHQL_PARSE_FAILED");
        Object.defineProperty(this, "name", { value: "SyntaxError" });
      }
    };
    exports2.SyntaxError = SyntaxError;
    var ValidationError = class extends ApolloError {
      static {
        __name(this, "ValidationError");
      }
      constructor(message) {
        super(message, "GRAPHQL_VALIDATION_FAILED");
        Object.defineProperty(this, "name", { value: "ValidationError" });
      }
    };
    exports2.ValidationError = ValidationError;
    var AuthenticationError = class extends ApolloError {
      static {
        __name(this, "AuthenticationError");
      }
      constructor(message, extensions) {
        super(message, "UNAUTHENTICATED", extensions);
        Object.defineProperty(this, "name", { value: "AuthenticationError" });
      }
    };
    exports2.AuthenticationError = AuthenticationError;
    var ForbiddenError = class extends ApolloError {
      static {
        __name(this, "ForbiddenError");
      }
      constructor(message, extensions) {
        super(message, "FORBIDDEN", extensions);
        Object.defineProperty(this, "name", { value: "ForbiddenError" });
      }
    };
    exports2.ForbiddenError = ForbiddenError;
    var PersistedQueryNotFoundError = class extends ApolloError {
      static {
        __name(this, "PersistedQueryNotFoundError");
      }
      constructor() {
        super("PersistedQueryNotFound", "PERSISTED_QUERY_NOT_FOUND");
        Object.defineProperty(this, "name", {
          value: "PersistedQueryNotFoundError"
        });
      }
    };
    exports2.PersistedQueryNotFoundError = PersistedQueryNotFoundError;
    var PersistedQueryNotSupportedError = class extends ApolloError {
      static {
        __name(this, "PersistedQueryNotSupportedError");
      }
      constructor() {
        super("PersistedQueryNotSupported", "PERSISTED_QUERY_NOT_SUPPORTED");
        Object.defineProperty(this, "name", {
          value: "PersistedQueryNotSupportedError"
        });
      }
    };
    exports2.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;
    var UserInputError = class extends ApolloError {
      static {
        __name(this, "UserInputError");
      }
      constructor(message, extensions) {
        super(message, "BAD_USER_INPUT", extensions);
        Object.defineProperty(this, "name", { value: "UserInputError" });
      }
    };
    exports2.UserInputError = UserInputError;
    function formatApolloErrors(errors, options) {
      if (!options) {
        return errors.map((error3) => enrichError(error3));
      }
      const { formatter, debug: debug4 } = options;
      const enrichedErrors = errors.map((error3) => enrichError(error3, debug4));
      const makePrintable = /* @__PURE__ */ __name((error3) => {
        if (error3 instanceof Error) {
          const graphQLError = error3;
          return {
            message: graphQLError.message,
            ...graphQLError.locations && { locations: graphQLError.locations },
            ...graphQLError.path && { path: graphQLError.path },
            ...graphQLError.extensions && { extensions: graphQLError.extensions }
          };
        }
        return error3;
      }, "makePrintable");
      if (!formatter) {
        return enrichedErrors;
      }
      return enrichedErrors.map((error3) => {
        try {
          return makePrintable(formatter(error3));
        } catch (err) {
          if (debug4) {
            return enrichError(err, debug4);
          } else {
            const newError = fromGraphQLError(new graphql_1.GraphQLError("Internal server error"));
            return enrichError(newError, debug4);
          }
        }
      });
    }
    __name(formatApolloErrors, "formatApolloErrors");
    exports2.formatApolloErrors = formatApolloErrors;
  }
});

// node_modules/whatwg-mimetype/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-mimetype/lib/utils.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.removeLeadingAndTrailingHTTPWhitespace = (string) => {
      return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
    };
    exports2.removeTrailingHTTPWhitespace = (string) => {
      return string.replace(/[ \t\n\r]+$/u, "");
    };
    exports2.isHTTPWhitespaceChar = (char) => {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    };
    exports2.solelyContainsHTTPTokenCodePoints = (string) => {
      return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
    };
    exports2.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
      return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
    };
    exports2.asciiLowercase = (string) => {
      return string.replace(/[A-Z]/ug, (l) => l.toLowerCase());
    };
    exports2.collectAnHTTPQuotedString = (input, position) => {
      let value = "";
      position++;
      while (true) {
        while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
          value += input[position];
          ++position;
        }
        if (position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position];
        ++position;
        if (quoteOrBackslash === "\\") {
          if (position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position];
          ++position;
        } else {
          break;
        }
      }
      return [value, position];
    };
  }
});

// node_modules/whatwg-mimetype/lib/mime-type-parameters.js
var require_mime_type_parameters = __commonJS({
  "node_modules/whatwg-mimetype/lib/mime-type-parameters.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints
    } = require_utils();
    module2.exports = class MIMETypeParameters {
      static {
        __name(this, "MIMETypeParameters");
      }
      constructor(map) {
        this._map = map;
      }
      get size() {
        return this._map.size;
      }
      get(name) {
        name = asciiLowercase(String(name));
        return this._map.get(name);
      }
      has(name) {
        name = asciiLowercase(String(name));
        return this._map.has(name);
      }
      set(name, value) {
        name = asciiLowercase(String(name));
        value = String(value);
        if (!solelyContainsHTTPTokenCodePoints(name)) {
          throw new Error(`Invalid MIME type parameter name "${name}": only HTTP token code points are valid.`);
        }
        if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
          throw new Error(`Invalid MIME type parameter value "${value}": only HTTP quoted-string token code points are valid.`);
        }
        return this._map.set(name, value);
      }
      clear() {
        this._map.clear();
      }
      delete(name) {
        name = asciiLowercase(String(name));
        return this._map.delete(name);
      }
      forEach(callbackFn, thisArg) {
        this._map.forEach(callbackFn, thisArg);
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.values();
      }
      entries() {
        return this._map.entries();
      }
      [Symbol.iterator]() {
        return this._map[Symbol.iterator]();
      }
    };
  }
});

// node_modules/whatwg-mimetype/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/whatwg-mimetype/lib/parser.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      removeLeadingAndTrailingHTTPWhitespace,
      removeTrailingHTTPWhitespace,
      isHTTPWhitespaceChar,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints,
      asciiLowercase,
      collectAnHTTPQuotedString
    } = require_utils();
    module2.exports = (input) => {
      input = removeLeadingAndTrailingHTTPWhitespace(input);
      let position = 0;
      let type2 = "";
      while (position < input.length && input[position] !== "/") {
        type2 += input[position];
        ++position;
      }
      if (type2.length === 0 || !solelyContainsHTTPTokenCodePoints(type2)) {
        return null;
      }
      if (position >= input.length) {
        return null;
      }
      ++position;
      let subtype = "";
      while (position < input.length && input[position] !== ";") {
        subtype += input[position];
        ++position;
      }
      subtype = removeTrailingHTTPWhitespace(subtype);
      if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
        return null;
      }
      const mimeType = {
        type: asciiLowercase(type2),
        subtype: asciiLowercase(subtype),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position < input.length) {
        ++position;
        while (isHTTPWhitespaceChar(input[position])) {
          ++position;
        }
        let parameterName = "";
        while (position < input.length && input[position] !== ";" && input[position] !== "=") {
          parameterName += input[position];
          ++position;
        }
        parameterName = asciiLowercase(parameterName);
        if (position < input.length) {
          if (input[position] === ";") {
            continue;
          }
          ++position;
        }
        let parameterValue = null;
        if (input[position] === '"') {
          [parameterValue, position] = collectAnHTTPQuotedString(input, position);
          while (position < input.length && input[position] !== ";") {
            ++position;
          }
        } else {
          parameterValue = "";
          while (position < input.length && input[position] !== ";") {
            parameterValue += input[position];
            ++position;
          }
          parameterValue = removeTrailingHTTPWhitespace(parameterValue);
          if (parameterValue === "") {
            continue;
          }
        }
        if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    };
  }
});

// node_modules/whatwg-mimetype/lib/serializer.js
var require_serializer = __commonJS({
  "node_modules/whatwg-mimetype/lib/serializer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { solelyContainsHTTPTokenCodePoints } = require_utils();
    module2.exports = (mimeType) => {
      let serialization = `${mimeType.type}/${mimeType.subtype}`;
      if (mimeType.parameters.size === 0) {
        return serialization;
      }
      for (let [name, value] of mimeType.parameters) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!solelyContainsHTTPTokenCodePoints(value) || value.length === 0) {
          value = value.replace(/(["\\])/ug, "\\$1");
          value = `"${value}"`;
        }
        serialization += value;
      }
      return serialization;
    };
  }
});

// node_modules/whatwg-mimetype/lib/mime-type.js
var require_mime_type = __commonJS({
  "node_modules/whatwg-mimetype/lib/mime-type.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MIMETypeParameters = require_mime_type_parameters();
    var parse = require_parser2();
    var serialize = require_serializer();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints
    } = require_utils();
    module2.exports = class MIMEType {
      static {
        __name(this, "MIMEType");
      }
      constructor(string) {
        string = String(string);
        const result = parse(string);
        if (result === null) {
          throw new Error(`Could not parse MIME type string "${string}"`);
        }
        this._type = result.type;
        this._subtype = result.subtype;
        this._parameters = new MIMETypeParameters(result.parameters);
      }
      static parse(string) {
        try {
          return new this(string);
        } catch (e) {
          return null;
        }
      }
      get essence() {
        return `${this.type}/${this.subtype}`;
      }
      get type() {
        return this._type;
      }
      set type(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid type: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid type ${value}: must contain only HTTP token code points`);
        }
        this._type = value;
      }
      get subtype() {
        return this._subtype;
      }
      set subtype(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid subtype: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid subtype ${value}: must contain only HTTP token code points`);
        }
        this._subtype = value;
      }
      get parameters() {
        return this._parameters;
      }
      toString() {
        return serialize(this);
      }
      isJavaScript({ prohibitParameters = false } = {}) {
        switch (this._type) {
          case "text": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "javascript1.0":
              case "javascript1.1":
              case "javascript1.2":
              case "javascript1.3":
              case "javascript1.4":
              case "javascript1.5":
              case "jscript":
              case "livescript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          case "application": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          default: {
            return false;
          }
        }
      }
      isXML() {
        return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
      }
      isHTML() {
        return this._subtype === "html" && this._type === "text";
      }
    };
  }
});

// node_modules/apollo-server-types/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/apollo-server-types/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CacheScope = void 0;
    var CacheScope;
    (function(CacheScope2) {
      CacheScope2["Public"] = "PUBLIC";
      CacheScope2["Private"] = "PRIVATE";
    })(CacheScope = exports2.CacheScope || (exports2.CacheScope = {}));
  }
});

// node_modules/apollo-server-core/dist/cachePolicy.js
var require_cachePolicy = __commonJS({
  "node_modules/apollo-server-core/dist/cachePolicy.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newCachePolicy = void 0;
    var apollo_server_types_1 = require_dist2();
    function newCachePolicy() {
      return {
        maxAge: void 0,
        scope: void 0,
        restrict(hint) {
          if (hint.maxAge !== void 0 && (this.maxAge === void 0 || hint.maxAge < this.maxAge)) {
            this.maxAge = hint.maxAge;
          }
          if (hint.scope !== void 0 && this.scope !== apollo_server_types_1.CacheScope.Private) {
            this.scope = hint.scope;
          }
        },
        replace(hint) {
          if (hint.maxAge !== void 0) {
            this.maxAge = hint.maxAge;
          }
          if (hint.scope !== void 0) {
            this.scope = hint.scope;
          }
        },
        policyIfCacheable() {
          var _a;
          if (this.maxAge === void 0 || this.maxAge === 0) {
            return null;
          }
          return { maxAge: this.maxAge, scope: (_a = this.scope) !== null && _a !== void 0 ? _a : apollo_server_types_1.CacheScope.Public };
        }
      };
    }
    __name(newCachePolicy, "newCachePolicy");
    exports2.newCachePolicy = newCachePolicy;
  }
});

// node_modules/apollo-server-core/dist/graphqlOptions.js
var require_graphqlOptions = __commonJS({
  "node_modules/apollo-server-core/dist/graphqlOptions.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveGraphqlOptions = void 0;
    async function resolveGraphqlOptions(options, ...args) {
      if (typeof options === "function") {
        return await options(...args);
      } else {
        return options;
      }
    }
    __name(resolveGraphqlOptions, "resolveGraphqlOptions");
    exports2.resolveGraphqlOptions = resolveGraphqlOptions;
  }
});

// node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js
var require_schemaInstrumentation = __commonJS({
  "node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.whenResultIsFinished = exports2.pluginsEnabledForSchemaResolvers = exports2.enablePluginsForSchemaResolvers = exports2.symbolUserFieldResolver = exports2.symbolExecutionDispatcherWillResolveField = void 0;
    var type_1 = require_type();
    var execution_1 = require_execution();
    exports2.symbolExecutionDispatcherWillResolveField = Symbol("apolloServerExecutionDispatcherWillResolveField");
    exports2.symbolUserFieldResolver = Symbol("apolloServerUserFieldResolver");
    var symbolPluginsEnabled = Symbol("apolloServerPluginsEnabled");
    function enablePluginsForSchemaResolvers(schema) {
      if (pluginsEnabledForSchemaResolvers(schema)) {
        return schema;
      }
      Object.defineProperty(schema, symbolPluginsEnabled, {
        value: true
      });
      forEachField(schema, wrapField);
      return schema;
    }
    __name(enablePluginsForSchemaResolvers, "enablePluginsForSchemaResolvers");
    exports2.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;
    function pluginsEnabledForSchemaResolvers(schema) {
      return !!schema[symbolPluginsEnabled];
    }
    __name(pluginsEnabledForSchemaResolvers, "pluginsEnabledForSchemaResolvers");
    exports2.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;
    function wrapField(field) {
      const originalFieldResolve = field.resolve;
      field.resolve = (source, args, context2, info3) => {
        const parentPath = info3.path.prev;
        const willResolveField = context2 === null || context2 === void 0 ? void 0 : context2[exports2.symbolExecutionDispatcherWillResolveField];
        const userFieldResolver = context2 === null || context2 === void 0 ? void 0 : context2[exports2.symbolUserFieldResolver];
        const didResolveField = typeof willResolveField === "function" && willResolveField({ source, args, context: context2, info: info3 });
        const resolveObject = info3.parentType.resolveObject;
        let whenObjectResolved;
        if (parentPath && resolveObject) {
          if (!parentPath.__fields) {
            parentPath.__fields = {};
          }
          parentPath.__fields[info3.fieldName] = info3.fieldNodes;
          whenObjectResolved = parentPath.__whenObjectResolved;
          if (!whenObjectResolved) {
            whenObjectResolved = Promise.resolve().then(() => {
              return resolveObject(source, parentPath.__fields, context2, info3);
            });
            parentPath.__whenObjectResolved = whenObjectResolved;
          }
        }
        const fieldResolver = originalFieldResolve || userFieldResolver || execution_1.defaultFieldResolver;
        try {
          let result;
          if (whenObjectResolved) {
            result = whenObjectResolved.then((resolvedObject) => {
              return fieldResolver(resolvedObject, args, context2, info3);
            });
          } else {
            result = fieldResolver(source, args, context2, info3);
          }
          if (typeof didResolveField === "function") {
            whenResultIsFinished(result, didResolveField);
          }
          return result;
        } catch (error3) {
          if (typeof didResolveField === "function") {
            didResolveField(error3);
          }
          throw error3;
        }
      };
    }
    __name(wrapField, "wrapField");
    function isPromise(x) {
      return x && typeof x.then === "function";
    }
    __name(isPromise, "isPromise");
    function whenResultIsFinished(result, callback) {
      if (isPromise(result)) {
        result.then((r) => callback(null, r), (err) => callback(err));
      } else if (Array.isArray(result)) {
        if (result.some(isPromise)) {
          Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
        } else {
          callback(null, result);
        }
      } else {
        callback(null, result);
      }
    }
    __name(whenResultIsFinished, "whenResultIsFinished");
    exports2.whenResultIsFinished = whenResultIsFinished;
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      Object.entries(typeMap).forEach(([typeName, type2]) => {
        if (!(0, type_1.getNamedType)(type2).name.startsWith("__") && type2 instanceof type_1.GraphQLObjectType) {
          const fields = type2.getFields();
          Object.entries(fields).forEach(([fieldName, field]) => {
            fn(field, typeName, fieldName);
          });
        }
      });
    }
    __name(forEachField, "forEachField");
  }
});

// node_modules/apollo-server-core/dist/utils/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/apollo-server-core/dist/utils/dispatcher.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dispatcher = void 0;
    var Dispatcher2 = class {
      static {
        __name(this, "Dispatcher");
      }
      constructor(targets) {
        this.targets = targets;
      }
      callTargets(methodName, ...args) {
        return this.targets.map((target) => {
          const method = target[methodName];
          if (typeof method === "function") {
            return method.apply(target, args);
          }
        });
      }
      hasHook(methodName) {
        return this.targets.some((target) => typeof target[methodName] === "function");
      }
      async invokeHook(methodName, ...args) {
        return Promise.all(this.callTargets(methodName, ...args));
      }
      async invokeHooksUntilNonNull(methodName, ...args) {
        for (const target of this.targets) {
          const method = target[methodName];
          if (typeof method !== "function") {
            continue;
          }
          const value = await method.apply(target, args);
          if (value !== null) {
            return value;
          }
        }
        return null;
      }
      async invokeDidStartHook(methodName, ...args) {
        const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));
        const didEndHooks = hookReturnValues.filter((hook) => !!hook);
        didEndHooks.reverse();
        return async (...args2) => {
          await Promise.all(didEndHooks.map((hook) => hook(...args2)));
        };
      }
      invokeSyncDidStartHook(methodName, ...args) {
        const didEndHooks = [];
        for (const target of this.targets) {
          const method = target[methodName];
          if (typeof method === "function") {
            const didEndHook = method.apply(target, args);
            if (didEndHook) {
              didEndHooks.push(didEndHook);
            }
          }
        }
        didEndHooks.reverse();
        return (...args2) => {
          for (const didEndHook of didEndHooks) {
            didEndHook(...args2);
          }
        };
      }
    };
    exports2.Dispatcher = Dispatcher2;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js
var require_PrefixingKeyValueCache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache = class {
      static {
        __name(this, "PrefixingKeyValueCache");
      }
      constructor(wrapped, prefix) {
        this.wrapped = wrapped;
        this.prefix = prefix;
      }
      get(key) {
        return this.wrapped.get(this.prefix + key);
      }
      set(key, value, options) {
        return this.wrapped.set(this.prefix + key, value, options);
      }
      delete(key) {
        return this.wrapped.delete(this.prefix + key);
      }
    };
    exports2.PrefixingKeyValueCache = PrefixingKeyValueCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      static {
        __name(this, "AbortController");
      }
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      static {
        __name(this, "AbortSignal");
      }
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type2) {
        if (type2 === "abort") {
          this.aborted = true;
          const e = { type: type2, target: this };
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = /* @__PURE__ */ __name((opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn3(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    }, "deprecatedOption");
    var deprecatedMethod = /* @__PURE__ */ __name((method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn3(code, `${method} method`, `cache.${instead}()`, get2);
      }
    }, "deprecatedMethod");
    var deprecatedProperty = /* @__PURE__ */ __name((field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn3(code, `${field} property`, `cache.${instead}`, get2);
      }
    }, "deprecatedProperty");
    var emitWarning2 = /* @__PURE__ */ __name((...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    }, "emitWarning");
    var shouldWarn = /* @__PURE__ */ __name((code) => !warned.has(code), "shouldWarn");
    var warn3 = /* @__PURE__ */ __name((code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning2(msg, "DeprecationWarning", code, fn);
    }, "warn");
    var isPosInt = /* @__PURE__ */ __name((n) => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt");
    var getUintArray = /* @__PURE__ */ __name((max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null, "getUintArray");
    var ZeroArray = class extends Array {
      static {
        __name(this, "ZeroArray");
      }
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      static {
        __name(this, "Stack");
      }
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      static {
        __name(this, "LRUCache");
      }
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning2(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = /* @__PURE__ */ __name(() => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        }, "getNow");
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxSize && size > this.maxSize) {
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context2) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options,
          context: context2
        };
        const cb = /* @__PURE__ */ __name((v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        }, "cb");
        const eb = /* @__PURE__ */ __name((er) => {
          if (this.valList[index] === p) {
            const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        }, "eb");
        const pcall = /* @__PURE__ */ __name((res) => res(this.fetchMethod(k, v, fetchOpts)), "pcall");
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = false
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js
var require_InMemoryLRUCache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryLRUCache = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var InMemoryLRUCache = class _InMemoryLRUCache {
      static {
        __name(this, "InMemoryLRUCache");
      }
      constructor(lruCacheOpts) {
        this.cache = new lru_cache_1.default({
          sizeCalculation: _InMemoryLRUCache.sizeCalculation,
          maxSize: Math.pow(2, 20) * 30,
          ...lruCacheOpts
        });
      }
      static sizeCalculation(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (typeof item === "object") {
          return Buffer.byteLength(JSON.stringify(item), "utf8");
        }
        return 1;
      }
      async set(key, value, options) {
        if (options === null || options === void 0 ? void 0 : options.ttl) {
          this.cache.set(key, value, { ttl: options.ttl * 1e3 });
        } else {
          this.cache.set(key, value);
        }
      }
      async get(key) {
        return this.cache.get(key);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
      }
      keys() {
        return [...this.cache.keys()];
      }
    };
    exports2.InMemoryLRUCache = InMemoryLRUCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js
var require_ErrorsAreMissesCache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = void 0;
    var ErrorsAreMissesCache = class {
      static {
        __name(this, "ErrorsAreMissesCache");
      }
      constructor(cache, logger) {
        this.cache = cache;
        this.logger = logger;
      }
      async get(key) {
        try {
          return await this.cache.get(key);
        } catch (e) {
          if (this.logger) {
            if (e instanceof Error) {
              this.logger.error(e.message);
            } else {
              this.logger.error(e);
            }
          }
          return void 0;
        }
      }
      async set(key, value, opts) {
        return this.cache.set(key, value, opts);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
    };
    exports2.ErrorsAreMissesCache = ErrorsAreMissesCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = exports2.InMemoryLRUCache = exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache_1 = require_PrefixingKeyValueCache();
    Object.defineProperty(exports2, "PrefixingKeyValueCache", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return PrefixingKeyValueCache_1.PrefixingKeyValueCache;
    }, "get") });
    var InMemoryLRUCache_1 = require_InMemoryLRUCache();
    Object.defineProperty(exports2, "InMemoryLRUCache", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return InMemoryLRUCache_1.InMemoryLRUCache;
    }, "get") });
    var ErrorsAreMissesCache_1 = require_ErrorsAreMissesCache();
    Object.defineProperty(exports2, "ErrorsAreMissesCache", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ErrorsAreMissesCache_1.ErrorsAreMissesCache;
    }, "get") });
  }
});

// node_modules/apollo-server-core/dist/utils/isNodeLike.js
var require_isNodeLike = __commonJS({
  "node_modules/apollo-server-core/dist/utils/isNodeLike.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = typeof process === "object" && process && process.release && process.versions && typeof process.versions.node === "string";
  }
});

// node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs
var subtle;
var init_web = __esm({
  "node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    subtle = globalThis.crypto?.subtle;
  }
});

// node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs
var webcrypto, createCipher, createDecipher, pseudoRandomBytes, Cipher, Decipher;
var init_node = __esm({
  "node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    webcrypto = new Proxy(globalThis.crypto, { get(_, key) {
      if (key === "CryptoKey") {
        return globalThis.CryptoKey;
      }
      if (typeof globalThis.crypto[key] === "function") {
        return globalThis.crypto[key].bind(globalThis.crypto);
      }
      return globalThis.crypto[key];
    } });
    createCipher = /* @__PURE__ */ notImplemented("crypto.createCipher");
    createDecipher = /* @__PURE__ */ notImplemented("crypto.createDecipher");
    pseudoRandomBytes = /* @__PURE__ */ notImplemented("crypto.pseudoRandomBytes");
    Cipher = /* @__PURE__ */ notImplementedClass("crypto.Cipher");
    Decipher = /* @__PURE__ */ notImplementedClass("crypto.Decipher");
  }
});

// node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs
var SSL_OP_ALL, SSL_OP_ALLOW_NO_DHE_KEX, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_NO_COMPRESSION, SSL_OP_NO_ENCRYPT_THEN_MAC, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_RENEGOTIATION, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_NO_TLSv1_3, SSL_OP_PRIORITIZE_CHACHA, SSL_OP_TLS_ROLLBACK_BUG, ENGINE_METHOD_RSA, ENGINE_METHOD_DSA, ENGINE_METHOD_DH, ENGINE_METHOD_RAND, ENGINE_METHOD_EC, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_ALL, ENGINE_METHOD_NONE, DH_CHECK_P_NOT_SAFE_PRIME, DH_CHECK_P_NOT_PRIME, DH_UNABLE_TO_CHECK_GENERATOR, DH_NOT_SUITABLE_GENERATOR, RSA_PKCS1_PADDING, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_X931_PADDING, RSA_PKCS1_PSS_PADDING, RSA_PSS_SALTLEN_DIGEST, RSA_PSS_SALTLEN_MAX_SIGN, RSA_PSS_SALTLEN_AUTO, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_UNCOMPRESSED, POINT_CONVERSION_HYBRID, defaultCoreCipherList, defaultCipherList, OPENSSL_VERSION_NUMBER, TLS1_VERSION, TLS1_1_VERSION, TLS1_2_VERSION, TLS1_3_VERSION;
var init_constants = __esm({
  "node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SSL_OP_ALL = 2147485776;
    SSL_OP_ALLOW_NO_DHE_KEX = 1024;
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;
    SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;
    SSL_OP_CISCO_ANYCONNECT = 32768;
    SSL_OP_COOKIE_EXCHANGE = 8192;
    SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;
    SSL_OP_LEGACY_SERVER_CONNECT = 4;
    SSL_OP_NO_COMPRESSION = 131072;
    SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;
    SSL_OP_NO_QUERY_MTU = 4096;
    SSL_OP_NO_RENEGOTIATION = 1073741824;
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;
    SSL_OP_NO_SSLv2 = 0;
    SSL_OP_NO_SSLv3 = 33554432;
    SSL_OP_NO_TICKET = 16384;
    SSL_OP_NO_TLSv1 = 67108864;
    SSL_OP_NO_TLSv1_1 = 268435456;
    SSL_OP_NO_TLSv1_2 = 134217728;
    SSL_OP_NO_TLSv1_3 = 536870912;
    SSL_OP_PRIORITIZE_CHACHA = 2097152;
    SSL_OP_TLS_ROLLBACK_BUG = 8388608;
    ENGINE_METHOD_RSA = 1;
    ENGINE_METHOD_DSA = 2;
    ENGINE_METHOD_DH = 4;
    ENGINE_METHOD_RAND = 8;
    ENGINE_METHOD_EC = 2048;
    ENGINE_METHOD_CIPHERS = 64;
    ENGINE_METHOD_DIGESTS = 128;
    ENGINE_METHOD_PKEY_METHS = 512;
    ENGINE_METHOD_PKEY_ASN1_METHS = 1024;
    ENGINE_METHOD_ALL = 65535;
    ENGINE_METHOD_NONE = 0;
    DH_CHECK_P_NOT_SAFE_PRIME = 2;
    DH_CHECK_P_NOT_PRIME = 1;
    DH_UNABLE_TO_CHECK_GENERATOR = 4;
    DH_NOT_SUITABLE_GENERATOR = 8;
    RSA_PKCS1_PADDING = 1;
    RSA_NO_PADDING = 3;
    RSA_PKCS1_OAEP_PADDING = 4;
    RSA_X931_PADDING = 5;
    RSA_PKCS1_PSS_PADDING = 6;
    RSA_PSS_SALTLEN_DIGEST = -1;
    RSA_PSS_SALTLEN_MAX_SIGN = -2;
    RSA_PSS_SALTLEN_AUTO = -2;
    POINT_CONVERSION_COMPRESSED = 2;
    POINT_CONVERSION_UNCOMPRESSED = 4;
    POINT_CONVERSION_HYBRID = 6;
    defaultCoreCipherList = "";
    defaultCipherList = "";
    OPENSSL_VERSION_NUMBER = 0;
    TLS1_VERSION = 0;
    TLS1_1_VERSION = 0;
    TLS1_2_VERSION = 0;
    TLS1_3_VERSION = 0;
  }
});

// node_modules/unenv/dist/runtime/node/crypto.mjs
var constants;
var init_crypto = __esm({
  "node_modules/unenv/dist/runtime/node/crypto.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constants();
    init_web();
    init_node();
    constants = {
      OPENSSL_VERSION_NUMBER,
      SSL_OP_ALL,
      SSL_OP_ALLOW_NO_DHE_KEX,
      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
      SSL_OP_CIPHER_SERVER_PREFERENCE,
      SSL_OP_CISCO_ANYCONNECT,
      SSL_OP_COOKIE_EXCHANGE,
      SSL_OP_CRYPTOPRO_TLSEXT_BUG,
      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
      SSL_OP_LEGACY_SERVER_CONNECT,
      SSL_OP_NO_COMPRESSION,
      SSL_OP_NO_ENCRYPT_THEN_MAC,
      SSL_OP_NO_QUERY_MTU,
      SSL_OP_NO_RENEGOTIATION,
      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
      SSL_OP_NO_SSLv2,
      SSL_OP_NO_SSLv3,
      SSL_OP_NO_TICKET,
      SSL_OP_NO_TLSv1,
      SSL_OP_NO_TLSv1_1,
      SSL_OP_NO_TLSv1_2,
      SSL_OP_NO_TLSv1_3,
      SSL_OP_PRIORITIZE_CHACHA,
      SSL_OP_TLS_ROLLBACK_BUG,
      ENGINE_METHOD_RSA,
      ENGINE_METHOD_DSA,
      ENGINE_METHOD_DH,
      ENGINE_METHOD_RAND,
      ENGINE_METHOD_EC,
      ENGINE_METHOD_CIPHERS,
      ENGINE_METHOD_DIGESTS,
      ENGINE_METHOD_PKEY_METHS,
      ENGINE_METHOD_PKEY_ASN1_METHS,
      ENGINE_METHOD_ALL,
      ENGINE_METHOD_NONE,
      DH_CHECK_P_NOT_SAFE_PRIME,
      DH_CHECK_P_NOT_PRIME,
      DH_UNABLE_TO_CHECK_GENERATOR,
      DH_NOT_SUITABLE_GENERATOR,
      RSA_PKCS1_PADDING,
      RSA_NO_PADDING,
      RSA_PKCS1_OAEP_PADDING,
      RSA_X931_PADDING,
      RSA_PKCS1_PSS_PADDING,
      RSA_PSS_SALTLEN_DIGEST,
      RSA_PSS_SALTLEN_MAX_SIGN,
      RSA_PSS_SALTLEN_AUTO,
      defaultCoreCipherList,
      TLS1_VERSION,
      TLS1_1_VERSION,
      TLS1_2_VERSION,
      TLS1_3_VERSION,
      POINT_CONVERSION_COMPRESSED,
      POINT_CONVERSION_UNCOMPRESSED,
      POINT_CONVERSION_HYBRID,
      defaultCipherList
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs
var workerdCrypto, Certificate, checkPrime, checkPrimeSync, Cipheriv, createCipheriv, createDecipheriv, createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createHmac, createPrivateKey, createPublicKey, createSecretKey, createSign, createVerify, Decipheriv, diffieHellman, DiffieHellman, DiffieHellmanGroup, ECDH, fips, generateKey, generateKeyPair, generateKeyPairSync, generateKeySync, generatePrime, generatePrimeSync, getCipherInfo, getCiphers, getCurves, getDiffieHellman, getFips, getHashes, getRandomValues, hash, Hash, hkdf, hkdfSync, Hmac, KeyObject, pbkdf2, pbkdf2Sync, privateDecrypt, privateEncrypt, publicDecrypt, publicEncrypt, randomBytes, randomFill, randomFillSync, randomInt, randomUUID, scrypt, scryptSync, secureHeapUsed, setEngine, setFips, sign, Sign, subtle2, timingSafeEqual, verify, Verify, X509Certificate, webcrypto2, crypto_default;
var init_crypto2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto();
    workerdCrypto = process.getBuiltinModule("node:crypto");
    ({
      Certificate,
      checkPrime,
      checkPrimeSync,
      Cipheriv: (
        // @ts-expect-error
        Cipheriv
      ),
      createCipheriv,
      createDecipheriv,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      createSign,
      createVerify,
      Decipheriv: (
        // @ts-expect-error
        Decipheriv
      ),
      diffieHellman,
      DiffieHellman,
      DiffieHellmanGroup,
      ECDH,
      fips,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCipherInfo,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hash,
      Hash,
      hkdf,
      hkdfSync,
      Hmac,
      KeyObject,
      pbkdf2,
      pbkdf2Sync,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      scrypt,
      scryptSync,
      secureHeapUsed,
      setEngine,
      setFips,
      sign,
      Sign,
      subtle: subtle2,
      timingSafeEqual,
      verify,
      Verify,
      X509Certificate
    } = workerdCrypto);
    webcrypto2 = {
      // @ts-expect-error
      CryptoKey: webcrypto.CryptoKey,
      getRandomValues,
      randomUUID,
      subtle: subtle2
    };
    crypto_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      Certificate,
      Cipher,
      Cipheriv,
      Decipher,
      Decipheriv,
      ECDH,
      Sign,
      Verify,
      X509Certificate,
      // @ts-expect-error @types/node is out of date - this is a bug in typings
      constants,
      createCipheriv,
      createDecipheriv,
      createECDH,
      createSign,
      createVerify,
      diffieHellman,
      getCipherInfo,
      hash,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      scrypt,
      scryptSync,
      sign,
      verify,
      // default-only export from unenv
      // @ts-expect-error unenv has unknown type
      createCipher,
      // @ts-expect-error unenv has unknown type
      createDecipher,
      // @ts-expect-error unenv has unknown type
      pseudoRandomBytes,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      DiffieHellman,
      DiffieHellmanGroup,
      Hash,
      Hmac,
      KeyObject,
      checkPrime,
      checkPrimeSync,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hkdf,
      hkdfSync,
      pbkdf2,
      pbkdf2Sync,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      secureHeapUsed,
      setEngine,
      setFips,
      subtle: subtle2,
      timingSafeEqual,
      // default-only export from workerd
      fips,
      // special-cased deep merged symbols
      webcrypto: webcrypto2
    };
  }
});

// node-built-in-modules:crypto
var require_crypto = __commonJS({
  "node-built-in-modules:crypto"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto2();
    module2.exports = crypto_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs
var isRegExp, isDate, isBoolean, isNull, isNullOrUndefined, isNumber, isString, isSymbol, isUndefined, isFunction, isBuffer, isObject, isError, isPrimitive;
var init_legacy_types = __esm({
  "node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isRegExp = /* @__PURE__ */ __name((val) => val instanceof RegExp, "isRegExp");
    isDate = /* @__PURE__ */ __name((val) => val instanceof Date, "isDate");
    isBoolean = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean");
    isNull = /* @__PURE__ */ __name((val) => val === null, "isNull");
    isNullOrUndefined = /* @__PURE__ */ __name((val) => val === null || val === void 0, "isNullOrUndefined");
    isNumber = /* @__PURE__ */ __name((val) => typeof val === "number", "isNumber");
    isString = /* @__PURE__ */ __name((val) => typeof val === "string", "isString");
    isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
    isUndefined = /* @__PURE__ */ __name((val) => val === void 0, "isUndefined");
    isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
    isBuffer = /* @__PURE__ */ __name((val) => {
      return val && typeof val === "object" && typeof val.copy === "function" && typeof val.fill === "function" && typeof val.readUInt8 === "function";
    }, "isBuffer");
    isObject = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && Object.getPrototypeOf(val).isPrototypeOf(Object), "isObject");
    isError = /* @__PURE__ */ __name((val) => val instanceof Error, "isError");
    isPrimitive = /* @__PURE__ */ __name((val) => {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    }, "isPrimitive");
  }
});

// node_modules/unenv/dist/runtime/node/internal/util/log.mjs
var init_log = __esm({
  "node_modules/unenv/dist/runtime/node/internal/util/log.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/unenv/dist/runtime/node/util.mjs
import types from "node:util/types";
import { default as default2 } from "node:util/types";
var TextDecoder2, TextEncoder, _errnoException, _exceptionWithHostPort, getSystemErrorMap, getSystemErrorName, parseEnv, styleText;
var init_util = __esm({
  "node_modules/unenv/dist/runtime/node/util.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_legacy_types();
    init_log();
    TextDecoder2 = globalThis.TextDecoder;
    TextEncoder = globalThis.TextEncoder;
    _errnoException = /* @__PURE__ */ notImplemented("util._errnoException");
    _exceptionWithHostPort = /* @__PURE__ */ notImplemented("util._exceptionWithHostPort");
    getSystemErrorMap = /* @__PURE__ */ notImplemented("util.getSystemErrorMap");
    getSystemErrorName = /* @__PURE__ */ notImplemented("util.getSystemErrorName");
    parseEnv = /* @__PURE__ */ notImplemented("util.parseEnv");
    styleText = /* @__PURE__ */ notImplemented("util.styleText");
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs
var workerdUtil, MIMEParams, MIMEType, TextDecoder3, TextEncoder2, _extend, aborted, callbackify, debug3, debuglog, deprecate, format, formatWithOptions, getCallSite, inherits, inspect, isArray, isDeepStrictEqual, log3, parseArgs, promisify, stripVTControlCharacters, toUSVString, transferableAbortController, transferableAbortSignal, types2, util_default;
var init_util2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util();
    workerdUtil = process.getBuiltinModule("node:util");
    ({
      MIMEParams,
      MIMEType,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder2,
      _extend: (
        // @ts-expect-error missing types?
        _extend
      ),
      aborted,
      callbackify,
      debug: debug3,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite: (
        // @ts-expect-error unknown type
        getCallSite
      ),
      inherits,
      inspect,
      isArray,
      isDeepStrictEqual,
      log: log3,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal
    } = workerdUtil);
    types2 = workerdUtil.types;
    util_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      _errnoException,
      _exceptionWithHostPort,
      // @ts-expect-error unenv has unknown type
      getSystemErrorMap,
      // @ts-expect-error unenv has unknown type
      getSystemErrorName,
      isBoolean,
      isBuffer,
      isDate,
      isError,
      isFunction,
      isNull,
      isNullOrUndefined,
      isNumber,
      isObject,
      isPrimitive,
      isRegExp,
      isString,
      isSymbol,
      isUndefined,
      // @ts-expect-error unenv has unknown type
      parseEnv,
      // @ts-expect-error unenv has unknown type
      styleText,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      _extend,
      aborted,
      callbackify,
      debug: debug3,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite,
      inherits,
      inspect,
      isArray,
      isDeepStrictEqual,
      log: log3,
      MIMEParams,
      MIMEType,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder2,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal,
      // special-cased deep merged symbols
      types: types2
    };
  }
});

// node_modules/unenv/dist/runtime/npm/inherits.mjs
var inherits_exports = {};
__export(inherits_exports, {
  default: () => inherits_default
});
var inherits_default;
var init_inherits = __esm({
  "node_modules/unenv/dist/runtime/npm/inherits.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    inherits_default = inherits;
  }
});

// required-unenv-alias:inherits
var require_inherits = __commonJS({
  "required-unenv-alias:inherits"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_inherits();
    module2.exports = Object.entries(inherits_exports).filter(([k]) => k !== "default").reduce(
      (cjs, [k, value]) => Object.defineProperty(cjs, k, { value, enumerable: true }),
      "default" in inherits_exports ? inherits_default : {}
    );
  }
});

// node-built-in-modules:buffer
import libDefault from "buffer";
var require_buffer = __commonJS({
  "node-built-in-modules:buffer"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = libDefault;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash2(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    __name(Hash2, "Hash");
    Hash2.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash2.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash2.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash2;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha, "Sha");
    inherits2(Sha, Hash2);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    __name(rotl5, "rotl5");
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    __name(rotl30, "rotl30");
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    __name(ft, "ft");
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha1, "Sha1");
    inherits2(Sha1, Hash2);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    __name(rotl1, "rotl1");
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    __name(rotl5, "rotl5");
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    __name(rotl30, "rotl30");
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    __name(ft, "ft");
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha256, "Sha256");
    inherits2(Sha256, Hash2);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    __name(ch, "ch");
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    __name(maj, "maj");
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    __name(sigma0, "sigma0");
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    __name(sigma1, "sigma1");
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    __name(gamma0, "gamma0");
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    __name(gamma1, "gamma1");
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Sha256 = require_sha256();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha224, "Sha224");
    inherits2(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    __name(Sha512, "Sha512");
    inherits2(Sha512, Hash2);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    __name(Ch, "Ch");
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    __name(maj, "maj");
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    __name(sigma0, "sigma0");
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    __name(sigma1, "sigma1");
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    __name(Gamma0, "Gamma0");
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    __name(Gamma0l, "Gamma0l");
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    __name(Gamma1, "Gamma1");
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    __name(Gamma1l, "Gamma1l");
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    __name(getCarry, "getCarry");
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      __name(writeInt64BE, "writeInt64BE");
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var SHA512 = require_sha512();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    __name(Sha384, "Sha384");
    inherits2(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      __name(writeInt64BE, "writeInt64BE");
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var exports2 = module2.exports = /* @__PURE__ */ __name(function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    }, "SHA");
    exports2.sha = require_sha();
    exports2.sha1 = require_sha1();
    exports2.sha224 = require_sha224();
    exports2.sha256 = require_sha256();
    exports2.sha384 = require_sha384();
    exports2.sha512 = require_sha512();
  }
});

// node_modules/apollo-server-core/dist/utils/createSHA.js
var require_createSHA = __commonJS({
  "node_modules/apollo-server-core/dist/utils/createSHA.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isNodeLike_1 = __importDefault(require_isNodeLike());
    function default_1(kind) {
      if (isNodeLike_1.default) {
        return require_crypto().createHash(kind);
      }
      return require_sha2()(kind);
    }
    __name(default_1, "default_1");
    exports2.default = default_1;
  }
});

// node_modules/apollo-server-core/dist/requestPipeline.js
var require_requestPipeline = __commonJS({
  "node_modules/apollo-server-core/dist/requestPipeline.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processGraphQLRequest = exports2.APQ_CACHE_PREFIX = void 0;
    var graphql_1 = require_graphql2();
    var schemaInstrumentation_1 = require_schemaInstrumentation();
    var apollo_server_errors_1 = require_dist();
    var dispatcher_1 = require_dispatcher();
    var utils_keyvaluecache_1 = require_dist3();
    var createSHA_1 = __importDefault(require_createSHA());
    var runHttpQuery_1 = require_runHttpQuery();
    var apollo_server_env_1 = require_index_browser();
    exports2.APQ_CACHE_PREFIX = "apq:";
    function computeQueryHash(query) {
      return (0, createSHA_1.default)("sha256").update(query).digest("hex");
    }
    __name(computeQueryHash, "computeQueryHash");
    function isBadUserInputGraphQLError(error3) {
      var _a;
      return ((_a = error3.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && error3.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error3.message.startsWith(`Variable "$${error3.nodes[0].variable.name.value}" got invalid value `) || error3.message.startsWith(`Variable "$${error3.nodes[0].variable.name.value}" of required type `) || error3.message.startsWith(`Variable "$${error3.nodes[0].variable.name.value}" of non-null type `));
    }
    __name(isBadUserInputGraphQLError, "isBadUserInputGraphQLError");
    async function processGraphQLRequest(config2, requestContext) {
      var _a, _b;
      const logger = requestContext.logger || console;
      const metrics = requestContext.metrics = requestContext.metrics || /* @__PURE__ */ Object.create(null);
      const dispatcher = await initializeRequestListenerDispatcher();
      await initializeDataSources();
      const request2 = requestContext.request;
      let { query, extensions } = request2;
      let queryHash;
      let persistedQueryCache;
      metrics.persistedQueryHit = false;
      metrics.persistedQueryRegister = false;
      if (extensions === null || extensions === void 0 ? void 0 : extensions.persistedQuery) {
        if (!config2.persistedQueries || !config2.persistedQueries.cache) {
          return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError());
        } else if (extensions.persistedQuery.version !== 1) {
          return await sendErrorResponse(new graphql_1.GraphQLError("Unsupported persisted query version"));
        }
        persistedQueryCache = config2.persistedQueries.cache;
        if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {
          persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports2.APQ_CACHE_PREFIX);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === void 0) {
          query = await persistedQueryCache.get(queryHash);
          if (query) {
            metrics.persistedQueryHit = true;
          } else {
            return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError());
          }
        } else {
          const computedQueryHash = computeQueryHash(query);
          if (queryHash !== computedQueryHash) {
            return await sendErrorResponse(new graphql_1.GraphQLError("provided sha does not match query"));
          }
          metrics.persistedQueryRegister = true;
        }
      } else if (query) {
        queryHash = computeQueryHash(query);
      } else {
        return await sendErrorResponse(new graphql_1.GraphQLError("GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension."));
      }
      requestContext.queryHash = queryHash;
      requestContext.source = query;
      await dispatcher.invokeHook("didResolveSource", requestContext);
      if (config2.documentStore) {
        try {
          requestContext.document = await config2.documentStore.get(queryHash);
        } catch (err) {
          logger.warn("An error occurred while attempting to read from the documentStore. " + (err === null || err === void 0 ? void 0 : err.message) || err);
        }
      }
      if (!requestContext.document) {
        const parsingDidEnd = await dispatcher.invokeDidStartHook("parsingDidStart", requestContext);
        try {
          requestContext.document = parse(query, config2.parseOptions);
          await parsingDidEnd();
        } catch (syntaxError) {
          await parsingDidEnd(syntaxError);
          return await sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);
        }
        if (config2.dangerouslyDisableValidation !== true) {
          const validationDidEnd = await dispatcher.invokeDidStartHook("validationDidStart", requestContext);
          const validationErrors = validate(requestContext.document);
          if (validationErrors.length === 0) {
            await validationDidEnd();
          } else {
            await validationDidEnd(validationErrors);
            return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);
          }
        }
        if (config2.documentStore) {
          Promise.resolve(config2.documentStore.set(queryHash, requestContext.document)).catch((err) => logger.warn("Could not store validated document. " + (err === null || err === void 0 ? void 0 : err.message) || err));
        }
      }
      const operation = (0, graphql_1.getOperationAST)(requestContext.document, request2.operationName);
      requestContext.operation = operation || void 0;
      requestContext.operationName = ((_a = operation === null || operation === void 0 ? void 0 : operation.name) === null || _a === void 0 ? void 0 : _a.value) || null;
      try {
        await dispatcher.invokeHook("didResolveOperation", requestContext);
      } catch (err) {
        return await sendErrorResponse(err);
      }
      if (metrics.persistedQueryRegister && persistedQueryCache) {
        Promise.resolve(persistedQueryCache.set(queryHash, query, config2.persistedQueries && typeof config2.persistedQueries.ttl !== "undefined" ? {
          ttl: config2.persistedQueries.ttl
        } : /* @__PURE__ */ Object.create(null))).catch(logger.warn);
      }
      let response = await dispatcher.invokeHooksUntilNonNull("responseForOperation", requestContext);
      if (response == null) {
        const executionListeners = [];
        (await dispatcher.invokeHook("executionDidStart", requestContext)).forEach((executionListener) => {
          if (executionListener) {
            executionListeners.push(executionListener);
          }
        });
        executionListeners.reverse();
        const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);
        if (executionDispatcher.hasHook("willResolveField")) {
          const invokeWillResolveField = /* @__PURE__ */ __name((...args) => executionDispatcher.invokeSyncDidStartHook("willResolveField", ...args), "invokeWillResolveField");
          Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
          if (config2.fieldResolver) {
            Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {
              value: config2.fieldResolver
            });
          }
          (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config2.schema);
        }
        try {
          const result = await execute(requestContext);
          const resultErrors = (_b = result.errors) === null || _b === void 0 ? void 0 : _b.map((e) => {
            if (isBadUserInputGraphQLError(e)) {
              return (0, apollo_server_errors_1.fromGraphQLError)(e, {
                errorClass: apollo_server_errors_1.UserInputError
              });
            }
            return e;
          });
          if (resultErrors) {
            await didEncounterErrors(resultErrors);
          }
          response = {
            ...result,
            errors: resultErrors ? formatErrors(resultErrors) : void 0
          };
          await executionDispatcher.invokeHook("executionDidEnd");
        } catch (executionError) {
          await executionDispatcher.invokeHook("executionDidEnd", executionError);
          return await sendErrorResponse(executionError);
        }
      }
      if (config2.formatResponse) {
        const formattedResponse = config2.formatResponse(response, requestContext);
        if (formattedResponse != null) {
          response = formattedResponse;
        }
      }
      return sendResponse(response);
      function parse(query2, parseOptions) {
        return (0, graphql_1.parse)(query2, parseOptions);
      }
      __name(parse, "parse");
      function validate(document) {
        let rules = graphql_1.specifiedRules;
        if (config2.validationRules) {
          rules = rules.concat(config2.validationRules);
        }
        return (0, graphql_1.validate)(config2.schema, document, rules);
      }
      __name(validate, "validate");
      async function execute(requestContext2) {
        const { request: request3, document } = requestContext2;
        const executionArgs = {
          schema: config2.schema,
          document,
          rootValue: typeof config2.rootValue === "function" ? config2.rootValue(document) : config2.rootValue,
          contextValue: requestContext2.context,
          variableValues: request3.variables,
          operationName: request3.operationName,
          fieldResolver: config2.fieldResolver
        };
        if (config2.executor) {
          return await config2.executor(requestContext2);
        } else {
          return await (0, graphql_1.execute)(executionArgs);
        }
      }
      __name(execute, "execute");
      async function sendResponse(response2) {
        requestContext.response = {
          ...requestContext.response,
          errors: response2.errors,
          data: response2.data,
          extensions: response2.extensions
        };
        if (response2.http) {
          if (!requestContext.response.http) {
            requestContext.response.http = {
              headers: new apollo_server_env_1.Headers()
            };
          }
          if (response2.http.status) {
            requestContext.response.http.status = response2.http.status;
          }
          for (const [name, value] of response2.http.headers) {
            requestContext.response.http.headers.set(name, value);
          }
        }
        await dispatcher.invokeHook("willSendResponse", requestContext);
        return requestContext.response;
      }
      __name(sendResponse, "sendResponse");
      async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await dispatcher.invokeHook("didEncounterErrors", requestContext);
      }
      __name(didEncounterErrors, "didEncounterErrors");
      async function sendErrorResponse(errorOrErrors, errorClass) {
        const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];
        await didEncounterErrors(errors);
        const response2 = {
          errors: formatErrors(errors.map((err) => err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {
            errorClass
          })))
        };
        if (errors.every((err) => err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {
          response2.http = {
            status: 200,
            headers: new apollo_server_env_1.Headers({
              "Cache-Control": "private, no-cache, must-revalidate"
            })
          };
        } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {
          response2.http = {
            status: errors[0].statusCode,
            headers: new apollo_server_env_1.Headers(errors[0].headers)
          };
        }
        return sendResponse(response2);
      }
      __name(sendErrorResponse, "sendErrorResponse");
      function formatErrors(errors) {
        return (0, apollo_server_errors_1.formatApolloErrors)(errors, {
          formatter: config2.formatError,
          debug: requestContext.debug
        });
      }
      __name(formatErrors, "formatErrors");
      async function initializeRequestListenerDispatcher() {
        const requestListeners = [];
        if (config2.plugins) {
          for (const plugin of config2.plugins) {
            if (!plugin.requestDidStart)
              continue;
            const listener = await plugin.requestDidStart(requestContext);
            if (listener) {
              requestListeners.push(listener);
            }
          }
        }
        return new dispatcher_1.Dispatcher(requestListeners);
      }
      __name(initializeRequestListenerDispatcher, "initializeRequestListenerDispatcher");
      async function initializeDataSources() {
        if (config2.dataSources) {
          const context2 = requestContext.context;
          const dataSources = config2.dataSources();
          const initializers = [];
          for (const dataSource of Object.values(dataSources)) {
            if (dataSource.initialize) {
              initializers.push(dataSource.initialize({
                context: context2,
                cache: requestContext.cache
              }));
            }
          }
          await Promise.all(initializers);
          if ("dataSources" in context2) {
            throw new Error("Please use the dataSources config option instead of putting dataSources on the context yourself.");
          }
          context2.dataSources = dataSources;
        }
      }
      __name(initializeDataSources, "initializeDataSources");
    }
    __name(processGraphQLRequest, "processGraphQLRequest");
    exports2.processGraphQLRequest = processGraphQLRequest;
  }
});

// node_modules/apollo-server-core/dist/runHttpQuery.js
var require_runHttpQuery = __commonJS({
  "node_modules/apollo-server-core/dist/runHttpQuery.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneObject = exports2.processHTTPRequest = exports2.runHttpQuery = exports2.throwHttpGraphQLError = exports2.isHttpQueryError = exports2.HttpQueryError = void 0;
    var apollo_server_env_1 = require_index_browser();
    var apollo_server_errors_1 = require_dist();
    var whatwg_mimetype_1 = __importDefault(require_mime_type());
    var cachePolicy_1 = require_cachePolicy();
    var graphqlOptions_1 = require_graphqlOptions();
    var requestPipeline_1 = require_requestPipeline();
    var HttpQueryError = class extends Error {
      static {
        __name(this, "HttpQueryError");
      }
      constructor(statusCode, message, isGraphQLError = false, headers) {
        super(message);
        this.name = "HttpQueryError";
        this.statusCode = statusCode;
        this.isGraphQLError = isGraphQLError;
        this.headers = headers;
      }
    };
    exports2.HttpQueryError = HttpQueryError;
    function isHttpQueryError(e) {
      return (e === null || e === void 0 ? void 0 : e.name) === "HttpQueryError";
    }
    __name(isHttpQueryError, "isHttpQueryError");
    exports2.isHttpQueryError = isHttpQueryError;
    function throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {
      const allHeaders = {
        "Content-Type": "application/json"
      };
      if (headers) {
        for (const [name, value] of headers) {
          allHeaders[name] = value;
        }
      }
      const result = {
        errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {
          debug: options.debug,
          formatter: options.formatError
        }) : errors
      };
      if (extensions) {
        result.extensions = extensions;
      }
      throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);
    }
    __name(throwHttpGraphQLError, "throwHttpGraphQLError");
    exports2.throwHttpGraphQLError = throwHttpGraphQLError;
    var NODE_ENV = (_a = "undefined") !== null && _a !== void 0 ? _a : "";
    var NON_PREFLIGHTED_CONTENT_TYPES = [
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ];
    function preventCsrf(headers, csrfPreventionRequestHeaders) {
      const contentType = headers.get("content-type");
      if (contentType !== null) {
        const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);
        if (contentTypeParsed === null) {
          return;
        }
        if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
          return;
        }
      }
      if (csrfPreventionRequestHeaders.some((header) => {
        const value = headers.get(header);
        return value !== null && value.length > 0;
      })) {
        return;
      }
      throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery (CSRF). Please either specify a 'content-type' header (with a type that is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(", ")}) or provide a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(", ")}
`);
    }
    __name(preventCsrf, "preventCsrf");
    async function runHttpQuery(handlerArguments, request2, csrfPreventionRequestHeaders) {
      function debugFromNodeEnv(nodeEnv = NODE_ENV) {
        return nodeEnv !== "production" && nodeEnv !== "test";
      }
      __name(debugFromNodeEnv, "debugFromNodeEnv");
      if (csrfPreventionRequestHeaders) {
        preventCsrf(request2.request.headers, csrfPreventionRequestHeaders);
      }
      let options;
      try {
        options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request2.options, ...handlerArguments);
      } catch (e) {
        return throwHttpGraphQLError(500, [e], {
          debug: debugFromNodeEnv()
        });
      }
      if (options.debug === void 0) {
        options.debug = debugFromNodeEnv(options.nodeEnv);
      }
      if (typeof options.context === "function") {
        try {
          options.context();
        } catch (e) {
          e.message = `Context creation failed: ${e.message}`;
          if (e.extensions && e.extensions.code && e.extensions.code !== "INTERNAL_SERVER_ERROR") {
            return throwHttpGraphQLError(400, [e], options);
          } else {
            return throwHttpGraphQLError(500, [e], options);
          }
        }
      }
      const config2 = {
        schema: options.schema,
        schemaHash: options.schemaHash,
        logger: options.logger,
        rootValue: options.rootValue,
        context: options.context || {},
        validationRules: options.validationRules,
        executor: options.executor,
        fieldResolver: options.fieldResolver,
        cache: options.cache,
        dataSources: options.dataSources,
        dangerouslyDisableValidation: options.dangerouslyDisableValidation,
        documentStore: options.documentStore,
        persistedQueries: options.persistedQueries,
        formatError: options.formatError,
        formatResponse: options.formatResponse,
        debug: options.debug,
        plugins: options.plugins || [],
        allowBatchedHttpRequests: options.allowBatchedHttpRequests
      };
      return processHTTPRequest(config2, request2);
    }
    __name(runHttpQuery, "runHttpQuery");
    exports2.runHttpQuery = runHttpQuery;
    async function processHTTPRequest(options, httpRequest) {
      var _a2, _b;
      let requestPayload;
      switch (httpRequest.method) {
        case "POST":
          if (!httpRequest.query || typeof httpRequest.query === "string" || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {
            throw new HttpQueryError(400, "POST body missing, invalid Content-Type, or JSON object has no keys.");
          }
          requestPayload = httpRequest.query;
          break;
        case "GET":
          if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {
            throw new HttpQueryError(400, "GET query missing.");
          }
          requestPayload = httpRequest.query;
          break;
        default:
          throw new HttpQueryError(405, "Apollo Server supports only GET/POST requests.", false, {
            Allow: "GET, POST"
          });
      }
      options = {
        ...options,
        plugins: [checkOperationPlugin, ...options.plugins]
      };
      function buildRequestContext(request2, requestIsBatched) {
        const context2 = cloneObject(options.context);
        return {
          logger: options.logger || console,
          schema: options.schema,
          schemaHash: options.schemaHash,
          request: request2,
          response: {
            http: {
              headers: new apollo_server_env_1.Headers()
            }
          },
          context: context2,
          cache: options.cache,
          debug: options.debug,
          metrics: {},
          overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
          requestIsBatched
        };
      }
      __name(buildRequestContext, "buildRequestContext");
      const responseInit = {
        headers: {
          "Content-Type": "application/json"
        }
      };
      let body;
      try {
        if (Array.isArray(requestPayload)) {
          if (options.allowBatchedHttpRequests === false) {
            return throwHttpGraphQLError(400, [new Error("Operation batching disabled.")], options);
          }
          const requests = requestPayload.map((requestParams) => parseGraphQLRequest(httpRequest.request, requestParams));
          const responses = await Promise.all(requests.map(async (request2) => {
            try {
              const requestContext = buildRequestContext(request2, true);
              const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
              if (response.http) {
                for (const [name, value] of response.http.headers) {
                  responseInit.headers[name] = value;
                }
                if (response.http.status) {
                  responseInit.status = response.http.status;
                }
              }
              return response;
            } catch (error3) {
              return {
                errors: (0, apollo_server_errors_1.formatApolloErrors)([error3], options)
              };
            }
          }));
          body = prettyJSONStringify(responses.map(serializeGraphQLResponse));
        } else {
          const request2 = parseGraphQLRequest(httpRequest.request, requestPayload);
          const requestContext = buildRequestContext(request2, false);
          const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
          if (response.errors && typeof response.data === "undefined") {
            return throwHttpGraphQLError(((_a2 = response.http) === null || _a2 === void 0 ? void 0 : _a2.status) || 400, response.errors, void 0, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);
          }
          if (response.http) {
            for (const [name, value] of response.http.headers) {
              responseInit.headers[name] = value;
            }
            if (response.http.status) {
              responseInit.status = response.http.status;
            }
          }
          body = prettyJSONStringify(serializeGraphQLResponse(response));
        }
      } catch (error3) {
        if (error3 instanceof HttpQueryError) {
          throw error3;
        }
        return throwHttpGraphQLError(500, [error3], options);
      }
      responseInit.headers["Content-Length"] = Buffer.byteLength(body, "utf8").toString();
      return {
        graphqlResponse: body,
        responseInit
      };
    }
    __name(processHTTPRequest, "processHTTPRequest");
    exports2.processHTTPRequest = processHTTPRequest;
    function parseGraphQLRequest(httpRequest, requestParams) {
      let queryString = requestParams.query;
      let extensions = requestParams.extensions;
      if (typeof extensions === "string" && extensions !== "") {
        try {
          extensions = JSON.parse(extensions);
        } catch (error3) {
          throw new HttpQueryError(400, "Extensions are invalid JSON.");
        }
      }
      if (queryString && typeof queryString !== "string") {
        if (queryString.kind === "Document") {
          throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the internal graphql-js representation of a parsed query in your request instead of a request in the GraphQL query language. You can convert an AST to a string using the `print` function from `graphql`, or use a client like `apollo-client` which converts the internal representation to a string for you.");
        } else {
          throw new HttpQueryError(400, "GraphQL queries must be strings.");
        }
      }
      const operationName = requestParams.operationName;
      let variables = requestParams.variables;
      if (typeof variables === "string" && variables !== "") {
        try {
          variables = JSON.parse(variables);
        } catch (error3) {
          throw new HttpQueryError(400, "Variables are invalid JSON.");
        }
      }
      return {
        query: queryString,
        operationName,
        variables,
        extensions,
        http: httpRequest
      };
    }
    __name(parseGraphQLRequest, "parseGraphQLRequest");
    var checkOperationPlugin = {
      async requestDidStart() {
        return {
          async didResolveOperation({ request: request2, operation }) {
            if (!request2.http)
              return;
            if (request2.http.method === "GET" && operation.operation !== "query") {
              throw new HttpQueryError(405, `GET supports only query operation`, false, {
                Allow: "POST"
              });
            }
          }
        };
      }
    };
    function serializeGraphQLResponse(response) {
      return {
        errors: response.errors,
        data: response.data,
        extensions: response.extensions
      };
    }
    __name(serializeGraphQLResponse, "serializeGraphQLResponse");
    function prettyJSONStringify(value) {
      return JSON.stringify(value) + "\n";
    }
    __name(prettyJSONStringify, "prettyJSONStringify");
    function cloneObject(object) {
      return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
    }
    __name(cloneObject, "cloneObject");
    exports2.cloneObject = cloneObject;
  }
});

// node_modules/apollo-server-core/dist/nodeHttpToRequest.js
var require_nodeHttpToRequest = __commonJS({
  "node_modules/apollo-server-core/dist/nodeHttpToRequest.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertNodeHttpToRequest = void 0;
    var apollo_server_env_1 = require_index_browser();
    function convertNodeHttpToRequest(req) {
      const headers = new apollo_server_env_1.Headers();
      Object.keys(req.headers).forEach((key) => {
        const values = req.headers[key];
        if (Array.isArray(values)) {
          values.forEach((value) => headers.append(key, value));
        } else {
          headers.append(key, values);
        }
      });
      return new apollo_server_env_1.Request(req.url, {
        headers,
        method: req.method
      });
    }
    __name(convertNodeHttpToRequest, "convertNodeHttpToRequest");
    exports2.convertNodeHttpToRequest = convertNodeHttpToRequest;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    var __addDisposableResource;
    var __disposeResources;
    var __rewriteRelativeImportExtension;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
      __name(createExporter, "createExporter");
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };
      __extends = /* @__PURE__ */ __name(function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }, "__extends");
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      __rest = /* @__PURE__ */ __name(function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      }, "__rest");
      __decorate = /* @__PURE__ */ __name(function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      }, "__decorate");
      __param = /* @__PURE__ */ __name(function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }, "__param");
      __esDecorate = /* @__PURE__ */ __name(function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
          return f;
        }
        __name(accept, "accept");
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
          var context2 = {};
          for (var p in contextIn) context2[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access) context2.access[p] = contextIn.access[p];
          context2.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
          if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
          } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
          }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      }, "__esDecorate");
      __runInitializers = /* @__PURE__ */ __name(function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
          value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
      }, "__runInitializers");
      __propKey = /* @__PURE__ */ __name(function(x) {
        return typeof x === "symbol" ? x : "".concat(x);
      }, "__propKey");
      __setFunctionName = /* @__PURE__ */ __name(function(f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      }, "__setFunctionName");
      __metadata = /* @__PURE__ */ __name(function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      }, "__metadata");
      __awaiter = /* @__PURE__ */ __name(function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        __name(adopt, "adopt");
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          __name(fulfilled, "fulfilled");
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          __name(rejected, "rejected");
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          __name(step, "step");
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }, "__awaiter");
      __generator = /* @__PURE__ */ __name(function(thisArg, body) {
        var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, "sent"), trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        __name(verb, "verb");
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
        __name(step, "step");
      }, "__generator");
      __exportStar = /* @__PURE__ */ __name(function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
      }, "__exportStar");
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
            return m[k];
          }, "get") };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      };
      __values = /* @__PURE__ */ __name(function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: /* @__PURE__ */ __name(function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }, "next")
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, "__values");
      __read = /* @__PURE__ */ __name(function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error3) {
          e = { error: error3 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      }, "__read");
      __spread = /* @__PURE__ */ __name(function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      }, "__spread");
      __spreadArrays = /* @__PURE__ */ __name(function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      }, "__spreadArrays");
      __spreadArray = /* @__PURE__ */ __name(function(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
      }, "__spreadArray");
      __await = /* @__PURE__ */ __name(function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }, "__await");
      __asyncGenerator = /* @__PURE__ */ __name(function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function awaitReturn(f) {
          return function(v) {
            return Promise.resolve(v).then(f, reject);
          };
        }
        __name(awaitReturn, "awaitReturn");
        function verb(n, f) {
          if (g[n]) {
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
            if (f) i[n] = f(i[n]);
          }
        }
        __name(verb, "verb");
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        __name(resume, "resume");
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        __name(step, "step");
        function fulfill(value) {
          resume("next", value);
        }
        __name(fulfill, "fulfill");
        function reject(value) {
          resume("throw", value);
        }
        __name(reject, "reject");
        function settle(f, v) {
          if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
        __name(settle, "settle");
      }, "__asyncGenerator");
      __asyncDelegator = /* @__PURE__ */ __name(function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
        __name(verb, "verb");
      }, "__asyncDelegator");
      __asyncValues = /* @__PURE__ */ __name(function(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        __name(verb, "verb");
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
        __name(settle, "settle");
      }, "__asyncValues");
      __makeTemplateObject = /* @__PURE__ */ __name(function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }, "__makeTemplateObject");
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      __importStar = /* @__PURE__ */ __name(function(mod2) {
        if (mod2 && mod2.__esModule) return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      }, "__importStar");
      __importDefault = /* @__PURE__ */ __name(function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      }, "__importDefault");
      __classPrivateFieldGet = /* @__PURE__ */ __name(function(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      }, "__classPrivateFieldGet");
      __classPrivateFieldSet = /* @__PURE__ */ __name(function(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      }, "__classPrivateFieldSet");
      __classPrivateFieldIn = /* @__PURE__ */ __name(function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      }, "__classPrivateFieldIn");
      __addDisposableResource = /* @__PURE__ */ __name(function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
          var dispose, inner;
          if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
          }
          if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
          if (inner) dispose = /* @__PURE__ */ __name(function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          }, "dispose");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      }, "__addDisposableResource");
      var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error3, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error3, e.suppressed = suppressed, e;
      };
      __disposeResources = /* @__PURE__ */ __name(function(env2) {
        function fail(e) {
          env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
          env2.hasError = true;
        }
        __name(fail, "fail");
        var r, s = 0;
        function next() {
          while (r = env2.stack.pop()) {
            try {
              if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
              } else s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
          if (env2.hasError) throw env2.error;
        }
        __name(next, "next");
        return next();
      }, "__disposeResources");
      __rewriteRelativeImportExtension = /* @__PURE__ */ __name(function(path, preserveJsx) {
        if (typeof path === "string" && /^\.\.?\//.test(path)) {
          return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
          });
        }
        return path;
      }, "__rewriteRelativeImportExtension");
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
      exporter("__addDisposableResource", __addDisposableResource);
      exporter("__disposeResources", __disposeResources);
      exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
    });
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return (/* @__PURE__ */ __name(function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i) out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }, "stringify"))(data);
    };
  }
});

// node_modules/@graphql-tools/mock/cjs/types.js
var require_types = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRecord = exports2.assertIsRef = exports2.isRef = void 0;
    function isRef(maybeRef) {
      return !!(maybeRef && typeof maybeRef === "object" && "$ref" in maybeRef);
    }
    __name(isRef, "isRef");
    exports2.isRef = isRef;
    function assertIsRef(maybeRef, message) {
      if (!isRef(maybeRef)) {
        throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);
      }
    }
    __name(assertIsRef, "assertIsRef");
    exports2.assertIsRef = assertIsRef;
    function isRecord(obj) {
      return typeof obj === "object" && obj !== null;
    }
    __name(isRecord, "isRecord");
    exports2.isRecord = isRecord;
  }
});

// node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = require_graphql2();
    var asArray = /* @__PURE__ */ __name((fns) => Array.isArray(fns) ? fns : fns ? [fns] : [], "asArray");
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isDocumentString, "isDocumentString");
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    __name(isValidPath, "isValidPath");
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    __name(compareStrings, "compareStrings");
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    __name(nodeToString, "nodeToString");
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    __name(compareNodes, "compareNodes");
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    __name(isSome, "isSome");
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    __name(assertSome, "assertSome");
    exports2.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/utils/cjs/jsutils.js
var require_jsutils = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/jsutils.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasOwnProperty = exports2.promiseReduce = exports2.isPromise = exports2.isObjectLike = exports2.isIterableObject = void 0;
    function isIterableObject(value) {
      return value != null && typeof value === "object" && Symbol.iterator in value;
    }
    __name(isIterableObject, "isIterableObject");
    exports2.isIterableObject = isIterableObject;
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    __name(isObjectLike, "isObjectLike");
    exports2.isObjectLike = isObjectLike;
    function isPromise(value) {
      return isObjectLike(value) && typeof value["then"] === "function";
    }
    __name(isPromise, "isPromise");
    exports2.isPromise = isPromise;
    function promiseReduce(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    __name(promiseReduce, "promiseReduce");
    exports2.promiseReduce = promiseReduce;
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    __name(hasOwnProperty, "hasOwnProperty");
    exports2.hasOwnProperty = hasOwnProperty;
  }
});

// node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = require_graphql2();
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    __name(createGraphQLError, "createGraphQLError");
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    __name(relocatedError, "relocatedError");
    exports2.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        static {
          __name(this, "AggregateErrorClass");
        }
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = /* @__PURE__ */ __name(function(errors, message) {
        return new AggregateErrorClass(errors, message);
      }, "AggregateErrorImpl");
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error3) {
      return "errors" in error3 && Array.isArray(error3["errors"]);
    }
    __name(isAggregateError, "isAggregateError");
    exports2.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = require_graphql2();
    var AggregateError_js_1 = require_AggregateError();
    var MAX_RECURSIVE_DEPTH = 3;
    function inspect2(value) {
      return formatValue(value, []);
    }
    __name(inspect2, "inspect");
    exports2.inspect = inspect2;
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    __name(formatValue, "formatValue");
    function formatError(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    __name(formatError, "formatError");
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    __name(formatObjectValue, "formatObjectValue");
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    __name(isJSONable, "isJSONable");
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    __name(formatObject, "formatObject");
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      return "[" + items.join(", ") + "]";
    }
    __name(formatArray, "formatArray");
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
    __name(getObjectTag, "getObjectTag");
  }
});

// node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var jsutils_js_1 = require_jsutils();
    var graphql_1 = require_graphql2();
    var errors_js_1 = require_errors();
    var inspect_js_1 = require_inspect2();
    function getArgumentValues(def, node, variableValues = {}) {
      var _a;
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !(0, jsutils_js_1.hasOwnProperty)(variableValues, variableName)) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    __name(getArgumentValues, "getArgumentValues");
    exports2.getArgumentValues = getArgumentValues;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    __name(getDirectivesInExtensions, "getDirectivesInExtensions");
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    __name(_getDirectiveInExtensions, "_getDirectiveInExtensions");
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    __name(getDirectiveInExtensions, "getDirectiveInExtensions");
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    __name(getDirectives, "getDirectives");
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    __name(getDirective, "getDirective");
    exports2.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = require_graphql2();
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type2 of allTypes) {
        const typeName = type2.name.value;
        if (type2.fields == null) {
          continue;
        }
        for (const field of type2.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: (0, graphql_1.valueFromASTUntyped)(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    __name(getFieldsWithDirectives, "getFieldsWithDirectives");
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js
var require_get_arguments_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentsWithDirectives = void 0;
    var graphql_1 = require_graphql2();
    function isTypeWithFields(t) {
      return t.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || t.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
    }
    __name(isTypeWithFields, "isTypeWithFields");
    function getArgumentsWithDirectives(documentNode) {
      var _a;
      const result = {};
      const allTypes = documentNode.definitions.filter(isTypeWithFields);
      for (const type2 of allTypes) {
        if (type2.fields == null) {
          continue;
        }
        for (const field of type2.fields) {
          const argsWithDirectives = (_a = field.arguments) === null || _a === void 0 ? void 0 : _a.filter((arg) => {
            var _a2;
            return (_a2 = arg.directives) === null || _a2 === void 0 ? void 0 : _a2.length;
          });
          if (!(argsWithDirectives === null || argsWithDirectives === void 0 ? void 0 : argsWithDirectives.length)) {
            continue;
          }
          const typeFieldResult = result[`${type2.name.value}.${field.name.value}`] = {};
          for (const arg of argsWithDirectives) {
            const directives = arg.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, dArg) => ({ ...prev, [dArg.name.value]: (0, graphql_1.valueFromASTUntyped)(dArg.value) }), {})
            }));
            typeFieldResult[arg.name.value] = directives;
          }
        }
      }
      return result;
    }
    __name(getArgumentsWithDirectives, "getArgumentsWithDirectives");
    exports2.getArgumentsWithDirectives = getArgumentsWithDirectives;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = require_graphql2();
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    __name(getImplementingTypes, "getImplementingTypes");
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = require_graphql2();
    var inspect_js_1 = require_inspect2();
    function astFromType(type2) {
      if ((0, graphql_1.isNonNullType)(type2)) {
        const innerType = astFromType(type2.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type2)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type2)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type2.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        }
      };
    }
    __name(astFromType, "astFromType");
    exports2.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = require_graphql2();
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    __name(astFromValueUntyped, "astFromValueUntyped");
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of5 = exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize1, "memoize1");
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2, "memoize2");
    exports2.memoize2 = memoize2;
    function memoize3(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize3, "memoize3");
    exports2.memoize3 = memoize3;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize4, "memoize4");
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize5, "memoize5");
    exports2.memoize5 = memoize5;
    function memoize2of4(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2of4, "memoize2of4");
    exports2.memoize2of4 = memoize2of4;
    function memoize2of5(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2of5, "memoize2of5");
    exports2.memoize2of5 = memoize2of5;
  }
});

// node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var errors_js_1 = require_errors();
    var memoize_js_1 = require_memoize();
    function getDefinedRootType(schema, operation, nodes) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw (0, errors_js_1.createGraphQLError)(`Schema is not configured to execute ${operation} operation.`, {
          nodes
        });
      }
      return rootType;
    }
    __name(getDefinedRootType, "getDefinedRootType");
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type2) => type2.name));
    }, "getRootTypeNames"));
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    }, "getRootTypes"));
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    }, "getRootTypeMap"));
  }
});

// node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = require_graphql2();
    var astFromType_js_1 = require_astFromType();
    var get_directives_js_1 = require_get_directives();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped();
    var helpers_js_1 = require_helpers();
    var rootTypes_js_1 = require_rootTypes();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type2 = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type2);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type2);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type2)) {
          definitions.push(astFromObjectType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          definitions.push(astFromInterfaceType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type2)) {
          definitions.push(astFromUnionType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          definitions.push(astFromInputObjectType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type2)) {
          definitions.push(astFromEnumType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type2)) {
          definitions.push(astFromScalarType(type2, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type2}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    __name(getDocumentNodeFromSchema, "getDocumentNodeFromSchema");
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    __name(printSchemaWithDirectives, "printSchemaWithDirectives");
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    __name(astFromSchema, "astFromSchema");
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    __name(astFromDirective, "astFromDirective");
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    __name(getDirectiveNodes, "getDirectiveNodes");
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    __name(getDeprecatableDirectiveNodes, "getDeprecatableDirectiveNodes");
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromArg, "astFromArg");
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type2.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromObjectType, "astFromObjectType");
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type2) {
        node.interfaces = Object.values(type2.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    __name(astFromInterfaceType, "astFromInterfaceType");
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions),
        types: type2.getTypes().map((type3) => (0, astFromType_js_1.astFromType)(type3))
      };
    }
    __name(astFromUnionType, "astFromUnionType");
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromInputObjectType, "astFromInputObjectType");
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        values: Object.values(type2.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromEnumType, "astFromEnumType");
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type2, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type2["specifiedByUrl"] || type2["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    __name(astFromScalarType, "astFromScalarType");
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromField, "astFromField");
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    __name(astFromInputField, "astFromInputField");
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromEnumValue, "astFromEnumValue");
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    __name(makeDeprecatedDirective, "makeDeprecatedDirective");
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    __name(makeDirectiveNode, "makeDirectiveNode");
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    __name(makeDirectiveNodes, "makeDirectiveNodes");
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = require_graphql2();
    function validateGraphQlDocuments(schema, documents, rules = createDefaultRules()) {
      var _a;
      const definitionMap = /* @__PURE__ */ new Map();
      for (const document of documents) {
        for (const docDefinition of document.definitions) {
          if ("name" in docDefinition && docDefinition.name) {
            definitionMap.set(`${docDefinition.kind}_${docDefinition.name.value}`, docDefinition);
          } else {
            definitionMap.set(Date.now().toString(), docDefinition);
          }
        }
      }
      const fullAST = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: Array.from(definitionMap.values())
      };
      const errors = (0, graphql_1.validate)(schema, fullAST, rules);
      for (const error3 of errors) {
        error3.stack = error3.message;
        if (error3.locations) {
          for (const location of error3.locations) {
            error3.stack += `
    at ${(_a = error3.source) === null || _a === void 0 ? void 0 : _a.name}:${location.line}:${location.column}`;
          }
        }
      }
      return errors;
    }
    __name(validateGraphQlDocuments, "validateGraphQlDocuments");
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    __name(createDefaultRules, "createDefaultRules");
    exports2.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = require_graphql2();
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    __name(stripBOM, "stripBOM");
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    __name(parseBOM, "parseBOM");
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    __name(parseGraphQLJSON, "parseGraphQLJSON");
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = require_graphql2();
    var MAX_LINE_LENGTH = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    __name(resetComments, "resetComments");
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    __name(collectComment, "collectComment");
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    __name(pushComment, "pushComment");
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    __name(printComment, "printComment");
    exports2.printComment = printComment;
    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    __name(join, "join");
    function hasMultilineItems(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    __name(hasMultilineItems, "hasMultilineItems");
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    __name(addDescription, "addDescription");
    function indent(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    __name(indent, "indent");
    function block(array) {
      return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
    }
    __name(block, "block");
    function wrap(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    __name(wrap, "wrap");
    function printBlockString(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
    }
    __name(printBlockString, "printBlockString");
    var printDocASTReducer = {
      Name: { leave: /* @__PURE__ */ __name((node) => node.value, "leave") },
      Variable: { leave: /* @__PURE__ */ __name((node) => "$" + node.name, "leave") },
      // Document
      Document: {
        leave: /* @__PURE__ */ __name((node) => join(node.definitions, "\n\n"), "leave")
      },
      OperationDefinition: {
        leave: /* @__PURE__ */ __name((node) => {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }, "leave")
      },
      VariableDefinition: {
        leave: /* @__PURE__ */ __name(({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " ")), "leave")
      },
      SelectionSet: { leave: /* @__PURE__ */ __name(({ selections }) => block(selections), "leave") },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
      // Fragments
      FragmentSpread: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => "..." + name + wrap(" ", join(directives, " ")), "leave")
      },
      InlineFragment: {
        leave: /* @__PURE__ */ __name(({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " "), "leave")
      },
      FragmentDefinition: {
        leave: /* @__PURE__ */ __name(({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        ), "leave")
      },
      // Value
      IntValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      FloatValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      StringValue: {
        leave: /* @__PURE__ */ __name(({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }, "leave")
      },
      BooleanValue: { leave: /* @__PURE__ */ __name(({ value }) => value ? "true" : "false", "leave") },
      NullValue: { leave: /* @__PURE__ */ __name(() => "null", "leave") },
      EnumValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      ListValue: { leave: /* @__PURE__ */ __name(({ values }) => "[" + join(values, ", ") + "]", "leave") },
      ObjectValue: { leave: /* @__PURE__ */ __name(({ fields }) => "{" + join(fields, ", ") + "}", "leave") },
      ObjectField: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
      // Directive
      Directive: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")"), "leave")
      },
      // Type
      NamedType: { leave: /* @__PURE__ */ __name(({ name }) => name, "leave") },
      ListType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => "[" + type2 + "]", "leave") },
      NonNullType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => type2 + "!", "leave") },
      // Type System Definitions
      SchemaDefinition: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      OperationTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ operation, type: type2 }) => operation + ": " + type2, "leave")
      },
      ScalarTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      FieldDefinition: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args, type: type2, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " ")), "leave")
      },
      InputValueDefinition: {
        leave: /* @__PURE__ */ __name(({ name, type: type2, defaultValue, directives }) => join([name + ": " + type2, wrap("= ", defaultValue), join(directives, " ")], " "), "leave")
      },
      InterfaceTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      UnionTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
      },
      EnumTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      EnumValueDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join([name, join(directives, " ")], " "), "leave")
      },
      InputObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " "), "leave")
      },
      DirectiveDefinition: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | "), "leave")
      },
      SchemaExtension: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      ScalarTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      InterfaceTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      UnionTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
      },
      EnumTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      InputObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " "), "leave")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    __name(printWithComments, "printWithComments");
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    __name(isFieldDefinitionNode, "isFieldDefinitionNode");
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    __name(getDescription, "getDescription");
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    __name(getComment, "getComment");
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    __name(getLeadingCommentBlock, "getLeadingCommentBlock");
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    __name(dedentBlockStringValue, "dedentBlockStringValue");
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent2 = leadingWhitespace(line);
        if (indent2 === line.length) {
          continue;
        }
        if (commonIndent === null || indent2 < commonIndent) {
          commonIndent = indent2;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    __name(getBlockStringIndentation, "getBlockStringIndentation");
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    __name(leadingWhitespace, "leadingWhitespace");
    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
    __name(isBlank, "isBlank");
  }
});

// node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = require_graphql2();
    var comments_js_1 = require_comments();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);
          }
        } else {
          document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document
      };
    }
    __name(parseGraphQLSDL, "parseGraphQLSDL");
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: /* @__PURE__ */ __name((node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }, "leave")
      });
      return modifiedDoc;
    }
    __name(transformCommentsToDescriptions, "transformCommentsToDescriptions");
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    __name(isDescribable, "isDescribable");
    exports2.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = require_graphql2();
    var rootTypes_js_1 = require_rootTypes();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    __name(addOperationVariable, "addOperationVariable");
    function resetOperationVariables() {
      operationVariables = [];
    }
    __name(resetOperationVariables, "resetOperationVariables");
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    __name(resetFieldMap, "resetFieldMap");
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    __name(buildOperationNodeForField, "buildOperationNodeForField");
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type2 = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type2.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type: type2,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    __name(buildOperationAndCollectVariables, "buildOperationAndCollectVariables");
    function resolveSelectionSet({ parent, type: type2, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type2)) {
        const types3 = type2.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types3.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type2,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type2)) {
        const types3 = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type2));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types3.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type2,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type2) && !rootTypeNames.has(type2.name)) {
        const isIgnored = ignore.includes(type2.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type2.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type2.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type: type2,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    __name(resolveSelectionSet, "resolveSelectionSet");
    function resolveVariable(arg, name) {
      function resolveVariableType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type2.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type2)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type2.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type2.name
          }
        };
      }
      __name(resolveVariableType, "resolveVariableType");
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    __name(resolveVariable, "resolveVariable");
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    __name(getArgumentName, "getArgumentName");
    function resolveField({ type: type2, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull").replace("[", "List").replace("]", "");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type2,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type2],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    __name(resolveField, "resolveField");
    function hasCircularRef(types3, config2 = {
      depth: 1
    }) {
      const type2 = types3[types3.length - 1];
      if ((0, graphql_1.isScalarType)(type2)) {
        return false;
      }
      const size = types3.filter((t) => t.name === type2.name).length;
      return size > config2.depth;
    }
    __name(hasCircularRef, "hasCircularRef");
  }
});

// node_modules/@graphql-tools/utils/cjs/types.js
var require_types2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = require_graphql2();
    function getObjectTypeFromTypeMap(typeMap, type2) {
      if (type2) {
        const maybeObjectType = typeMap[type2.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    __name(getObjectTypeFromTypeMap, "getObjectTypeFromTypeMap");
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = require_graphql2();
    function createNamedStub(name, type2) {
      let constructor;
      if (type2 === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type2 === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    __name(createNamedStub, "createNamedStub");
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type2) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type2));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type2));
        default:
          if (type2 === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    __name(createStub, "createStub");
    exports2.createStub = createStub;
    function isNamedStub(type2) {
      if ("getFields" in type2) {
        const fields = type2.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    __name(isNamedStub, "isNamedStub");
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type2) {
      switch (type2.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type2;
      }
    }
    __name(getBuiltInForStub, "getBuiltInForStub");
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = require_graphql2();
    var stub_js_1 = require_stub();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
          continue;
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      __name(rewireDirective, "rewireDirective");
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      __name(rewireArgs, "rewireArgs");
      function rewireNamedType(type2) {
        if ((0, graphql_1.isObjectType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields"),
            interfaces: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.interfaces), "interfaces")
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields")
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            types: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.types), "types")
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireInputFields(config2.fields), "fields")
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const enumConfig = type2.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type2)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type2)) {
            return type2;
          }
          const scalarConfig = type2.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type2}`);
      }
      __name(rewireNamedType, "rewireNamedType");
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      __name(rewireFields, "rewireFields");
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      __name(rewireInputFields, "rewireInputFields");
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      __name(rewireNamedTypes, "rewireNamedTypes");
      function rewireType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          const rewiredType = rewireType(type2.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type2)) {
          const rewiredType = rewireType(type2.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type2)) {
          let rewiredType = referenceTypeMap[type2.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type2) ? (0, stub_js_1.getBuiltInForStub)(type2) : rewireNamedType(type2);
            newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
      __name(rewireType, "rewireType");
    }
    __name(rewireTypes, "rewireTypes");
    exports2.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = require_graphql2();
    var helpers_js_1 = require_helpers();
    function transformInputValue(type2, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type2);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return (0, helpers_js_1.asArray)(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    __name(transformInputValue, "transformInputValue");
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type2, value) {
      return transformInputValue(type2, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    __name(serializeInputValue, "serializeInputValue");
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type2, value) {
      return transformInputValue(type2, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    __name(parseInputValue, "parseInputValue");
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type2, value) {
      return transformInputValue(type2, value, (t, v) => t.parseLiteral(v, {}));
    }
    __name(parseInputValueLiteral, "parseInputValueLiteral");
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = require_graphql2();
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var Interfaces_js_1 = require_Interfaces();
    var rewire_js_1 = require_rewire();
    var transformInputValue_js_1 = require_transformInputValue();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type2) => (0, graphql_1.isLeafType)(type2)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type2) => !(0, graphql_1.isLeafType)(type2)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    __name(mapSchema, "mapSchema");
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    __name(mapTypes, "mapTypes");
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => {
          const config2 = type2.toConfig();
          const originalEnumValueConfigMap = config2.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config2,
            values: newEnumValueConfigMap
          }));
        }
      }, (type2) => (0, graphql_1.isEnumType)(type2));
    }
    __name(mapEnumValues, "mapEnumValues");
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    __name(mapDefaultValues, "mapDefaultValues");
    function getNewType(newTypeMap, type2) {
      if ((0, graphql_1.isListType)(type2)) {
        const newType = getNewType(newTypeMap, type2.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type2)) {
        const newType = getNewType(newTypeMap, type2.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type2)) {
        const newType = newTypeMap[type2.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    __name(getNewType, "getNewType");
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    __name(mapFields, "mapFields");
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    __name(mapArguments, "mapArguments");
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    __name(mapDirectives, "mapDirectives");
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type2 = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    __name(getTypeSpecifiers, "getTypeSpecifiers");
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    __name(getTypeMapper, "getTypeMapper");
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type2 = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    __name(getFieldSpecifiers, "getFieldSpecifiers");
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    __name(getFieldMapper, "getFieldMapper");
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    __name(getArgumentMapper, "getArgumentMapper");
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    __name(getDirectiveMapper, "getDirectiveMapper");
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    __name(getEnumValueMapper, "getEnumValueMapper");
    function correctASTNodes(type2) {
      if ((0, graphql_1.isObjectType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config2);
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config2);
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config2);
      } else if ((0, graphql_1.isEnumType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const values = [];
          for (const enumKey in config2.values) {
            const enumValueConfig = config2.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            values
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config2);
      } else {
        return type2;
      }
    }
    __name(correctASTNodes, "correctASTNodes");
    exports2.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = require_graphql2();
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    function filterSchema({ schema, typeFilter = /* @__PURE__ */ __name(() => true, "typeFilter"), fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type2) => filterRootFields(type2, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type2) => filterRootFields(type2, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type2) => filterRootFields(type2, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLObjectType, type2, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLInterfaceType, type2, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLInputObjectType, type2, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null
      });
      return filteredSchema;
    }
    __name(filterSchema, "filterSchema");
    exports2.filterSchema = filterSchema;
    function filterRootFields(type2, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config2 = type2.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config2);
      }
      return type2;
    }
    __name(filterRootFields, "filterRootFields");
    function filterElementFields(ElementConstructor, type2, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config2 = type2.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (fieldFilter && !fieldFilter(type2.name, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type2.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config2);
      }
    }
    __name(filterElementFields, "filterElementFields");
  }
});

// node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = require_graphql2();
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    __name(healSchema, "healSchema");
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualNamedTypeMap[actualName] != null) {
          console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
          continue;
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type2) {
        if ((0, graphql_1.isObjectType)(type2)) {
          healFields(type2);
          healInterfaces(type2);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          healFields(type2);
          if ("getInterfaces" in type2) {
            healInterfaces(type2);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type2)) {
          healUnderlyingTypes(type2);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          healInputFields(type2);
          return;
        } else if ((0, graphql_1.isLeafType)(type2)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type2}`);
      }
      __name(healNamedType, "healNamedType");
      function healFields(type2) {
        const fieldMap = type2.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      __name(healFields, "healFields");
      function healInterfaces(type2) {
        if ("getInterfaces" in type2) {
          const interfaces = type2.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      __name(healInterfaces, "healInterfaces");
      function healInputFields(type2) {
        const fieldMap = type2.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      __name(healInputFields, "healInputFields");
      function healUnderlyingTypes(type2) {
        const types3 = type2.getTypes();
        types3.push(...types3.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      __name(healUnderlyingTypes, "healUnderlyingTypes");
      function healType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          const healedType = healType(type2.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type2)) {
          const healedType = healType(type2.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type2)) {
          const officialType = originalTypeMap[type2.name];
          if (officialType && type2 !== officialType) {
            return officialType;
          }
        }
        return type2;
      }
      __name(healType, "healType");
    }
    __name(healTypes, "healTypes");
    exports2.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = require_graphql2();
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers2 = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type2 = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type2)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type2)) {
              const config2 = type2.toConfig();
              delete config2.astNode;
              resolvers2[typeName] = new graphql_1.GraphQLScalarType(config2);
            }
          } else if ((0, graphql_1.isEnumType)(type2)) {
            resolvers2[typeName] = {};
            const values = type2.getValues();
            for (const value of values) {
              resolvers2[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type2)) {
            if (type2.resolveType != null) {
              resolvers2[typeName] = {
                __resolveType: type2.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type2)) {
            if (type2.resolveType != null) {
              resolvers2[typeName] = {
                __resolveType: type2.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type2)) {
            resolvers2[typeName] = {};
            if (type2.isTypeOf != null) {
              resolvers2[typeName].__isTypeOf = type2.isTypeOf;
            }
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers2[typeName][fieldName] = resolvers2[typeName][fieldName] || {};
                resolvers2[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers2[typeName][fieldName] = resolvers2[typeName][fieldName] || {};
                resolvers2[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers2;
    }
    __name(getResolversFromSchema, "getResolversFromSchema");
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = require_graphql2();
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type2).name.startsWith("__") && (0, graphql_1.isObjectType)(type2)) {
          const fields = type2.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    __name(forEachField, "forEachField");
    exports2.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = require_graphql2();
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type2).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type2)) {
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type2)) {
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    __name(forEachDefaultValue, "forEachDefaultValue");
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = require_graphql2();
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var rewire_js_1 = require_rewire();
    function addTypes(schema, newTypesOrDirectives) {
      const config2 = schema.toConfig();
      const originalTypeMap = {};
      for (const type2 of config2.types) {
        originalTypeMap[type2.name] = type2;
      }
      const originalDirectiveMap = {};
      for (const directive of config2.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config2,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    __name(addTypes, "addTypes");
    exports2.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = require_graphql2();
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    var rootTypes_js_1 = require_rootTypes();
    var get_implementing_types_js_1 = require_get_implementing_types();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type2 = prunedSchema.getType(typeName);
            if (type2 && skipPruning(type2)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type2) => {
            if (!visited.has(type2.name) && !(0, graphql_1.isSpecifiedScalarType)(type2)) {
              if ((0, graphql_1.isUnionType)(type2) || (0, graphql_1.isInputObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2) || (0, graphql_1.isObjectType)(type2) || (0, graphql_1.isScalarType)(type2)) {
                if (skipUnusedTypesPruning) {
                  return type2;
                }
                if ((0, graphql_1.isUnionType)(type2) && skipEmptyUnionPruning && !Object.keys(type2.getTypes()).length) {
                  return type2;
                }
                if ((0, graphql_1.isInputObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2) || (0, graphql_1.isObjectType)(type2)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type2.getFields()).length) {
                    return type2;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type2) && skipUnimplementedInterfacesPruning) {
                  return type2;
                }
              }
              prunedTypes.push(type2.name);
              visited.delete(type2.name);
              return null;
            }
            return type2;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    __name(pruneSchema, "pruneSchema");
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type2 of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type2.name);
      }
      return visitQueue(queue, schema);
    }
    __name(visitSchema, "visitSchema");
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type2 = schema.getType(typeName);
        if (type2) {
          if ((0, graphql_1.isUnionType)(type2)) {
            queue.push(...type2.getTypes().map((type3) => type3.name));
          }
          if ((0, graphql_1.isInterfaceType)(type2) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type2.name, schema));
            revisit[typeName] = false;
          }
          if ((0, graphql_1.isEnumType)(type2)) {
            queue.push(...type2.getValues().flatMap((value) => {
              if (value.astNode) {
                return getDirectivesArgumentsTypeNames(schema, value.astNode);
              }
              return [];
            }));
          }
          if ("getInterfaces" in type2) {
            queue.push(...type2.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type2) {
            const fields = type2.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type2)) {
                queue.push(...field.args.flatMap((arg) => {
                  const typeNames = [(0, graphql_1.getNamedType)(arg.type).name];
                  if (arg.astNode) {
                    typeNames.push(...getDirectivesArgumentsTypeNames(schema, arg.astNode));
                  }
                  return typeNames;
                }));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if (field.astNode) {
                queue.push(...getDirectivesArgumentsTypeNames(schema, field.astNode));
              }
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          if (type2.astNode) {
            queue.push(...getDirectivesArgumentsTypeNames(schema, type2.astNode));
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
    __name(visitQueue, "visitQueue");
    function getDirectivesArgumentsTypeNames(schema, astNode) {
      var _a;
      return ((_a = astNode.directives) !== null && _a !== void 0 ? _a : []).flatMap((directive) => {
        var _a2, _b;
        return (_b = (_a2 = schema.getDirective(directive.name.value)) === null || _a2 === void 0 ? void 0 : _a2.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name)) !== null && _b !== void 0 ? _b : [];
      });
    }
    __name(getDirectivesArgumentsTypeNames, "getDirectivesArgumentsTypeNames");
  }
});

// node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject2(target) && isObject2(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject2(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    __name(mergeDeep, "mergeDeep");
    exports2.mergeDeep = mergeDeep;
    function isObject2(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
    __name(isObject2, "isObject");
  }
});

// node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = require_graphql2();
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    __name(parseSelectionSet, "parseSelectionSet");
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info3) {
      return info3.fieldNodes[0].alias != null ? info3.fieldNodes[0].alias.value : info3.fieldName;
    }
    __name(getResponseKeyFromInfo, "getResponseKeyFromInfo");
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = require_graphql2();
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    var addTypes_js_1 = require_addTypes();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    __name(appendObjectFields, "appendObjectFields");
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    __name(removeObjectFields, "removeObjectFields");
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    __name(selectObjectFields, "selectObjectFields");
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    __name(modifyObjectFields, "modifyObjectFields");
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = require_graphql2();
    function renameType(type2, newTypeName) {
      if ((0, graphql_1.isObjectType)(type2)) {
        return new graphql_1.GraphQLObjectType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type2)) {
        return new graphql_1.GraphQLUnionType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type2)) {
        return new graphql_1.GraphQLEnumType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type2)) {
        return new graphql_1.GraphQLScalarType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type2}.`);
    }
    __name(renameType, "renameType");
    exports2.renameType = renameType;
  }
});

// node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = /* @__PURE__ */ __name((error3) => {
          const rethrow = /* @__PURE__ */ __name(() => Promise.reject(error3), "rethrow");
          return $return.call(iterator).then(rethrow, rethrow);
        }, "abruptClose");
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      __name(mapResult, "mapResult");
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = /* @__PURE__ */ __name((error3) => asyncMapValue(error3, reject).then(iteratorResult, abruptClose), "mapReject");
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error3) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error3).then(mapResult, mapReject);
          }
          return Promise.reject(error3).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(mapAsyncIterator, "mapAsyncIterator");
    exports2.mapAsyncIterator = mapAsyncIterator;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    __name(asyncMapValue, "asyncMapValue");
    function iteratorResult(value) {
      return { value, done: false };
    }
    __name(iteratorResult, "iteratorResult");
  }
});

// node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = require_graphql2();
    var astFromType_js_1 = require_astFromType();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type2, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type2)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    __name(updateArgument, "updateArgument");
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    __name(createVariableNameGenerator, "createVariableNameGenerator");
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = require_graphql2();
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    __name(implementsAbstractType, "implementsAbstractType");
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = /* @__PURE__ */ __name((value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      }, "pushValue");
      const pushError = /* @__PURE__ */ __name((error3) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error3] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error3] }, done: false });
        }
      }, "pushError");
      const pushDone = /* @__PURE__ */ __name(() => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      }, "pushDone");
      const pullValue = /* @__PURE__ */ __name(() => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      }), "pullValue");
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = /* @__PURE__ */ __name(() => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      }, "emptyQueue");
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error3) {
          emptyQueue();
          return Promise.reject(error3);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(observableToAsyncIterable, "observableToAsyncIterable");
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = require_graphql2();
    var memoize_js_1 = require_memoize();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    __name(getOperationASTFromDocument, "getOperationASTFromDocument");
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getOperationASTFromRequest(request2) {
      return getOperationASTFromDocument(request2.document, request2.operationName);
    }, "getOperationASTFromRequest"));
  }
});

// node_modules/@graphql-tools/utils/cjs/directives.js
var require_directives2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GraphQLStreamDirective = exports2.GraphQLDeferDirective = void 0;
    var graphql_1 = require_graphql2();
    exports2.GraphQLDeferDirective = new graphql_1.GraphQLDirective({
      name: "defer",
      description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FRAGMENT_SPREAD, graphql_1.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Deferred when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        }
      }
    });
    exports2.GraphQLStreamDirective = new graphql_1.GraphQLDirective({
      name: "stream",
      description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FIELD],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Stream when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        },
        initialCount: {
          defaultValue: 0,
          type: graphql_1.GraphQLInt,
          description: "Number of items to return immediately"
        }
      }
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js
var require_AccumulatorMap = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccumulatorMap = void 0;
    var AccumulatorMap = class extends Map {
      static {
        __name(this, "AccumulatorMap");
      }
      get [Symbol.toStringTag]() {
        return "AccumulatorMap";
      }
      add(key, item) {
        const group3 = this.get(key);
        if (group3 === void 0) {
          this.set(key, [item]);
        } else {
          group3.push(item);
        }
      }
    };
    exports2.AccumulatorMap = AccumulatorMap;
  }
});

// node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.getDeferValues = exports2.getFieldEntryKey = exports2.doesFragmentConditionMatch = exports2.shouldIncludeNode = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize();
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives2();
    var AccumulatorMap_js_1 = require_AccumulatorMap();
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            fields.add(getFieldEntryKey(selection), selection);
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (visitedFragmentNames.has(fragName) && !defer) {
              continue;
            }
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            if (!defer) {
              visitedFragmentNames.add(fragName);
            }
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
        }
      }
    }
    __name(collectFieldsImpl, "collectFieldsImpl");
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = new AccumulatorMap_js_1.AccumulatorMap();
      const patches = [];
      collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
      return { fields, patches };
    }
    __name(collectFields, "collectFields");
    exports2.collectFields = collectFields;
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    __name(shouldIncludeNode, "shouldIncludeNode");
    exports2.shouldIncludeNode = shouldIncludeNode;
    function doesFragmentConditionMatch(schema, fragment, type2) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type2) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type2);
      }
      return false;
    }
    __name(doesFragmentConditionMatch, "doesFragmentConditionMatch");
    exports2.doesFragmentConditionMatch = doesFragmentConditionMatch;
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    __name(getFieldEntryKey, "getFieldEntryKey");
    exports2.getFieldEntryKey = getFieldEntryKey;
    function getDeferValues(variableValues, node) {
      const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);
      if (!defer) {
        return;
      }
      if (defer["if"] === false) {
        return;
      }
      return {
        label: typeof defer["label"] === "string" ? defer["label"] : void 0
      };
    }
    __name(getDeferValues, "getDeferValues");
    exports2.getDeferValues = getDeferValues;
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(/* @__PURE__ */ __name(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      const subPatches = [];
      const subFieldsAndPatches = {
        fields: subFieldNodes,
        patches: subPatches
      };
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
        }
      }
      return subFieldsAndPatches;
    }, "collectSubfields"));
  }
});

// node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest();
    var graphql_1 = require_graphql2();
    var collectFields_js_1 = require_collectFields2();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    __name(visitData, "visitData");
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error3) => visitor(error3));
    }
    __name(visitErrors, "visitErrors");
    exports2.visitErrors = visitErrors;
    function visitResult(result, request2, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request2.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request2.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request2);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    __name(visitResult, "visitResult");
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    __name(visitErrorsByType, "visitErrorsByType");
    function getOperationRootType(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    __name(getOperationRootType, "getOperationRootType");
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType(schema, operation);
      const { fields: collectedFields } = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet);
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    __name(visitRoot, "visitRoot");
    function visitObjectValue(object, type2, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type2.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type2.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error3 of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error3);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
            case "__type":
              fieldType = graphql_1.TypeMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type2, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error3 of errors2) {
            errorInfo.unpathedErrors.add(error3);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    __name(visitObjectValue, "visitObjectValue");
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    __name(updateObject, "updateObject");
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    __name(visitListValue, "visitListValue");
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    __name(visitFieldValue, "visitFieldValue");
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error3 of errors) {
        const pathSegment = (_a = error3.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error3);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error3);
        } else {
          errorMap[pathSegment] = [error3];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    __name(sortErrorsByPathSegment, "sortErrorsByPathSegment");
    function addPathSegmentInfo(type2, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error3 of errors) {
        const segmentInfo = {
          type: type2,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error3);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error3, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
    __name(addPathSegmentInfo, "addPathSegmentInfo");
  }
});

// node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    __name(valueMatchesCriteria, "valueMatchesCriteria");
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    __name(isAsyncIterable, "isAsyncIterable");
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = require_graphql2();
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    __name(isDocumentNode, "isDocumentNode");
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    __name(defaultAsyncIteratorReturn, "defaultAsyncIteratorReturn");
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(/* @__PURE__ */ __name(function proxyMethodFactory2(target, targetMethod) {
      return /* @__PURE__ */ __name(function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      }, "proxyMethod");
    }, "proxyMethodFactory"));
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return /* @__PURE__ */ __name(async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            }, "returnWithCancel");
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    __name(getAsyncIteratorWithCancel, "getAsyncIteratorWithCancel");
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return /* @__PURE__ */ __name(function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            }, "asyncIteratorFactory");
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    __name(getAsyncIterableWithCancel, "getAsyncIterableWithCancel");
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = require_graphql2();
    var print_schema_with_directives_js_1 = require_print_schema_with_directives();
    function buildFixedSchema(schema, options) {
      const document = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document, {
        ...options || {}
      });
    }
    __name(buildFixedSchema, "buildFixedSchema");
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    __name(fixSchemaAst, "fixSchemaAst");
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js
var require_extractExtensionsFromSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = void 0;
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: schema.extensions || {},
        types: {}
      };
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          result.types[type2.name] = { fields: {}, type: "object", extensions: type2.extensions || {} };
          return type2;
        },
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type2) => {
          result.types[type2.name] = { fields: {}, type: "interface", extensions: type2.extensions || {} };
          return type2;
        },
        [Interfaces_js_1.MapperKind.FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            arguments: {},
            extensions: field.extensions || {}
          };
          const args = field.args;
          if (args != null) {
            for (const argName in args) {
              result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
            }
          }
          return field;
        },
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => {
          result.types[type2.name] = { values: {}, type: "enum", extensions: type2.extensions || {} };
          return type2;
        },
        [Interfaces_js_1.MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
          result.types[typeName].values[valueName] = value.extensions || {};
          return value;
        },
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type2) => {
          result.types[type2.name] = { type: "scalar", extensions: type2.extensions || {} };
          return type2;
        },
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type2) => {
          result.types[type2.name] = { type: "union", extensions: type2.extensions || {} };
          return type2;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type2) => {
          result.types[type2.name] = { fields: {}, type: "input", extensions: type2.extensions || {} };
          return type2;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            extensions: field.extensions || {}
          };
          return field;
        }
      });
      return result;
    }
    __name(extractExtensionsFromSchema, "extractExtensionsFromSchema");
    exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// node_modules/@graphql-tools/utils/cjs/Path.js
var require_Path2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/Path.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printPathArray = exports2.pathToArray = exports2.addPath = void 0;
    function addPath(prev, key, typename) {
      return { prev, key, typename };
    }
    __name(addPath, "addPath");
    exports2.addPath = addPath;
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    __name(pathToArray, "pathToArray");
    exports2.pathToArray = pathToArray;
    function printPathArray(path) {
      return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
    }
    __name(printPathArray, "printPathArray");
    exports2.printPathArray = printPathArray;
  }
});

// node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_loaders(), exports2);
    tslib_1.__exportStar(require_helpers(), exports2);
    tslib_1.__exportStar(require_get_directives(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
    tslib_1.__exportStar(require_get_arguments_with_directives(), exports2);
    tslib_1.__exportStar(require_get_implementing_types(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
    tslib_1.__exportStar(require_validate_documents(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field(), exports2);
    tslib_1.__exportStar(require_types2(), exports2);
    tslib_1.__exportStar(require_filterSchema(), exports2);
    tslib_1.__exportStar(require_heal(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema(), exports2);
    tslib_1.__exportStar(require_forEachField(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue(), exports2);
    tslib_1.__exportStar(require_mapSchema(), exports2);
    tslib_1.__exportStar(require_addTypes(), exports2);
    tslib_1.__exportStar(require_rewire(), exports2);
    tslib_1.__exportStar(require_prune(), exports2);
    tslib_1.__exportStar(require_mergeDeep(), exports2);
    tslib_1.__exportStar(require_Interfaces(), exports2);
    tslib_1.__exportStar(require_stub(), exports2);
    tslib_1.__exportStar(require_selectionSets(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo(), exports2);
    tslib_1.__exportStar(require_fields(), exports2);
    tslib_1.__exportStar(require_renameType(), exports2);
    tslib_1.__exportStar(require_transformInputValue(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator2(), exports2);
    tslib_1.__exportStar(require_updateArgument(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType(), exports2);
    tslib_1.__exportStar(require_errors(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable(), exports2);
    tslib_1.__exportStar(require_visitResult(), exports2);
    tslib_1.__exportStar(require_getArgumentValues(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable2(), exports2);
    tslib_1.__exportStar(require_isDocumentNode(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped(), exports2);
    tslib_1.__exportStar(require_executor(), exports2);
    tslib_1.__exportStar(require_withCancel(), exports2);
    tslib_1.__exportStar(require_AggregateError(), exports2);
    tslib_1.__exportStar(require_rootTypes(), exports2);
    tslib_1.__exportStar(require_comments(), exports2);
    tslib_1.__exportStar(require_collectFields2(), exports2);
    tslib_1.__exportStar(require_inspect2(), exports2);
    tslib_1.__exportStar(require_memoize(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest(), exports2);
    tslib_1.__exportStar(require_extractExtensionsFromSchema(), exports2);
    tslib_1.__exportStar(require_Path2(), exports2);
    tslib_1.__exportStar(require_jsutils(), exports2);
    tslib_1.__exportStar(require_directives2(), exports2);
  }
});

// node_modules/@graphql-tools/mock/cjs/utils.js
var require_utils2 = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/utils.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRootType = exports2.copyOwnProps = exports2.copyOwnPropsIfNotPresent = exports2.isObject = exports2.makeRef = exports2.takeRandom = exports2.randomListLength = exports2.uuidv4 = void 0;
    var utils_1 = require_cjs();
    function uuidv4() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    __name(uuidv4, "uuidv4");
    exports2.uuidv4 = uuidv4;
    var randomListLength = /* @__PURE__ */ __name(() => {
      return 2;
    }, "randomListLength");
    exports2.randomListLength = randomListLength;
    var takeRandom = /* @__PURE__ */ __name((arr) => arr[Math.floor(Math.random() * arr.length)], "takeRandom");
    exports2.takeRandom = takeRandom;
    function makeRef(typeName, key) {
      return { $ref: { key, typeName } };
    }
    __name(makeRef, "makeRef");
    exports2.makeRef = makeRef;
    function isObject2(thing) {
      return thing === Object(thing) && !Array.isArray(thing);
    }
    __name(isObject2, "isObject");
    exports2.isObject = isObject2;
    function copyOwnPropsIfNotPresent(target, source) {
      for (const prop of Object.getOwnPropertyNames(source)) {
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
          const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
          Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
      }
    }
    __name(copyOwnPropsIfNotPresent, "copyOwnPropsIfNotPresent");
    exports2.copyOwnPropsIfNotPresent = copyOwnPropsIfNotPresent;
    function copyOwnProps(target, ...sources) {
      for (const source of sources) {
        let chain = source;
        while (chain != null) {
          copyOwnPropsIfNotPresent(target, chain);
          chain = Object.getPrototypeOf(chain);
        }
      }
      return target;
    }
    __name(copyOwnProps, "copyOwnProps");
    exports2.copyOwnProps = copyOwnProps;
    var isRootType = /* @__PURE__ */ __name((type2, schema) => {
      const rootTypeNames = (0, utils_1.getRootTypeNames)(schema);
      return rootTypeNames.has(type2.name);
    }, "isRootType");
    exports2.isRootType = isRootType;
  }
});

// node_modules/@graphql-tools/mock/cjs/MockList.js
var require_MockList = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/MockList.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepResolveMockList = exports2.MockList = exports2.isMockList = void 0;
    function isMockList(obj) {
      if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === "number" || Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === "number") {
        if (typeof obj.wrappedFunction === "undefined" || typeof obj.wrappedFunction === "function") {
          return true;
        }
      }
      return false;
    }
    __name(isMockList, "isMockList");
    exports2.isMockList = isMockList;
    var MockList = class {
      static {
        __name(this, "MockList");
      }
      /**
       * @param length Either the exact length of items to return or an inclusive
       * range of possible lengths.
       * @param mockFunction The function to call for each item in the list to
       * resolve it. It can return another MockList or a value.
       */
      constructor(length, mockFunction) {
        this.len = length;
        if (typeof mockFunction !== "undefined") {
          if (typeof mockFunction !== "function") {
            throw new Error("Second argument to MockList must be a function or undefined");
          }
          this.wrappedFunction = mockFunction;
        }
      }
      /**
       * @internal
       */
      mock() {
        let arr;
        if (Array.isArray(this.len)) {
          arr = new Array(this.randint(this.len[0], this.len[1]));
        } else {
          arr = new Array(this.len);
        }
        for (let i = 0; i < arr.length; i++) {
          if (typeof this.wrappedFunction === "function") {
            const res = this.wrappedFunction();
            if (isMockList(res)) {
              arr[i] = res.mock();
            } else {
              arr[i] = res;
            }
          } else {
            arr[i] = void 0;
          }
        }
        return arr;
      }
      randint(low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
      }
    };
    exports2.MockList = MockList;
    function deepResolveMockList(mockList) {
      return mockList.mock().map((v) => {
        if (isMockList(v))
          return deepResolveMockList(v);
        return v;
      });
    }
    __name(deepResolveMockList, "deepResolveMockList");
    exports2.deepResolveMockList = deepResolveMockList;
  }
});

// node_modules/@graphql-tools/mock/cjs/MockStore.js
var require_MockStore = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/MockStore.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMockStore = exports2.MockStore = exports2.defaultMocks = void 0;
    var tslib_1 = require_tslib();
    var graphql_1 = require_graphql2();
    var fast_json_stable_stringify_1 = tslib_1.__importDefault(require_fast_json_stable_stringify());
    var types_js_1 = require_types();
    var utils_js_1 = require_utils2();
    var MockList_js_1 = require_MockList();
    exports2.defaultMocks = {
      Int: /* @__PURE__ */ __name(() => Math.round(Math.random() * 200) - 100, "Int"),
      Float: /* @__PURE__ */ __name(() => Math.random() * 200 - 100, "Float"),
      String: /* @__PURE__ */ __name(() => "Hello World", "String"),
      Boolean: /* @__PURE__ */ __name(() => Math.random() > 0.5, "Boolean"),
      ID: /* @__PURE__ */ __name(() => (0, utils_js_1.uuidv4)(), "ID")
    };
    var defaultKeyFieldNames = ["id", "_id"];
    var MockStore = class {
      static {
        __name(this, "MockStore");
      }
      constructor({ schema, mocks, typePolicies }) {
        this.store = {};
        this.schema = schema;
        this.mocks = { ...exports2.defaultMocks, ...mocks };
        this.typePolicies = typePolicies || {};
      }
      has(typeName, key) {
        return !!this.store[typeName] && !!this.store[typeName][key];
      }
      get(_typeName, _key, _fieldName, _fieldArgs) {
        if (typeof _typeName !== "string") {
          if (_key === void 0) {
            if ((0, types_js_1.isRef)(_typeName)) {
              throw new Error("Can't provide a ref as first argument and no other argument");
            }
            return this.getImpl(_typeName);
          } else {
            (0, types_js_1.assertIsRef)(_typeName);
            const { $ref } = _typeName;
            _fieldArgs = _fieldName;
            _fieldName = _key;
            _key = $ref.key;
            _typeName = $ref.typeName;
          }
        }
        const args = {
          typeName: _typeName
        };
        if ((0, types_js_1.isRecord)(_key) || _key === void 0) {
          args.defaultValue = _key;
          return this.getImpl(args);
        }
        args.key = _key;
        if (Array.isArray(_fieldName) && _fieldName.length === 1) {
          _fieldName = _fieldName[0];
        }
        if (typeof _fieldName !== "string" && !Array.isArray(_fieldName)) {
          args.defaultValue = _fieldName;
          return this.getImpl(args);
        }
        if (Array.isArray(_fieldName)) {
          const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);
          (0, types_js_1.assertIsRef)(ref);
          return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));
        }
        args.fieldName = _fieldName;
        args.fieldArgs = _fieldArgs;
        return this.getImpl(args);
      }
      set(_typeName, _key, _fieldName, _value) {
        if (typeof _typeName !== "string") {
          if (_key === void 0) {
            if ((0, types_js_1.isRef)(_typeName)) {
              throw new Error("Can't provide a ref as first argument and no other argument");
            }
            return this.setImpl(_typeName);
          } else {
            (0, types_js_1.assertIsRef)(_typeName);
            const { $ref } = _typeName;
            _value = _fieldName;
            _fieldName = _key;
            _key = $ref.key;
            _typeName = $ref.typeName;
          }
        }
        assertIsDefined(_key, "key was not provided");
        const args = {
          typeName: _typeName,
          key: _key
        };
        if (typeof _fieldName !== "string") {
          if (!(0, types_js_1.isRecord)(_fieldName))
            throw new Error("Expected value to be a record");
          args.value = _fieldName;
          return this.setImpl(args);
        }
        args.fieldName = _fieldName;
        args.value = _value;
        return this.setImpl(args);
      }
      reset() {
        this.store = {};
      }
      filter(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).filter(predicate);
      }
      find(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).find(predicate);
      }
      getImpl(args) {
        const { typeName, key, fieldName, fieldArgs, defaultValue } = args;
        if (!fieldName) {
          if (defaultValue !== void 0 && !(0, types_js_1.isRecord)(defaultValue)) {
            throw new Error("`defaultValue` should be an object");
          }
          let valuesToInsert = defaultValue || {};
          if (key) {
            valuesToInsert = { ...valuesToInsert, ...(0, utils_js_1.makeRef)(typeName, key) };
          }
          return this.insert(typeName, valuesToInsert, true);
        }
        assertIsDefined(key, "key argument should be given when fieldName is given");
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.store[typeName] === void 0 || this.store[typeName][key] === void 0 || this.store[typeName][key][fieldNameInStore] === void 0) {
          let value;
          if (defaultValue !== void 0) {
            value = defaultValue;
          } else if (this.isKeyField(typeName, fieldName)) {
            value = key;
          } else {
            value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {
              if (this.isKeyField(typeName, otherFieldName))
                return;
              this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });
            });
          }
          this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });
        }
        return this.store[typeName][key][fieldNameInStore];
      }
      setImpl(args) {
        const { typeName, key, fieldName, fieldArgs, noOverride } = args;
        let { value } = args;
        if ((0, MockList_js_1.isMockList)(value)) {
          value = (0, MockList_js_1.deepResolveMockList)(value);
        }
        if (this.store[typeName] === void 0) {
          this.store[typeName] = {};
        }
        if (this.store[typeName][key] === void 0) {
          this.store[typeName][key] = {};
        }
        if (!fieldName) {
          if (!(0, types_js_1.isRecord)(value)) {
            throw new Error("When no `fieldName` is provided, `value` should be a record.");
          }
          for (const fieldName2 in value) {
            this.setImpl({
              typeName,
              key,
              fieldName: fieldName2,
              value: value[fieldName2],
              noOverride
            });
          }
          return;
        }
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.isKeyField(typeName, fieldName) && value !== key) {
          throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);
        }
        if (this.store[typeName][key][fieldNameInStore] !== void 0 && noOverride) {
          return;
        }
        const fieldType = this.getFieldType(typeName, fieldName);
        const currentValue = this.store[typeName][key][fieldNameInStore];
        let valueToStore;
        try {
          valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName2, values) => this.insert(typeName2, values, noOverride));
        } catch (e) {
          throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);
        }
        this.store[typeName][key] = {
          ...this.store[typeName][key],
          [fieldNameInStore]: valueToStore
        };
      }
      normalizeValueToStore(fieldType, value, currentValue, onInsertType) {
        const fieldTypeName = fieldType.toString();
        if (value === null) {
          if (!(0, graphql_1.isNullableType)(fieldType)) {
            throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);
          }
          return null;
        }
        const nullableFieldType = (0, graphql_1.getNullableType)(fieldType);
        if (value === void 0)
          return this.generateValueFromType(nullableFieldType);
        if ((0, graphql_1.isCompositeType)(nullableFieldType)) {
          if (!(0, types_js_1.isRecord)(value))
            throw new Error(`should be an object or null or undefined. Received ${value}`);
          let joinedTypeName;
          if ((0, graphql_1.isAbstractType)(nullableFieldType)) {
            if ((0, types_js_1.isRef)(value)) {
              joinedTypeName = value.$ref.typeName;
            } else {
              if (typeof value["__typename"] !== "string") {
                throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);
              }
              joinedTypeName = value["__typename"];
            }
          } else {
            joinedTypeName = nullableFieldType.name;
          }
          return onInsertType(joinedTypeName, (0, types_js_1.isRef)(currentValue) ? { ...currentValue, ...value } : value);
        }
        if ((0, graphql_1.isListType)(nullableFieldType)) {
          if (!Array.isArray(value))
            throw new Error(`should be an array or null or undefined. Received ${value}`);
          return value.map((v, index) => {
            return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === "object" && currentValue != null && currentValue[index] ? currentValue : void 0, onInsertType);
          });
        }
        return value;
      }
      insert(typeName, values, noOverride) {
        const keyFieldName = this.getKeyFieldName(typeName);
        let key;
        const otherValues = {};
        if ((0, types_js_1.isRef)(values)) {
          key = values.$ref.key;
        } else if (keyFieldName && keyFieldName in values) {
          key = values[keyFieldName];
        } else {
          key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {
            otherValues[otherFieldName] = otherFieldValue;
          });
        }
        const toInsert = { ...otherValues, ...values };
        for (const fieldName in toInsert) {
          if (fieldName === "$ref")
            continue;
          if (fieldName === "__typename")
            continue;
          this.set({
            typeName,
            key,
            fieldName,
            value: toInsert[fieldName],
            noOverride
          });
        }
        if (this.store[typeName] === void 0) {
          this.store[typeName] = {};
        }
        if (this.store[typeName][key] === void 0) {
          this.store[typeName][key] = {};
        }
        return (0, utils_js_1.makeRef)(typeName, key);
      }
      generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {
        const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);
        if (mockedValue !== void 0)
          return mockedValue;
        const fieldType = this.getFieldType(typeName, fieldName);
        return this.generateValueFromType(fieldType);
      }
      generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {
        let value;
        const mock = this.mocks ? this.mocks[typeName] : void 0;
        if (mock) {
          if (typeof mock === "function") {
            const values = mock();
            if (typeof values !== "object" || values == null) {
              throw new Error(`Value returned by the mock for ${typeName} is not an object`);
            }
            for (const otherFieldName in values) {
              if (otherFieldName === fieldName)
                continue;
              if (typeof values[otherFieldName] === "function")
                continue;
              onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);
            }
            value = values[fieldName];
            if (typeof value === "function")
              value = value();
          } else if (typeof mock === "object" && mock != null && typeof mock[fieldName] === "function") {
            value = mock[fieldName]();
          }
        }
        if (value !== void 0)
          return value;
        const type2 = this.getType(typeName);
        const interfaces = "getInterfaces" in type2 ? type2.getInterfaces() : [];
        if (interfaces.length > 0) {
          for (const interface_ of interfaces) {
            if (value)
              break;
            value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);
          }
        }
        return value;
      }
      generateKeyForType(typeName, onOtherFieldsGenerated) {
        const keyFieldName = this.getKeyFieldName(typeName);
        if (!keyFieldName)
          return (0, utils_js_1.uuidv4)();
        return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);
      }
      generateValueFromType(fieldType) {
        const nullableType = (0, graphql_1.getNullableType)(fieldType);
        if ((0, graphql_1.isScalarType)(nullableType)) {
          const mockFn = this.mocks[nullableType.name];
          if (typeof mockFn !== "function")
            throw new Error(`No mock defined for type "${nullableType.name}"`);
          return mockFn();
        } else if ((0, graphql_1.isEnumType)(nullableType)) {
          const mockFn = this.mocks[nullableType.name];
          if (typeof mockFn === "function")
            return mockFn();
          const values = nullableType.getValues().map((v) => v.value);
          return (0, utils_js_1.takeRandom)(values);
        } else if ((0, graphql_1.isObjectType)(nullableType)) {
          return this.insert(nullableType.name, {});
        } else if ((0, graphql_1.isListType)(nullableType)) {
          return [...new Array((0, utils_js_1.randomListLength)())].map(() => this.generateValueFromType(nullableType.ofType));
        } else if ((0, graphql_1.isAbstractType)(nullableType)) {
          const mock = this.mocks[nullableType.name];
          let typeName;
          let values = {};
          if (!mock) {
            typeName = (0, utils_js_1.takeRandom)(this.schema.getPossibleTypes(nullableType).map((t) => t.name));
          } else if (typeof mock === "function") {
            const mockRes = mock();
            if (mockRes === null)
              return null;
            if (!(0, types_js_1.isRecord)(mockRes)) {
              throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);
            }
            values = mockRes;
            if (typeof values["__typename"] !== "string") {
              throw new Error(`Please return a __typename in "${nullableType.name}"`);
            }
            typeName = values["__typename"];
          } else if (typeof mock === "object" && mock != null && typeof mock["__typename"] === "function") {
            const mockRes = mock["__typename"]();
            if (typeof mockRes !== "string")
              throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);
            typeName = mockRes;
          } else {
            throw new Error(`Please return a __typename in "${nullableType.name}"`);
          }
          const toInsert = {};
          for (const fieldName in values) {
            if (fieldName === "__typename")
              continue;
            const fieldValue = values[fieldName];
            toInsert[fieldName] = typeof fieldValue === "function" ? fieldValue() : fieldValue;
          }
          return this.insert(typeName, toInsert);
        } else {
          throw new Error(`${nullableType} not implemented`);
        }
      }
      getFieldType(typeName, fieldName) {
        if (fieldName === "__typename") {
          return graphql_1.GraphQLString;
        }
        const type2 = this.getType(typeName);
        const field = type2.getFields()[fieldName];
        if (!field) {
          throw new Error(`${fieldName} does not exist on type ${typeName}`);
        }
        return field.type;
      }
      getType(typeName) {
        const type2 = this.schema.getType(typeName);
        if (!type2 || !((0, graphql_1.isObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2))) {
          throw new Error(`${typeName} does not exist on schema or is not an object or interface`);
        }
        return type2;
      }
      isKeyField(typeName, fieldName) {
        return this.getKeyFieldName(typeName) === fieldName;
      }
      getKeyFieldName(typeName) {
        var _a;
        const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;
        if (typePolicyKeyField !== void 0) {
          if (typePolicyKeyField === false)
            return null;
          return typePolicyKeyField;
        }
        const gqlType = this.getType(typeName);
        for (const fieldName in gqlType.getFields()) {
          if (defaultKeyFieldNames.includes(fieldName)) {
            return fieldName;
          }
        }
        return null;
      }
    };
    exports2.MockStore = MockStore;
    var getFieldNameInStore = /* @__PURE__ */ __name((fieldName, fieldArgs) => {
      if (!fieldArgs)
        return fieldName;
      if (typeof fieldArgs === "string") {
        return `${fieldName}:${fieldArgs}`;
      }
      if (Object.keys(fieldArgs).length === 0) {
        return fieldName;
      }
      return `${fieldName}:${(0, fast_json_stable_stringify_1.default)(fieldArgs)}`;
    }, "getFieldNameInStore");
    function assertIsDefined(value, message) {
      if (value !== void 0 && value !== null) {
        return;
      }
      throw new Error(false ? "Invariant failed:" : `Invariant failed: ${message || ""}`);
    }
    __name(assertIsDefined, "assertIsDefined");
    function createMockStore(options) {
      return new MockStore(options);
    }
    __name(createMockStore, "createMockStore");
    exports2.createMockStore = createMockStore;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertResolversPresent = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    __name(assertResolversPresent, "assertResolversPresent");
    exports2.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
    __name(expectResolver, "expectResolver");
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.chainResolvers = void 0;
    var graphql_1 = require_graphql2();
    function chainResolvers(resolvers2) {
      return (root, args, ctx, info3) => resolvers2.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info3);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info3);
      }, root);
    }
    __name(chainResolvers, "chainResolvers");
    exports2.chainResolvers = chainResolvers;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type2) => {
          if (!type2.resolveType) {
            const message = `Type "${type2.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    __name(checkForResolveTypeResolver, "checkForResolveTypeResolver");
    exports2.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers2) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if ("getInterfaces" in type2) {
          extendedResolvers[typeName] = {};
          for (const iFace of type2.getInterfaces()) {
            if (resolvers2[iFace.name]) {
              for (const fieldName in resolvers2[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers2[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers2[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers2[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    __name(extendResolversFromInterfaces, "extendResolversFromInterfaces");
    exports2.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addResolversToSchema = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers2 = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers2) {
        const resolverValue = resolvers2[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type2 = schema.getType(typeName);
        if (type2 == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type2[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const values = type2.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but not present within ${type2.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type2)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but ${type2.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type2.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    __name(addResolversToSchema, "addResolversToSchema");
    exports2.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers2) {
        const type2 = schema.getType(typeName);
        const resolverValue = resolvers2[typeName];
        if ((0, graphql_1.isScalarType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type2.astNode != null) {
              type2.astNode = {
                ...type2.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.astNode.description,
                directives: ((_c = type2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type2.extensionASTNodes != null) {
              type2.extensionASTNodes = type2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
              type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
            } else {
              type2[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const config2 = type2.toConfig();
          const enumValueConfigMap = config2.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config2[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config2.astNode != null) {
              config2.astNode = {
                ...config2.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config2.astNode.description,
                directives: ((_j = config2.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
              config2.extensionASTNodes = config2.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
              type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config2);
        } else if ((0, graphql_1.isUnionType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type2.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver;
          }
        });
      }
      return schema;
    }
    __name(addResolversToExistingSchema, "addResolversToExistingSchema");
    function createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type2) => {
          var _a, _b, _c, _d, _e, _f;
          const config2 = type2.toConfig();
          const resolverValue = resolvers2[type2.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type2) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config2[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config2.astNode != null) {
                config2.astNode = {
                  ...config2.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
                  directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
                config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
                config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
              } else {
                config2[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config2);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type2) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers2[type2.name];
          const config2 = type2.toConfig();
          const enumValueConfigMap = config2.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config2[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config2.astNode != null) {
                config2.astNode = {
                  ...config2.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
                  directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
                config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
                config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config2);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type2) => {
          const resolverValue = resolvers2[type2.name];
          if (resolverValue != null) {
            const config2 = type2.toConfig();
            if (resolverValue["__resolveType"]) {
              config2.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config2);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type2) => {
          const resolverValue = resolvers2[type2.name];
          if (resolverValue != null) {
            const config2 = type2.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config2.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config2);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type2) => {
          const resolverValue = resolvers2[type2.name];
          if (resolverValue != null) {
            const config2 = type2.toConfig();
            if (resolverValue["__resolveType"]) {
              config2.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config2);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers2[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
          })
        });
      }
      return schema;
    }
    __name(createNewSchemaWithResolvers, "createNewSchemaWithResolvers");
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
    __name(setFieldProperties, "setFieldProperties");
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeResolvers = void 0;
    var utils_1 = require_cjs();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers2 = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers2.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers2, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    __name(mergeResolvers, "mergeResolvers");
    exports2.mergeResolvers = mergeResolvers;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeArguments = void 0;
    var utils_1 = require_cjs();
    function mergeArguments(args1, args2, config2) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome), config2);
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    __name(mergeArguments, "mergeArguments");
    exports2.mergeArguments = mergeArguments;
    function deduplicateArguments(args, config2) {
      return args.reduce((acc, current) => {
        const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
        if (dupIndex === -1) {
          return acc.concat([current]);
        } else if (!(config2 === null || config2 === void 0 ? void 0 : config2.reverseArguments)) {
          acc[dupIndex] = current;
        }
        return acc;
      }, []);
    }
    __name(deduplicateArguments, "deduplicateArguments");
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDirective = exports2.mergeDirectives = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    __name(directiveAlreadyExists, "directiveAlreadyExists");
    function isRepeatableDirective(directive, directives) {
      var _a;
      return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);
    }
    __name(isRepeatableDirective, "isRepeatableDirective");
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    __name(nameAlreadyExists, "nameAlreadyExists");
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    __name(mergeArguments, "mergeArguments");
    function deduplicateDirectives(directives, definitions) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    __name(deduplicateDirectives, "deduplicateDirectives");
    function mergeDirectives(d1 = [], d2 = [], config2, directives) {
      const reverseOrder = config2 && config2.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext], directives);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    __name(mergeDirectives, "mergeDirectives");
    exports2.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    __name(validateInputs, "validateInputs");
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    __name(mergeDirective, "mergeDirective");
    exports2.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
    __name(deduplicateLists, "deduplicateLists");
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnumValues = void 0;
    var directives_js_1 = require_directives3();
    var utils_1 = require_cjs();
    function mergeEnumValues(first, second, config2, directives) {
      if (config2 === null || config2 === void 0 ? void 0 : config2.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives, directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    __name(mergeEnumValues, "mergeEnumValues");
    exports2.mergeEnumValues = mergeEnumValues;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnum = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives3();
    var enum_values_js_1 = require_enum_values();
    function mergeEnum(e1, e2, config2, directives) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config2, directives),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    __name(mergeEnum, "mergeEnum");
    exports2.mergeEnum = mergeEnum;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
    var graphql_1 = require_graphql2();
    function isStringTypes(types3) {
      return typeof types3 === "string";
    }
    __name(isStringTypes, "isStringTypes");
    exports2.isStringTypes = isStringTypes;
    function isSourceTypes(types3) {
      return types3 instanceof graphql_1.Source;
    }
    __name(isSourceTypes, "isSourceTypes");
    exports2.isSourceTypes = isSourceTypes;
    function extractType(type2) {
      let visitedType = type2;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    __name(extractType, "extractType");
    exports2.extractType = extractType;
    function isWrappingTypeNode(type2) {
      return type2.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    __name(isWrappingTypeNode, "isWrappingTypeNode");
    exports2.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type2) {
      return type2.kind === graphql_1.Kind.LIST_TYPE;
    }
    __name(isListTypeNode, "isListTypeNode");
    exports2.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type2) {
      return type2.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    __name(isNonNullTypeNode, "isNonNullTypeNode");
    exports2.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type2) {
      if (isListTypeNode(type2)) {
        return `[${printTypeNode(type2.type)}]`;
      }
      if (isNonNullTypeNode(type2)) {
        return `${printTypeNode(type2.type)}!`;
      }
      return type2.name.value;
    }
    __name(printTypeNode, "printTypeNode");
    exports2.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    __name(defaultStringComparator, "defaultStringComparator");
    exports2.defaultStringComparator = defaultStringComparator;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields2 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeFields = void 0;
    var utils_js_1 = require_utils3();
    var directives_js_1 = require_directives3();
    var utils_1 = require_cjs();
    var arguments_js_1 = require_arguments();
    function fieldAlreadyExists(fieldsArr, otherField) {
      const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
      return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
    }
    __name(fieldAlreadyExists, "fieldAlreadyExists");
    function mergeFields(type2, f1, f2, config2, directives) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          const [existing, existingIndex] = fieldAlreadyExists(result, field);
          if (existing && !(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
            const newField = (config2 === null || config2 === void 0 ? void 0 : config2.onFieldTypeConflict) && config2.onFieldTypeConflict(existing, field, type2, config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict) || preventConflicts(type2, existing, field, config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict);
            newField.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing["arguments"] || [], config2);
            newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config2, directives);
            newField.description = field.description || existing.description;
            result[existingIndex] = newField;
          } else {
            result.push(field);
          }
        }
      }
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config2 && config2.exclusions) {
        const exclusions = config2.exclusions;
        return result.filter((field) => !exclusions.includes(`${type2.name.value}.${field.name.value}`));
      }
      return result;
    }
    __name(mergeFields, "mergeFields");
    exports2.mergeFields = mergeFields;
    function preventConflicts(type2, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType) {
        const t1 = (0, utils_js_1.extractType)(a.type);
        const t2 = (0, utils_js_1.extractType)(b.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
          throw new Error(`Field '${type2.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
        }
      }
      if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a.type)) {
        a.type = b.type;
      }
      return a;
    }
    __name(preventConflicts, "preventConflicts");
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
    __name(safeChangeForFieldType, "safeChangeForFieldType");
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInputType = void 0;
    var graphql_1 = require_graphql2();
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives3();
    function mergeInputType(node, existingNode, config2, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    __name(mergeInputType, "mergeInputType");
    exports2.mergeInputType = mergeInputType;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    __name(alreadyExists, "alreadyExists");
    function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    __name(mergeNamedTypeArray, "mergeNamedTypeArray");
    exports2.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInterface = void 0;
    var graphql_1 = require_graphql2();
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeInterface(node, existingNode, config2, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives),
            interfaces: node["interfaces"] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config2) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    __name(mergeInterface, "mergeInterface");
    exports2.mergeInterface = mergeInterface;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type2 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeType = void 0;
    var graphql_1 = require_graphql2();
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeType(node, existingNode, config2, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config2)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    __name(mergeType, "mergeType");
    exports2.mergeType = mergeType;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScalar = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives3();
    function mergeScalar(node, existingNode, config2, directives) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    __name(mergeScalar, "mergeScalar");
    exports2.mergeScalar = mergeScalar;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeUnion = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeUnion(first, second, config2, directives) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config2, directives),
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    __name(mergeUnion, "mergeUnion");
    exports2.mergeUnion = mergeUnion;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives3();
    exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    __name(mergeOperationTypes, "mergeOperationTypes");
    function mergeSchemaDefs(node, existingNode, config2, directives) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    __name(mergeSchemaDefs, "mergeSchemaDefs");
    exports2.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
    var graphql_1 = require_graphql2();
    var type_js_1 = require_type2();
    var enum_js_1 = require_enum();
    var scalar_js_1 = require_scalar();
    var union_js_1 = require_union();
    var input_type_js_1 = require_input_type();
    var interface_js_1 = require_interface();
    var directives_js_1 = require_directives3();
    var schema_def_js_1 = require_schema_def();
    var utils_1 = require_cjs();
    exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    __name(isNamedDefinitionNode, "isNamedDefinitionNode");
    exports2.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config2, directives = {}) {
      var _a, _b, _c;
      const mergedResultMap = directives;
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config2, directives);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config2, directives);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config2, directives);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config2, directives);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config2, directives);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config2, directives);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config2);
        }
      }
      return mergedResultMap;
    }
    __name(mergeGraphQLNodes, "mergeGraphQLNodes");
    exports2.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
    var graphql_1 = require_graphql2();
    var utils_js_1 = require_utils3();
    var merge_nodes_js_1 = require_merge_nodes();
    var utils_1 = require_cjs();
    var schema_def_js_1 = require_schema_def();
    function mergeTypeDefs(typeSource, config2) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config2
        })
      };
      let result;
      if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    __name(mergeTypeDefs, "mergeTypeDefs");
    exports2.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type2 of typeSource) {
            visitTypeSources(type2, options, allDirectives, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
            allDirectives.push(typeSource);
          } else {
            allNodes.push(typeSource);
          }
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return { allDirectives, allNodes };
    }
    __name(visitTypeSources, "visitTypeSources");
    function mergeGraphQLTypes(typeSource, config2) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const { allDirectives, allNodes } = visitTypeSources(typeSource, config2);
      const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config2);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config2, mergedDirectives);
      if (config2 === null || config2 === void 0 ? void 0 : config2.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config2 === null || config2 === void 0 ? void 0 : config2.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config2 === null || config2 === void 0 ? void 0 : config2.sort) {
        const sortFn = typeof config2.sort === "function" ? config2.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    __name(mergeGraphQLTypes, "mergeGraphQLTypes");
    exports2.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_arguments(), exports2);
    tslib_1.__exportStar(require_directives3(), exports2);
    tslib_1.__exportStar(require_enum_values(), exports2);
    tslib_1.__exportStar(require_enum(), exports2);
    tslib_1.__exportStar(require_fields2(), exports2);
    tslib_1.__exportStar(require_input_type(), exports2);
    tslib_1.__exportStar(require_interface(), exports2);
    tslib_1.__exportStar(require_merge_named_type_array(), exports2);
    tslib_1.__exportStar(require_merge_nodes(), exports2);
    tslib_1.__exportStar(require_merge_typedefs(), exports2);
    tslib_1.__exportStar(require_scalar(), exports2);
    tslib_1.__exportStar(require_type2(), exports2);
    tslib_1.__exportStar(require_union(), exports2);
    tslib_1.__exportStar(require_utils3(), exports2);
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyExtensions = exports2.mergeExtensions = exports2.extractExtensionsFromSchema = void 0;
    var utils_1 = require_cjs();
    var utils_2 = require_cjs();
    Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_2.extractExtensionsFromSchema;
    }, "get") });
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    __name(mergeExtensions, "mergeExtensions");
    exports2.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    __name(applyExtensionObject, "applyExtensionObject");
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type2 = schema.getType(typeName);
        if (type2) {
          applyExtensionObject(type2, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type2.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type2.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type2.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    __name(applyExtensions, "applyExtensions");
    exports2.applyExtensions = applyExtensions;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_merge_resolvers(), exports2);
    tslib_1.__exportStar(require_typedefs_mergers(), exports2);
    tslib_1.__exportStar(require_extensions(), exports2);
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeExecutableSchema = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs();
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    var merge_1 = require_cjs2();
    function makeExecutableSchema({ typeDefs: typeDefs2, resolvers: resolvers2 = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs2) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs2)) {
        schema = typeDefs2;
      } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs2, {
          ...otherOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs2, otherOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers2),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    __name(makeExecutableSchema, "makeExecutableSchema");
    exports2.makeExecutableSchema = makeExecutableSchema;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js
var require_types3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemas = void 0;
    var utils_1 = require_cjs();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema();
    function mergeSchemas(config2) {
      const extractedTypeDefs = [];
      const extractedResolvers = [];
      const extractedSchemaExtensions = [];
      if (config2.schemas != null) {
        for (const schema of config2.schemas) {
          extractedTypeDefs.push(schema);
          extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));
          extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));
        }
      }
      if (config2.typeDefs != null) {
        extractedTypeDefs.push(config2.typeDefs);
      }
      if (config2.resolvers != null) {
        const additionalResolvers = (0, utils_1.asArray)(config2.resolvers);
        extractedResolvers.push(...additionalResolvers);
      }
      if (config2.schemaExtensions != null) {
        const additionalSchemaExtensions = (0, utils_1.asArray)(config2.schemaExtensions);
        extractedSchemaExtensions.push(...additionalSchemaExtensions);
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        ...config2,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    __name(mergeSchemas, "mergeSchemas");
    exports2.mergeSchemas = mergeSchemas;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = exports2.extendResolversFromInterfaces = exports2.checkForResolveTypeResolver = exports2.addResolversToSchema = exports2.chainResolvers = exports2.assertResolversPresent = void 0;
    var tslib_1 = require_tslib();
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    Object.defineProperty(exports2, "assertResolversPresent", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    }, "get") });
    var chainResolvers_js_1 = require_chainResolvers();
    Object.defineProperty(exports2, "chainResolvers", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return chainResolvers_js_1.chainResolvers;
    }, "get") });
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    Object.defineProperty(exports2, "addResolversToSchema", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    }, "get") });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    Object.defineProperty(exports2, "checkForResolveTypeResolver", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    }, "get") });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    Object.defineProperty(exports2, "extendResolversFromInterfaces", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    }, "get") });
    tslib_1.__exportStar(require_makeExecutableSchema(), exports2);
    tslib_1.__exportStar(require_types3(), exports2);
    tslib_1.__exportStar(require_merge_schemas(), exports2);
    var utils_1 = require_cjs();
    Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_1.extractExtensionsFromSchema;
    }, "get") });
  }
});

// node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js
var require_addMocksToSchema = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addMocksToSchema = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs();
    var schema_1 = require_cjs3();
    var types_js_1 = require_types();
    var utils_js_1 = require_utils2();
    var MockStore_js_1 = require_MockStore();
    function addMocksToSchema({ schema, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false }) {
      if (!schema) {
        throw new Error("Must provide schema to mock");
      }
      if (!(0, graphql_1.isSchema)(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
      }
      if (mocks && !(0, utils_js_1.isObject)(mocks)) {
        throw new Error("mocks must be of type Object");
      }
      const store = maybeStore || (0, MockStore_js_1.createMockStore)({
        schema,
        mocks,
        typePolicies
      });
      const resolvers2 = typeof resolversOrFnResolvers === "function" ? resolversOrFnResolvers(store) : resolversOrFnResolvers;
      const mockResolver = /* @__PURE__ */ __name((source, args, contex, info3) => {
        const defaultResolvedValue = (0, graphql_1.defaultFieldResolver)(source, args, contex, info3);
        if (defaultResolvedValue !== void 0)
          return defaultResolvedValue;
        if ((0, types_js_1.isRef)(source)) {
          return store.get({
            typeName: source.$ref.typeName,
            key: source.$ref.key,
            fieldName: info3.fieldName,
            fieldArgs: args
          });
        }
        if ((0, utils_js_1.isRootType)(info3.parentType, info3.schema)) {
          return store.get({
            typeName: info3.parentType.name,
            key: "ROOT",
            fieldName: info3.fieldName,
            fieldArgs: args
          });
        }
        if (defaultResolvedValue === void 0) {
          return store.generateFieldValue(info3.parentType.name, info3.fieldName);
        }
        return void 0;
      }, "mockResolver");
      const typeResolver = /* @__PURE__ */ __name((data) => {
        if ((0, types_js_1.isRef)(data)) {
          return data.$ref.typeName;
        }
      }, "typeResolver");
      const mockSubscriber = /* @__PURE__ */ __name(() => ({
        [Symbol.asyncIterator]() {
          return {
            async next() {
              return {
                done: true,
                value: {}
              };
            }
          };
        }
      }), "mockSubscriber");
      const schemaWithMocks = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => {
          const newFieldConfig = {
            ...fieldConfig
          };
          const oldResolver = fieldConfig.resolve;
          if (!preserveResolvers || !oldResolver) {
            newFieldConfig.resolve = mockResolver;
          } else {
            newFieldConfig.resolve = async (rootObject, args, context2, info3) => {
              const [mockedValue, resolvedValue] = await Promise.all([
                mockResolver(rootObject, args, context2, info3),
                oldResolver(rootObject, args, context2, info3)
              ]);
              if (mockedValue instanceof Error) {
                if (void 0 === resolvedValue) {
                  throw mockedValue;
                }
                return resolvedValue;
              }
              if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                return void 0 !== resolvedValue ? resolvedValue : mockedValue;
              }
              if ((0, utils_js_1.isObject)(mockedValue) && (0, utils_js_1.isObject)(resolvedValue)) {
                const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                return (0, utils_js_1.copyOwnProps)(emptyObject, resolvedValue, mockedValue);
              }
              return void 0 !== resolvedValue ? resolvedValue : mockedValue;
            };
          }
          const fieldSubscriber = fieldConfig.subscribe;
          if (!preserveResolvers || !fieldSubscriber) {
            newFieldConfig.subscribe = mockSubscriber;
          } else {
            newFieldConfig.subscribe = async (rootObject, args, context2, info3) => {
              const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([
                mockSubscriber(rootObject, args, context2, info3),
                fieldSubscriber(rootObject, args, context2, info3)
              ]);
              return oldAsyncIterable || mockAsyncIterable;
            };
          }
          return newFieldConfig;
        },
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type2) => {
          if (preserveResolvers && type2.resolveType != null && type2.resolveType.length) {
            return;
          }
          if ((0, graphql_1.isUnionType)(type2)) {
            return new graphql_1.GraphQLUnionType({
              ...type2.toConfig(),
              resolveType: typeResolver
            });
          } else {
            return new graphql_1.GraphQLInterfaceType({
              ...type2.toConfig(),
              resolveType: typeResolver
            });
          }
        }
      });
      return resolvers2 ? (0, schema_1.addResolversToSchema)({
        schema: schemaWithMocks,
        resolvers: resolvers2
      }) : schemaWithMocks;
    }
    __name(addMocksToSchema, "addMocksToSchema");
    exports2.addMocksToSchema = addMocksToSchema;
  }
});

// node_modules/@graphql-tools/mock/cjs/mockServer.js
var require_mockServer = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/mockServer.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mockServer = void 0;
    var graphql_1 = require_graphql2();
    var schema_1 = require_cjs3();
    var addMocksToSchema_js_1 = require_addMocksToSchema();
    function mockServer(schema, mocks, preserveResolvers = false) {
      const mockedSchema = (0, addMocksToSchema_js_1.addMocksToSchema)({
        schema: (0, graphql_1.isSchema)(schema) ? schema : (0, schema_1.makeExecutableSchema)({
          typeDefs: schema
        }),
        mocks,
        preserveResolvers
      });
      return {
        query: /* @__PURE__ */ __name((query, vars) => (0, graphql_1.graphql)({
          schema: mockedSchema,
          source: query,
          rootValue: {},
          contextValue: {},
          variableValues: vars
        }), "query")
      };
    }
    __name(mockServer, "mockServer");
    exports2.mockServer = mockServer;
  }
});

// node_modules/@graphql-tools/mock/cjs/pagination.js
var require_pagination = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/pagination.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relayStylePaginationMock = void 0;
    var utils_js_1 = require_utils2();
    var relayStylePaginationMock = /* @__PURE__ */ __name((store, { cursorFn = /* @__PURE__ */ __name((node) => `${node.$ref.key}`, "cursorFn"), applyOnNodes, allNodesFn } = {}) => {
      return (parent, args, context2, info3) => {
        const source = (0, utils_js_1.isRootType)(info3.parentType, info3.schema) ? (0, utils_js_1.makeRef)(info3.parentType.name, "ROOT") : parent;
        const allNodesFn_ = allNodesFn !== null && allNodesFn !== void 0 ? allNodesFn : defaultAllNodesFn(store);
        let allNodes = allNodesFn_(source, args, context2, info3);
        if (applyOnNodes) {
          allNodes = applyOnNodes(allNodes, args);
        }
        const allEdges = allNodes.map((node) => ({
          node,
          cursor: cursorFn(node)
        }));
        let start, end;
        const { first, after, last, before } = args;
        if (typeof first === "number") {
          if (last || before) {
            throw new Error("if `first` is provided, `last` or `before` can't be provided");
          }
          const afterIndex = after ? allEdges.findIndex((e) => e.cursor === after) : -1;
          start = afterIndex + 1;
          end = afterIndex + 1 + first;
        } else if (typeof last === "number") {
          if (first || after) {
            throw new Error("if `last` is provided, `first` or `after` can't be provided");
          }
          const foundBeforeIndex = before ? allEdges.findIndex((e) => e.cursor === before) : -1;
          const beforeIndex = foundBeforeIndex !== -1 ? foundBeforeIndex : allNodes.length;
          start = allEdges.length - (allEdges.length - beforeIndex) - last;
          if (start < 0)
            start = 0;
          end = beforeIndex;
        } else {
          throw new Error("A `first` or a `last` arguments should be provided");
        }
        const edges = allEdges.slice(start, end);
        const pageInfo = {
          startCursor: edges.length > 0 ? edges[0].cursor : "",
          endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : "",
          hasNextPage: end < allEdges.length - 1,
          hasPreviousPage: start > 0
        };
        return {
          edges,
          pageInfo,
          totalCount: allEdges.length
        };
      };
    }, "relayStylePaginationMock");
    exports2.relayStylePaginationMock = relayStylePaginationMock;
    var defaultAllNodesFn = /* @__PURE__ */ __name((store) => (parent, _, __, info3) => store.get(parent, [info3.fieldName, "edges"]).map((e) => store.get(e, "node")), "defaultAllNodesFn");
  }
});

// node_modules/@graphql-tools/mock/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_MockStore(), exports2);
    tslib_1.__exportStar(require_addMocksToSchema(), exports2);
    tslib_1.__exportStar(require_mockServer(), exports2);
    tslib_1.__exportStar(require_types(), exports2);
    tslib_1.__exportStar(require_MockList(), exports2);
    tslib_1.__exportStar(require_pagination(), exports2);
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = require_graphql2();
    var asArray = /* @__PURE__ */ __name((fns) => Array.isArray(fns) ? fns : fns ? [fns] : [], "asArray");
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isDocumentString, "isDocumentString");
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    __name(isValidPath, "isValidPath");
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    __name(compareStrings, "compareStrings");
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    __name(nodeToString, "nodeToString");
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    __name(compareNodes, "compareNodes");
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    __name(isSome, "isSome");
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    __name(assertSome, "assertSome");
    exports2.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = require_graphql2();
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    __name(createGraphQLError, "createGraphQLError");
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    __name(relocatedError, "relocatedError");
    exports2.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        static {
          __name(this, "AggregateErrorClass");
        }
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = /* @__PURE__ */ __name(function(errors, message) {
        return new AggregateErrorClass(errors, message);
      }, "AggregateErrorImpl");
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error3) {
      return "errors" in error3 && Array.isArray(error3["errors"]);
    }
    __name(isAggregateError, "isAggregateError");
    exports2.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect3 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = require_graphql2();
    var AggregateError_js_1 = require_AggregateError2();
    var MAX_RECURSIVE_DEPTH = 3;
    function inspect2(value) {
      return formatValue(value, []);
    }
    __name(inspect2, "inspect");
    exports2.inspect = inspect2;
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    __name(formatValue, "formatValue");
    function formatError(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    __name(formatError, "formatError");
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    __name(formatObjectValue, "formatObjectValue");
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    __name(isJSONable, "isJSONable");
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    __name(formatObject, "formatObject");
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = array.length;
      const remaining = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    __name(formatArray, "formatArray");
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
    __name(getObjectTag, "getObjectTag");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var graphql_1 = require_graphql2();
    var errors_js_1 = require_errors2();
    var inspect_js_1 = require_inspect3();
    function getArgumentValues(def, node, variableValues = {}) {
      var _a;
      const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
        ...prev,
        [key]: value
      }), {});
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || variableMap[variableName] == null) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    __name(getArgumentValues, "getArgumentValues");
    exports2.getArgumentValues = getArgumentValues;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues2();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    __name(getDirectivesInExtensions, "getDirectivesInExtensions");
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    __name(_getDirectiveInExtensions, "_getDirectiveInExtensions");
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    __name(getDirectiveInExtensions, "getDirectiveInExtensions");
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    __name(getDirectives, "getDirectives");
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    __name(getDirective, "getDirective");
    exports2.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = require_graphql2();
    function parseDirectiveValue(value) {
      switch (value.kind) {
        case graphql_1.Kind.INT:
          return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
          return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
          return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
          return value.value;
        case graphql_1.Kind.LIST:
          return value.values.map((v) => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
          return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
          return null;
        default:
          return null;
      }
    }
    __name(parseDirectiveValue, "parseDirectiveValue");
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type2 of allTypes) {
        const typeName = type2.name.value;
        if (type2.fields == null) {
          continue;
        }
        for (const field of type2.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    __name(getFieldsWithDirectives, "getFieldsWithDirectives");
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = require_graphql2();
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    __name(getImplementingTypes, "getImplementingTypes");
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = require_graphql2();
    var inspect_js_1 = require_inspect3();
    function astFromType(type2) {
      if ((0, graphql_1.isNonNullType)(type2)) {
        const innerType = astFromType(type2.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type2)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type2)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type2.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        }
      };
    }
    __name(astFromType, "astFromType");
    exports2.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = require_graphql2();
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    __name(astFromValueUntyped, "astFromValueUntyped");
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize1, "memoize1");
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2, "memoize2");
    exports2.memoize2 = memoize2;
    function memoize3(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize3, "memoize3");
    exports2.memoize3 = memoize3;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize4, "memoize4");
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize5, "memoize5");
    exports2.memoize5 = memoize5;
    var memoize2of4cache = /* @__PURE__ */ new WeakMap();
    function memoize2of4(fn) {
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2of4, "memoize2of4");
    exports2.memoize2of4 = memoize2of4;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var memoize_js_1 = require_memoize2();
    function getDefinedRootType(schema, operation) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
      }
      return rootType;
    }
    __name(getDefinedRootType, "getDefinedRootType");
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type2) => type2.name));
    }, "getRootTypeNames"));
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    }, "getRootTypes"));
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    }, "getRootTypeMap"));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = require_graphql2();
    var astFromType_js_1 = require_astFromType2();
    var get_directives_js_1 = require_get_directives2();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped2();
    var helpers_js_1 = require_helpers2();
    var rootTypes_js_1 = require_rootTypes2();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type2 = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type2);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type2);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type2)) {
          definitions.push(astFromObjectType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          definitions.push(astFromInterfaceType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type2)) {
          definitions.push(astFromUnionType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          definitions.push(astFromInputObjectType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type2)) {
          definitions.push(astFromEnumType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type2)) {
          definitions.push(astFromScalarType(type2, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type2}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    __name(getDocumentNodeFromSchema, "getDocumentNodeFromSchema");
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    __name(printSchemaWithDirectives, "printSchemaWithDirectives");
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    __name(astFromSchema, "astFromSchema");
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    __name(astFromDirective, "astFromDirective");
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    __name(getDirectiveNodes, "getDirectiveNodes");
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    __name(getDeprecatableDirectiveNodes, "getDeprecatableDirectiveNodes");
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromArg, "astFromArg");
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type2.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromObjectType, "astFromObjectType");
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type2) {
        node.interfaces = Object.values(type2.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    __name(astFromInterfaceType, "astFromInterfaceType");
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions),
        types: type2.getTypes().map((type3) => (0, astFromType_js_1.astFromType)(type3))
      };
    }
    __name(astFromUnionType, "astFromUnionType");
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromInputObjectType, "astFromInputObjectType");
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        values: Object.values(type2.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromEnumType, "astFromEnumType");
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type2, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type2["specifiedByUrl"] || type2["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    __name(astFromScalarType, "astFromScalarType");
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromField, "astFromField");
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    __name(astFromInputField, "astFromInputField");
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromEnumValue, "astFromEnumValue");
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    __name(makeDeprecatedDirective, "makeDeprecatedDirective");
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    __name(makeDirectiveNode, "makeDirectiveNode");
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    __name(makeDirectiveNodes, "makeDirectiveNodes");
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.checkValidationErrors = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = require_graphql2();
    var AggregateError_js_1 = require_AggregateError2();
    async function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {
      const allFragmentMap = /* @__PURE__ */ new Map();
      const documentFileObjectsToValidate = [];
      for (const documentFile of documentFiles) {
        if (documentFile.document) {
          const definitionsToValidate = [];
          for (const definitionNode of documentFile.document.definitions) {
            if (definitionNode.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
              allFragmentMap.set(definitionNode.name.value, definitionNode);
            } else {
              definitionsToValidate.push(definitionNode);
            }
          }
          documentFileObjectsToValidate.push({
            location: documentFile.location,
            document: {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: definitionsToValidate
            }
          });
        }
      }
      const allErrors = [];
      const allFragmentsDocument = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...allFragmentMap.values()]
      };
      await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
        const documentToValidate = (0, graphql_1.concatAST)([allFragmentsDocument, documentFile.document]);
        const errors = (0, graphql_1.validate)(schema, documentToValidate, effectiveRules);
        if (errors.length > 0) {
          allErrors.push({
            filePath: documentFile.location,
            errors
          });
        }
      }));
      return allErrors;
    }
    __name(validateGraphQlDocuments, "validateGraphQlDocuments");
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function checkValidationErrors(loadDocumentErrors) {
      if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
          for (const graphQLError of loadDocumentError.errors) {
            const error3 = new Error();
            error3.name = "GraphQLDocumentError";
            error3.message = `${error3.name}: ${graphQLError.message}`;
            error3.stack = error3.message;
            if (graphQLError.locations) {
              for (const location of graphQLError.locations) {
                error3.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
              }
            }
            errors.push(error3);
          }
        }
        throw new AggregateError_js_1.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error3, index) => `Error ${index}: ${error3.stack}`).join("\n\n")}`);
      }
    }
    __name(checkValidationErrors, "checkValidationErrors");
    exports2.checkValidationErrors = checkValidationErrors;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    __name(createDefaultRules, "createDefaultRules");
    exports2.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = require_graphql2();
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    __name(stripBOM, "stripBOM");
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    __name(parseBOM, "parseBOM");
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    __name(parseGraphQLJSON, "parseGraphQLJSON");
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = require_graphql2();
    var MAX_LINE_LENGTH = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    __name(resetComments, "resetComments");
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    __name(collectComment, "collectComment");
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    __name(pushComment, "pushComment");
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    __name(printComment, "printComment");
    exports2.printComment = printComment;
    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    __name(join, "join");
    function hasMultilineItems(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    __name(hasMultilineItems, "hasMultilineItems");
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    __name(addDescription, "addDescription");
    function indent(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    __name(indent, "indent");
    function block(array) {
      return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
    }
    __name(block, "block");
    function wrap(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    __name(wrap, "wrap");
    function printBlockString(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
    }
    __name(printBlockString, "printBlockString");
    var printDocASTReducer = {
      Name: { leave: /* @__PURE__ */ __name((node) => node.value, "leave") },
      Variable: { leave: /* @__PURE__ */ __name((node) => "$" + node.name, "leave") },
      // Document
      Document: {
        leave: /* @__PURE__ */ __name((node) => join(node.definitions, "\n\n"), "leave")
      },
      OperationDefinition: {
        leave: /* @__PURE__ */ __name((node) => {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }, "leave")
      },
      VariableDefinition: {
        leave: /* @__PURE__ */ __name(({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " ")), "leave")
      },
      SelectionSet: { leave: /* @__PURE__ */ __name(({ selections }) => block(selections), "leave") },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
      // Fragments
      FragmentSpread: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => "..." + name + wrap(" ", join(directives, " ")), "leave")
      },
      InlineFragment: {
        leave: /* @__PURE__ */ __name(({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " "), "leave")
      },
      FragmentDefinition: {
        leave: /* @__PURE__ */ __name(({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        ), "leave")
      },
      // Value
      IntValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      FloatValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      StringValue: {
        leave: /* @__PURE__ */ __name(({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }, "leave")
      },
      BooleanValue: { leave: /* @__PURE__ */ __name(({ value }) => value ? "true" : "false", "leave") },
      NullValue: { leave: /* @__PURE__ */ __name(() => "null", "leave") },
      EnumValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      ListValue: { leave: /* @__PURE__ */ __name(({ values }) => "[" + join(values, ", ") + "]", "leave") },
      ObjectValue: { leave: /* @__PURE__ */ __name(({ fields }) => "{" + join(fields, ", ") + "}", "leave") },
      ObjectField: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
      // Directive
      Directive: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")"), "leave")
      },
      // Type
      NamedType: { leave: /* @__PURE__ */ __name(({ name }) => name, "leave") },
      ListType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => "[" + type2 + "]", "leave") },
      NonNullType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => type2 + "!", "leave") },
      // Type System Definitions
      SchemaDefinition: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      OperationTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ operation, type: type2 }) => operation + ": " + type2, "leave")
      },
      ScalarTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      FieldDefinition: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args, type: type2, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " ")), "leave")
      },
      InputValueDefinition: {
        leave: /* @__PURE__ */ __name(({ name, type: type2, defaultValue, directives }) => join([name + ": " + type2, wrap("= ", defaultValue), join(directives, " ")], " "), "leave")
      },
      InterfaceTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      UnionTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
      },
      EnumTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      EnumValueDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join([name, join(directives, " ")], " "), "leave")
      },
      InputObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " "), "leave")
      },
      DirectiveDefinition: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | "), "leave")
      },
      SchemaExtension: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      ScalarTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      InterfaceTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      UnionTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
      },
      EnumTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      InputObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " "), "leave")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    __name(printWithComments, "printWithComments");
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    __name(isFieldDefinitionNode, "isFieldDefinitionNode");
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    __name(getDescription, "getDescription");
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    __name(getComment, "getComment");
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    __name(getLeadingCommentBlock, "getLeadingCommentBlock");
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    __name(dedentBlockStringValue, "dedentBlockStringValue");
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent2 = leadingWhitespace(line);
        if (indent2 === line.length) {
          continue;
        }
        if (commonIndent === null || indent2 < commonIndent) {
          commonIndent = indent2;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    __name(getBlockStringIndentation, "getBlockStringIndentation");
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    __name(leadingWhitespace, "leadingWhitespace");
    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
    __name(isBlank, "isBlank");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = require_graphql2();
    var comments_js_1 = require_comments2();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);
          }
        } else {
          document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document
      };
    }
    __name(parseGraphQLSDL, "parseGraphQLSDL");
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: /* @__PURE__ */ __name((node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }, "leave")
      });
      return modifiedDoc;
    }
    __name(transformCommentsToDescriptions, "transformCommentsToDescriptions");
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    __name(isDescribable, "isDescribable");
    exports2.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = require_graphql2();
    var rootTypes_js_1 = require_rootTypes2();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    __name(addOperationVariable, "addOperationVariable");
    function resetOperationVariables() {
      operationVariables = [];
    }
    __name(resetOperationVariables, "resetOperationVariables");
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    __name(resetFieldMap, "resetFieldMap");
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    __name(buildOperationNodeForField, "buildOperationNodeForField");
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type2 = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type2.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type: type2,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    __name(buildOperationAndCollectVariables, "buildOperationAndCollectVariables");
    function resolveSelectionSet({ parent, type: type2, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type2)) {
        const types3 = type2.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types3.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type2,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type2)) {
        const types3 = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type2));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types3.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type2,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type2) && !rootTypeNames.has(type2.name)) {
        const isIgnored = ignore.includes(type2.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type2.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type2.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type: type2,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    __name(resolveSelectionSet, "resolveSelectionSet");
    function resolveVariable(arg, name) {
      function resolveVariableType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type2.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type2)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type2.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type2.name
          }
        };
      }
      __name(resolveVariableType, "resolveVariableType");
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    __name(resolveVariable, "resolveVariable");
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    __name(getArgumentName, "getArgumentName");
    function resolveField({ type: type2, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type2,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type2],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    __name(resolveField, "resolveField");
    function hasCircularRef(types3, config2 = {
      depth: 1
    }) {
      const type2 = types3[types3.length - 1];
      if ((0, graphql_1.isScalarType)(type2)) {
        return false;
      }
      const size = types3.filter((t) => t.name === type2.name).length;
      return size > config2.depth;
    }
    __name(hasCircularRef, "hasCircularRef");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/types.js
var require_types4 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = require_graphql2();
    function getObjectTypeFromTypeMap(typeMap, type2) {
      if (type2) {
        const maybeObjectType = typeMap[type2.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    __name(getObjectTypeFromTypeMap, "getObjectTypeFromTypeMap");
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = require_graphql2();
    function createNamedStub(name, type2) {
      let constructor;
      if (type2 === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type2 === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    __name(createNamedStub, "createNamedStub");
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type2) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type2));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type2));
        default:
          if (type2 === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    __name(createStub, "createStub");
    exports2.createStub = createStub;
    function isNamedStub(type2) {
      if ("getFields" in type2) {
        const fields = type2.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    __name(isNamedStub, "isNamedStub");
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type2) {
      switch (type2.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type2;
      }
    }
    __name(getBuiltInForStub, "getBuiltInForStub");
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = require_graphql2();
    var stub_js_1 = require_stub2();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          throw new Error(`Duplicate schema type name ${newName}`);
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      __name(rewireDirective, "rewireDirective");
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      __name(rewireArgs, "rewireArgs");
      function rewireNamedType(type2) {
        if ((0, graphql_1.isObjectType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields"),
            interfaces: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.interfaces), "interfaces")
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields")
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            types: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.types), "types")
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireInputFields(config2.fields), "fields")
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const enumConfig = type2.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type2)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type2)) {
            return type2;
          }
          const scalarConfig = type2.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type2}`);
      }
      __name(rewireNamedType, "rewireNamedType");
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      __name(rewireFields, "rewireFields");
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      __name(rewireInputFields, "rewireInputFields");
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      __name(rewireNamedTypes, "rewireNamedTypes");
      function rewireType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          const rewiredType = rewireType(type2.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type2)) {
          const rewiredType = rewireType(type2.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type2)) {
          let rewiredType = referenceTypeMap[type2.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type2) ? (0, stub_js_1.getBuiltInForStub)(type2) : rewireNamedType(type2);
            newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
      __name(rewireType, "rewireType");
    }
    __name(rewireTypes, "rewireTypes");
    exports2.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = require_graphql2();
    function transformInputValue(type2, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type2);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    __name(transformInputValue, "transformInputValue");
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type2, value) {
      return transformInputValue(type2, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    __name(serializeInputValue, "serializeInputValue");
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type2, value) {
      return transformInputValue(type2, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    __name(parseInputValue, "parseInputValue");
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type2, value) {
      return transformInputValue(type2, value, (t, v) => t.parseLiteral(v, {}));
    }
    __name(parseInputValueLiteral, "parseInputValueLiteral");
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = require_graphql2();
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap2();
    var Interfaces_js_1 = require_Interfaces2();
    var rewire_js_1 = require_rewire2();
    var transformInputValue_js_1 = require_transformInputValue2();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type2) => (0, graphql_1.isLeafType)(type2)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type2) => !(0, graphql_1.isLeafType)(type2)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    __name(mapSchema, "mapSchema");
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    __name(mapTypes, "mapTypes");
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => {
          const config2 = type2.toConfig();
          const originalEnumValueConfigMap = config2.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config2,
            values: newEnumValueConfigMap
          }));
        }
      }, (type2) => (0, graphql_1.isEnumType)(type2));
    }
    __name(mapEnumValues, "mapEnumValues");
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    __name(mapDefaultValues, "mapDefaultValues");
    function getNewType(newTypeMap, type2) {
      if ((0, graphql_1.isListType)(type2)) {
        const newType = getNewType(newTypeMap, type2.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type2)) {
        const newType = getNewType(newTypeMap, type2.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type2)) {
        const newType = newTypeMap[type2.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    __name(getNewType, "getNewType");
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    __name(mapFields, "mapFields");
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    __name(mapArguments, "mapArguments");
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    __name(mapDirectives, "mapDirectives");
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type2 = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    __name(getTypeSpecifiers, "getTypeSpecifiers");
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    __name(getTypeMapper, "getTypeMapper");
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type2 = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    __name(getFieldSpecifiers, "getFieldSpecifiers");
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    __name(getFieldMapper, "getFieldMapper");
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    __name(getArgumentMapper, "getArgumentMapper");
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    __name(getDirectiveMapper, "getDirectiveMapper");
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    __name(getEnumValueMapper, "getEnumValueMapper");
    function correctASTNodes(type2) {
      if ((0, graphql_1.isObjectType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config2);
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config2);
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config2);
      } else if ((0, graphql_1.isEnumType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const values = [];
          for (const enumKey in config2.values) {
            const enumValueConfig = config2.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            values
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config2);
      } else {
        return type2;
      }
    }
    __name(correctASTNodes, "correctASTNodes");
    exports2.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = require_graphql2();
    var Interfaces_js_1 = require_Interfaces2();
    var mapSchema_js_1 = require_mapSchema2();
    function filterSchema({ schema, typeFilter = /* @__PURE__ */ __name(() => true, "typeFilter"), fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type2) => filterRootFields(type2, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type2) => filterRootFields(type2, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type2) => filterRootFields(type2, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLObjectType, type2, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLInterfaceType, type2, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLInputObjectType, type2, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null
      });
      return filteredSchema;
    }
    __name(filterSchema, "filterSchema");
    exports2.filterSchema = filterSchema;
    function filterRootFields(type2, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config2 = type2.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config2);
      }
      return type2;
    }
    __name(filterRootFields, "filterRootFields");
    function filterElementFields(ElementConstructor, type2, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config2 = type2.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (fieldFilter && !fieldFilter(type2.name, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type2.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config2);
      }
    }
    __name(filterElementFields, "filterElementFields");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = require_graphql2();
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    __name(healSchema, "healSchema");
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualName in actualNamedTypeMap) {
          throw new Error(`Duplicate schema type name ${actualName}`);
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type2) {
        if ((0, graphql_1.isObjectType)(type2)) {
          healFields(type2);
          healInterfaces(type2);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          healFields(type2);
          if ("getInterfaces" in type2) {
            healInterfaces(type2);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type2)) {
          healUnderlyingTypes(type2);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          healInputFields(type2);
          return;
        } else if ((0, graphql_1.isLeafType)(type2)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type2}`);
      }
      __name(healNamedType, "healNamedType");
      function healFields(type2) {
        const fieldMap = type2.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      __name(healFields, "healFields");
      function healInterfaces(type2) {
        if ("getInterfaces" in type2) {
          const interfaces = type2.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      __name(healInterfaces, "healInterfaces");
      function healInputFields(type2) {
        const fieldMap = type2.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      __name(healInputFields, "healInputFields");
      function healUnderlyingTypes(type2) {
        const types3 = type2.getTypes();
        types3.push(...types3.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      __name(healUnderlyingTypes, "healUnderlyingTypes");
      function healType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          const healedType = healType(type2.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type2)) {
          const healedType = healType(type2.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type2)) {
          const officialType = originalTypeMap[type2.name];
          if (officialType && type2 !== officialType) {
            return officialType;
          }
        }
        return type2;
      }
      __name(healType, "healType");
    }
    __name(healTypes, "healTypes");
    exports2.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = require_graphql2();
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers2 = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type2 = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type2)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type2)) {
              const config2 = type2.toConfig();
              delete config2.astNode;
              resolvers2[typeName] = new graphql_1.GraphQLScalarType(config2);
            }
          } else if ((0, graphql_1.isEnumType)(type2)) {
            resolvers2[typeName] = {};
            const values = type2.getValues();
            for (const value of values) {
              resolvers2[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type2)) {
            if (type2.resolveType != null) {
              resolvers2[typeName] = {
                __resolveType: type2.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type2)) {
            if (type2.resolveType != null) {
              resolvers2[typeName] = {
                __resolveType: type2.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type2)) {
            resolvers2[typeName] = {};
            if (type2.isTypeOf != null) {
              resolvers2[typeName].__isTypeOf = type2.isTypeOf;
            }
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers2[typeName][fieldName] = resolvers2[typeName][fieldName] || {};
                resolvers2[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers2[typeName][fieldName] = resolvers2[typeName][fieldName] || {};
                resolvers2[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers2;
    }
    __name(getResolversFromSchema, "getResolversFromSchema");
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = require_graphql2();
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type2).name.startsWith("__") && (0, graphql_1.isObjectType)(type2)) {
          const fields = type2.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    __name(forEachField, "forEachField");
    exports2.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = require_graphql2();
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type2).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type2)) {
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type2)) {
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    __name(forEachDefaultValue, "forEachDefaultValue");
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = require_graphql2();
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap2();
    var rewire_js_1 = require_rewire2();
    function addTypes(schema, newTypesOrDirectives) {
      const config2 = schema.toConfig();
      const originalTypeMap = {};
      for (const type2 of config2.types) {
        originalTypeMap[type2.name] = type2;
      }
      const originalDirectiveMap = {};
      for (const directive of config2.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config2,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    __name(addTypes, "addTypes");
    exports2.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = require_graphql2();
    var mapSchema_js_1 = require_mapSchema2();
    var Interfaces_js_1 = require_Interfaces2();
    var rootTypes_js_1 = require_rootTypes2();
    var get_implementing_types_js_1 = require_get_implementing_types2();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type2 = prunedSchema.getType(typeName);
            if (type2 && skipPruning(type2)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type2) => {
            if (!visited.has(type2.name) && !(0, graphql_1.isSpecifiedScalarType)(type2)) {
              if ((0, graphql_1.isUnionType)(type2) || (0, graphql_1.isInputObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2) || (0, graphql_1.isObjectType)(type2) || (0, graphql_1.isScalarType)(type2)) {
                if (skipUnusedTypesPruning) {
                  return type2;
                }
                if ((0, graphql_1.isUnionType)(type2) && skipEmptyUnionPruning && !Object.keys(type2.getTypes()).length) {
                  return type2;
                }
                if ((0, graphql_1.isInputObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2) || (0, graphql_1.isObjectType)(type2)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type2.getFields()).length) {
                    return type2;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type2) && skipUnimplementedInterfacesPruning) {
                  return type2;
                }
              }
              prunedTypes.push(type2.name);
              visited.delete(type2.name);
              return null;
            }
            return type2;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    __name(pruneSchema, "pruneSchema");
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type2 of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type2.name);
      }
      return visitQueue(queue, schema);
    }
    __name(visitSchema, "visitSchema");
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type2 = schema.getType(typeName);
        if (type2) {
          if ((0, graphql_1.isUnionType)(type2)) {
            queue.push(...type2.getTypes().map((type3) => type3.name));
          }
          if ((0, graphql_1.isInterfaceType)(type2) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type2.name, schema));
            revisit[typeName] = false;
          }
          if ("getInterfaces" in type2) {
            queue.push(...type2.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type2) {
            const fields = type2.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type2)) {
                queue.push(...field.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
    __name(visitQueue, "visitQueue");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers2();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject2(target) && isObject2(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject2(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    __name(mergeDeep, "mergeDeep");
    exports2.mergeDeep = mergeDeep;
    function isObject2(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
    __name(isObject2, "isObject");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = require_graphql2();
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    __name(parseSelectionSet, "parseSelectionSet");
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info3) {
      return info3.fieldNodes[0].alias != null ? info3.fieldNodes[0].alias.value : info3.fieldName;
    }
    __name(getResponseKeyFromInfo, "getResponseKeyFromInfo");
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields3 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = require_graphql2();
    var Interfaces_js_1 = require_Interfaces2();
    var mapSchema_js_1 = require_mapSchema2();
    var addTypes_js_1 = require_addTypes2();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    __name(appendObjectFields, "appendObjectFields");
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    __name(removeObjectFields, "removeObjectFields");
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    __name(selectObjectFields, "selectObjectFields");
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    __name(modifyObjectFields, "modifyObjectFields");
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = require_graphql2();
    function renameType(type2, newTypeName) {
      if ((0, graphql_1.isObjectType)(type2)) {
        return new graphql_1.GraphQLObjectType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type2)) {
        return new graphql_1.GraphQLUnionType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type2)) {
        return new graphql_1.GraphQLEnumType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type2)) {
        return new graphql_1.GraphQLScalarType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type2}.`);
    }
    __name(renameType, "renameType");
    exports2.renameType = renameType;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator3 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = /* @__PURE__ */ __name((error3) => {
          const rethrow = /* @__PURE__ */ __name(() => Promise.reject(error3), "rethrow");
          return $return.call(iterator).then(rethrow, rethrow);
        }, "abruptClose");
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      __name(mapResult, "mapResult");
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = /* @__PURE__ */ __name((error3) => asyncMapValue(error3, reject).then(iteratorResult, abruptClose), "mapReject");
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error3) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error3).then(mapResult, mapReject);
          }
          return Promise.reject(error3).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(mapAsyncIterator, "mapAsyncIterator");
    exports2.mapAsyncIterator = mapAsyncIterator;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    __name(asyncMapValue, "asyncMapValue");
    function iteratorResult(value) {
      return { value, done: false };
    }
    __name(iteratorResult, "iteratorResult");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = require_graphql2();
    var astFromType_js_1 = require_astFromType2();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type2, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type2)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    __name(updateArgument, "updateArgument");
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    __name(createVariableNameGenerator, "createVariableNameGenerator");
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = require_graphql2();
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    __name(implementsAbstractType, "implementsAbstractType");
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = /* @__PURE__ */ __name((value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      }, "pushValue");
      const pushError = /* @__PURE__ */ __name((error3) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error3] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error3] }, done: false });
        }
      }, "pushError");
      const pushDone = /* @__PURE__ */ __name(() => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      }, "pushDone");
      const pullValue = /* @__PURE__ */ __name(() => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      }), "pullValue");
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = /* @__PURE__ */ __name(() => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      }, "emptyQueue");
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error3) {
          emptyQueue();
          return Promise.reject(error3);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(observableToAsyncIterable, "observableToAsyncIterable");
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = require_graphql2();
    var memoize_js_1 = require_memoize2();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    __name(getOperationASTFromDocument, "getOperationASTFromDocument");
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getOperationASTFromRequest(request2) {
      return getOperationASTFromDocument(request2.document, request2.operationName);
    }, "getOperationASTFromRequest"));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields3 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize2();
    var graphql_1 = require_graphql2();
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    __name(collectFields, "collectFields");
    exports2.collectFields = collectFields;
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    __name(shouldIncludeNode, "shouldIncludeNode");
    function doesFragmentConditionMatch(schema, fragment, type2) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type2) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type2);
      }
      return false;
    }
    __name(doesFragmentConditionMatch, "doesFragmentConditionMatch");
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    __name(getFieldEntryKey, "getFieldEntryKey");
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(/* @__PURE__ */ __name(function collectSubFields(schema, fragments, variableValues, type2, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const fieldNode of fieldNodes) {
        if (fieldNode.selectionSet) {
          collectFields(schema, fragments, variableValues, type2, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    }, "collectSubFields"));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest2();
    var graphql_1 = require_graphql2();
    var collectFields_js_1 = require_collectFields3();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    __name(visitData, "visitData");
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error3) => visitor(error3));
    }
    __name(visitErrors, "visitErrors");
    exports2.visitErrors = visitErrors;
    function visitResult(result, request2, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request2.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request2.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request2);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    __name(visitResult, "visitResult");
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    __name(visitErrorsByType, "visitErrorsByType");
    function getOperationRootType(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    __name(getOperationRootType, "getOperationRootType");
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType(schema, operation);
      const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    __name(visitRoot, "visitRoot");
    function visitObjectValue(object, type2, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type2.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type2.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error3 of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error3);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type2, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error3 of errors2) {
            errorInfo.unpathedErrors.add(error3);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    __name(visitObjectValue, "visitObjectValue");
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    __name(updateObject, "updateObject");
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    __name(visitListValue, "visitListValue");
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    __name(visitFieldValue, "visitFieldValue");
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error3 of errors) {
        const pathSegment = (_a = error3.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error3);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error3);
        } else {
          errorMap[pathSegment] = [error3];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    __name(sortErrorsByPathSegment, "sortErrorsByPathSegment");
    function addPathSegmentInfo(type2, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error3 of errors) {
        const segmentInfo = {
          type: type2,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error3);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error3, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
    __name(addPathSegmentInfo, "addPathSegmentInfo");
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    __name(valueMatchesCriteria, "valueMatchesCriteria");
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable3 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    __name(isAsyncIterable, "isAsyncIterable");
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = require_graphql2();
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    __name(isDocumentNode, "isDocumentNode");
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize2();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    __name(defaultAsyncIteratorReturn, "defaultAsyncIteratorReturn");
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(/* @__PURE__ */ __name(function proxyMethodFactory2(target, targetMethod) {
      return /* @__PURE__ */ __name(function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      }, "proxyMethod");
    }, "proxyMethodFactory"));
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return /* @__PURE__ */ __name(async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            }, "returnWithCancel");
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    __name(getAsyncIteratorWithCancel, "getAsyncIteratorWithCancel");
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return /* @__PURE__ */ __name(function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            }, "asyncIteratorFactory");
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    __name(getAsyncIterableWithCancel, "getAsyncIterableWithCancel");
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = require_graphql2();
    var print_schema_with_directives_js_1 = require_print_schema_with_directives2();
    function buildFixedSchema(schema, options) {
      const document = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document, {
        ...options || {}
      });
    }
    __name(buildFixedSchema, "buildFixedSchema");
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    __name(fixSchemaAst, "fixSchemaAst");
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_loaders2(), exports2);
    tslib_1.__exportStar(require_helpers2(), exports2);
    tslib_1.__exportStar(require_get_directives2(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives2(), exports2);
    tslib_1.__exportStar(require_get_implementing_types2(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives2(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives2(), exports2);
    tslib_1.__exportStar(require_validate_documents2(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json2(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl2(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field2(), exports2);
    tslib_1.__exportStar(require_types4(), exports2);
    tslib_1.__exportStar(require_filterSchema2(), exports2);
    tslib_1.__exportStar(require_heal2(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema2(), exports2);
    tslib_1.__exportStar(require_forEachField2(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue2(), exports2);
    tslib_1.__exportStar(require_mapSchema2(), exports2);
    tslib_1.__exportStar(require_addTypes2(), exports2);
    tslib_1.__exportStar(require_rewire2(), exports2);
    tslib_1.__exportStar(require_prune2(), exports2);
    tslib_1.__exportStar(require_mergeDeep2(), exports2);
    tslib_1.__exportStar(require_Interfaces2(), exports2);
    tslib_1.__exportStar(require_stub2(), exports2);
    tslib_1.__exportStar(require_selectionSets2(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo2(), exports2);
    tslib_1.__exportStar(require_fields3(), exports2);
    tslib_1.__exportStar(require_renameType2(), exports2);
    tslib_1.__exportStar(require_transformInputValue2(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator3(), exports2);
    tslib_1.__exportStar(require_updateArgument2(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType2(), exports2);
    tslib_1.__exportStar(require_errors2(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable2(), exports2);
    tslib_1.__exportStar(require_visitResult2(), exports2);
    tslib_1.__exportStar(require_getArgumentValues2(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria2(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable3(), exports2);
    tslib_1.__exportStar(require_isDocumentNode2(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped2(), exports2);
    tslib_1.__exportStar(require_executor2(), exports2);
    tslib_1.__exportStar(require_withCancel2(), exports2);
    tslib_1.__exportStar(require_AggregateError2(), exports2);
    tslib_1.__exportStar(require_rootTypes2(), exports2);
    tslib_1.__exportStar(require_comments2(), exports2);
    tslib_1.__exportStar(require_collectFields3(), exports2);
    tslib_1.__exportStar(require_inspect3(), exports2);
    tslib_1.__exportStar(require_memoize2(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst2(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest2(), exports2);
  }
});

// node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertResolversPresent = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs5();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    __name(assertResolversPresent, "assertResolversPresent");
    exports2.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
    __name(expectResolver, "expectResolver");
  }
});

// node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.chainResolvers = void 0;
    var graphql_1 = require_graphql2();
    function chainResolvers(resolvers2) {
      return (root, args, ctx, info3) => resolvers2.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info3);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info3);
      }, root);
    }
    __name(chainResolvers, "chainResolvers");
    exports2.chainResolvers = chainResolvers;
  }
});

// node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs5();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type2) => {
          if (!type2.resolveType) {
            const message = `Type "${type2.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    __name(checkForResolveTypeResolver, "checkForResolveTypeResolver");
    exports2.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers2) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if ("getInterfaces" in type2) {
          extendedResolvers[typeName] = {};
          for (const iFace of type2.getInterfaces()) {
            if (resolvers2[iFace.name]) {
              for (const fieldName in resolvers2[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers2[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers2[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers2[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    __name(extendResolversFromInterfaces, "extendResolversFromInterfaces");
    exports2.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addResolversToSchema = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs5();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver2();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces2();
    function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
      const options = (0, graphql_1.isSchema)(schemaOrOptions) ? {
        schema: schemaOrOptions,
        resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
        resolverValidationOptions: legacyInputValidationOptions
      } : schemaOrOptions;
      let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers2 = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers2) {
        const resolverValue = resolvers2[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type2 = schema.getType(typeName);
        if (type2 == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type2[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const values = type2.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but not present within ${type2.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type2)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but ${type2.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type2.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    __name(addResolversToSchema, "addResolversToSchema");
    exports2.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers2) {
        const type2 = schema.getType(typeName);
        const resolverValue = resolvers2[typeName];
        if ((0, graphql_1.isScalarType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type2.astNode != null) {
              type2.astNode = {
                ...type2.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.astNode.description,
                directives: ((_c = type2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type2.extensionASTNodes != null) {
              type2.extensionASTNodes = type2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
              type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
            } else {
              type2[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const config2 = type2.toConfig();
          const enumValueConfigMap = config2.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config2[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config2.astNode != null) {
              config2.astNode = {
                ...config2.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config2.astNode.description,
                directives: ((_j = config2.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
              config2.extensionASTNodes = config2.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
              type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config2);
        } else if ((0, graphql_1.isUnionType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type2[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type2.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver;
          }
        });
      }
      return schema;
    }
    __name(addResolversToExistingSchema, "addResolversToExistingSchema");
    function createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type2) => {
          var _a, _b, _c, _d, _e, _f;
          const config2 = type2.toConfig();
          const resolverValue = resolvers2[type2.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type2) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config2[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config2.astNode != null) {
                config2.astNode = {
                  ...config2.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
                  directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
                config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
                config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
              } else {
                config2[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config2);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type2) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers2[type2.name];
          const config2 = type2.toConfig();
          const enumValueConfigMap = config2.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config2[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config2.astNode != null) {
                config2.astNode = {
                  ...config2.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
                  directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
                config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
                config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config2);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type2) => {
          const resolverValue = resolvers2[type2.name];
          if (resolverValue != null) {
            const config2 = type2.toConfig();
            if (resolverValue["__resolveType"]) {
              config2.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config2);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type2) => {
          const resolverValue = resolvers2[type2.name];
          if (resolverValue != null) {
            const config2 = type2.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config2.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config2);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type2) => {
          const resolverValue = resolvers2[type2.name];
          if (resolverValue != null) {
            const config2 = type2.toConfig();
            if (resolverValue["__resolveType"]) {
              config2.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config2);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers2[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
          })
        });
      }
      return schema;
    }
    __name(createNewSchemaWithResolvers, "createNewSchemaWithResolvers");
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
    __name(setFieldProperties, "setFieldProperties");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = require_graphql2();
    var asArray = /* @__PURE__ */ __name((fns) => Array.isArray(fns) ? fns : fns ? [fns] : [], "asArray");
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isDocumentString, "isDocumentString");
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    __name(isValidPath, "isValidPath");
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    __name(compareStrings, "compareStrings");
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    __name(nodeToString, "nodeToString");
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    __name(compareNodes, "compareNodes");
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    __name(isSome, "isSome");
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    __name(assertSome, "assertSome");
    exports2.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = require_graphql2();
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    __name(createGraphQLError, "createGraphQLError");
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    __name(relocatedError, "relocatedError");
    exports2.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        static {
          __name(this, "AggregateErrorClass");
        }
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = /* @__PURE__ */ __name(function(errors, message) {
        return new AggregateErrorClass(errors, message);
      }, "AggregateErrorImpl");
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error3) {
      return "errors" in error3 && Array.isArray(error3["errors"]);
    }
    __name(isAggregateError, "isAggregateError");
    exports2.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = require_graphql2();
    var AggregateError_js_1 = require_AggregateError3();
    var MAX_RECURSIVE_DEPTH = 3;
    function inspect2(value) {
      return formatValue(value, []);
    }
    __name(inspect2, "inspect");
    exports2.inspect = inspect2;
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    __name(formatValue, "formatValue");
    function formatError(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    __name(formatError, "formatError");
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    __name(formatObjectValue, "formatObjectValue");
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    __name(isJSONable, "isJSONable");
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    __name(formatObject, "formatObject");
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = array.length;
      const remaining = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    __name(formatArray, "formatArray");
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
    __name(getObjectTag, "getObjectTag");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var graphql_1 = require_graphql2();
    var errors_js_1 = require_errors3();
    var inspect_js_1 = require_inspect4();
    function getArgumentValues(def, node, variableValues = {}) {
      var _a;
      const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
        ...prev,
        [key]: value
      }), {});
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || variableMap[variableName] == null) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    __name(getArgumentValues, "getArgumentValues");
    exports2.getArgumentValues = getArgumentValues;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues3();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    __name(getDirectivesInExtensions, "getDirectivesInExtensions");
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    __name(_getDirectiveInExtensions, "_getDirectiveInExtensions");
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    __name(getDirectiveInExtensions, "getDirectiveInExtensions");
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    __name(getDirectives, "getDirectives");
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    __name(getDirective, "getDirective");
    exports2.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = require_graphql2();
    function parseDirectiveValue(value) {
      switch (value.kind) {
        case graphql_1.Kind.INT:
          return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
          return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
          return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
          return value.value;
        case graphql_1.Kind.LIST:
          return value.values.map((v) => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
          return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
          return null;
        default:
          return null;
      }
    }
    __name(parseDirectiveValue, "parseDirectiveValue");
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type2 of allTypes) {
        const typeName = type2.name.value;
        if (type2.fields == null) {
          continue;
        }
        for (const field of type2.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    __name(getFieldsWithDirectives, "getFieldsWithDirectives");
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = require_graphql2();
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    __name(getImplementingTypes, "getImplementingTypes");
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = require_graphql2();
    var inspect_js_1 = require_inspect4();
    function astFromType(type2) {
      if ((0, graphql_1.isNonNullType)(type2)) {
        const innerType = astFromType(type2.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type2)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type2)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type2.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        }
      };
    }
    __name(astFromType, "astFromType");
    exports2.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = require_graphql2();
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    __name(astFromValueUntyped, "astFromValueUntyped");
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize1, "memoize1");
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2, "memoize2");
    exports2.memoize2 = memoize2;
    function memoize3(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize3, "memoize3");
    exports2.memoize3 = memoize3;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize4, "memoize4");
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize5, "memoize5");
    exports2.memoize5 = memoize5;
    var memoize2of4cache = /* @__PURE__ */ new WeakMap();
    function memoize2of4(fn) {
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      }, "memoized");
    }
    __name(memoize2of4, "memoize2of4");
    exports2.memoize2of4 = memoize2of4;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var memoize_js_1 = require_memoize4();
    function getDefinedRootType(schema, operation) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
      }
      return rootType;
    }
    __name(getDefinedRootType, "getDefinedRootType");
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type2) => type2.name));
    }, "getRootTypeNames"));
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    }, "getRootTypes"));
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    }, "getRootTypeMap"));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = require_graphql2();
    var astFromType_js_1 = require_astFromType3();
    var get_directives_js_1 = require_get_directives3();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped3();
    var helpers_js_1 = require_helpers3();
    var rootTypes_js_1 = require_rootTypes3();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type2 = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type2);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type2);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type2)) {
          definitions.push(astFromObjectType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          definitions.push(astFromInterfaceType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type2)) {
          definitions.push(astFromUnionType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          definitions.push(astFromInputObjectType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type2)) {
          definitions.push(astFromEnumType(type2, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type2)) {
          definitions.push(astFromScalarType(type2, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type2}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    __name(getDocumentNodeFromSchema, "getDocumentNodeFromSchema");
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    __name(printSchemaWithDirectives, "printSchemaWithDirectives");
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    __name(astFromSchema, "astFromSchema");
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    __name(astFromDirective, "astFromDirective");
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    __name(getDirectiveNodes, "getDirectiveNodes");
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    __name(getDeprecatableDirectiveNodes, "getDeprecatableDirectiveNodes");
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromArg, "astFromArg");
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type2.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromObjectType, "astFromObjectType");
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type2) {
        node.interfaces = Object.values(type2.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    __name(astFromInterfaceType, "astFromInterfaceType");
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions),
        types: type2.getTypes().map((type3) => (0, astFromType_js_1.astFromType)(type3))
      };
    }
    __name(astFromUnionType, "astFromUnionType");
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        fields: Object.values(type2.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromInputObjectType, "astFromInputObjectType");
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        values: Object.values(type2.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromEnumType, "astFromEnumType");
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type2, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type2, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type2["specifiedByUrl"] || type2["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type2.description ? {
          kind: graphql_1.Kind.STRING,
          value: type2.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type2.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    __name(astFromScalarType, "astFromScalarType");
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromField, "astFromField");
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    __name(astFromInputField, "astFromInputField");
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    __name(astFromEnumValue, "astFromEnumValue");
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    __name(makeDeprecatedDirective, "makeDeprecatedDirective");
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    __name(makeDirectiveNode, "makeDirectiveNode");
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    __name(makeDirectiveNodes, "makeDirectiveNodes");
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.checkValidationErrors = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = require_graphql2();
    var AggregateError_js_1 = require_AggregateError3();
    async function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {
      const allFragmentMap = /* @__PURE__ */ new Map();
      const documentFileObjectsToValidate = [];
      for (const documentFile of documentFiles) {
        if (documentFile.document) {
          const definitionsToValidate = [];
          for (const definitionNode of documentFile.document.definitions) {
            if (definitionNode.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
              allFragmentMap.set(definitionNode.name.value, definitionNode);
            } else {
              definitionsToValidate.push(definitionNode);
            }
          }
          documentFileObjectsToValidate.push({
            location: documentFile.location,
            document: {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: definitionsToValidate
            }
          });
        }
      }
      const allErrors = [];
      const allFragmentsDocument = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...allFragmentMap.values()]
      };
      await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
        const documentToValidate = (0, graphql_1.concatAST)([allFragmentsDocument, documentFile.document]);
        const errors = (0, graphql_1.validate)(schema, documentToValidate, effectiveRules);
        if (errors.length > 0) {
          allErrors.push({
            filePath: documentFile.location,
            errors
          });
        }
      }));
      return allErrors;
    }
    __name(validateGraphQlDocuments, "validateGraphQlDocuments");
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function checkValidationErrors(loadDocumentErrors) {
      if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
          for (const graphQLError of loadDocumentError.errors) {
            const error3 = new Error();
            error3.name = "GraphQLDocumentError";
            error3.message = `${error3.name}: ${graphQLError.message}`;
            error3.stack = error3.message;
            if (graphQLError.locations) {
              for (const location of graphQLError.locations) {
                error3.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
              }
            }
            errors.push(error3);
          }
        }
        throw new AggregateError_js_1.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error3, index) => `Error ${index}: ${error3.stack}`).join("\n\n")}`);
      }
    }
    __name(checkValidationErrors, "checkValidationErrors");
    exports2.checkValidationErrors = checkValidationErrors;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    __name(createDefaultRules, "createDefaultRules");
    exports2.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = require_graphql2();
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    __name(stripBOM, "stripBOM");
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    __name(parseBOM, "parseBOM");
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    __name(parseGraphQLJSON, "parseGraphQLJSON");
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = require_graphql2();
    var MAX_LINE_LENGTH = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    __name(resetComments, "resetComments");
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    __name(collectComment, "collectComment");
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    __name(pushComment, "pushComment");
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    __name(printComment, "printComment");
    exports2.printComment = printComment;
    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    __name(join, "join");
    function hasMultilineItems(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    __name(hasMultilineItems, "hasMultilineItems");
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    __name(addDescription, "addDescription");
    function indent(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    __name(indent, "indent");
    function block(array) {
      return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
    }
    __name(block, "block");
    function wrap(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    __name(wrap, "wrap");
    function printBlockString(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
    }
    __name(printBlockString, "printBlockString");
    var printDocASTReducer = {
      Name: { leave: /* @__PURE__ */ __name((node) => node.value, "leave") },
      Variable: { leave: /* @__PURE__ */ __name((node) => "$" + node.name, "leave") },
      // Document
      Document: {
        leave: /* @__PURE__ */ __name((node) => join(node.definitions, "\n\n"), "leave")
      },
      OperationDefinition: {
        leave: /* @__PURE__ */ __name((node) => {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }, "leave")
      },
      VariableDefinition: {
        leave: /* @__PURE__ */ __name(({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " ")), "leave")
      },
      SelectionSet: { leave: /* @__PURE__ */ __name(({ selections }) => block(selections), "leave") },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
      // Fragments
      FragmentSpread: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => "..." + name + wrap(" ", join(directives, " ")), "leave")
      },
      InlineFragment: {
        leave: /* @__PURE__ */ __name(({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " "), "leave")
      },
      FragmentDefinition: {
        leave: /* @__PURE__ */ __name(({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        ), "leave")
      },
      // Value
      IntValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      FloatValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      StringValue: {
        leave: /* @__PURE__ */ __name(({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }, "leave")
      },
      BooleanValue: { leave: /* @__PURE__ */ __name(({ value }) => value ? "true" : "false", "leave") },
      NullValue: { leave: /* @__PURE__ */ __name(() => "null", "leave") },
      EnumValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
      ListValue: { leave: /* @__PURE__ */ __name(({ values }) => "[" + join(values, ", ") + "]", "leave") },
      ObjectValue: { leave: /* @__PURE__ */ __name(({ fields }) => "{" + join(fields, ", ") + "}", "leave") },
      ObjectField: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
      // Directive
      Directive: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")"), "leave")
      },
      // Type
      NamedType: { leave: /* @__PURE__ */ __name(({ name }) => name, "leave") },
      ListType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => "[" + type2 + "]", "leave") },
      NonNullType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => type2 + "!", "leave") },
      // Type System Definitions
      SchemaDefinition: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      OperationTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ operation, type: type2 }) => operation + ": " + type2, "leave")
      },
      ScalarTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      FieldDefinition: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args, type: type2, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " ")), "leave")
      },
      InputValueDefinition: {
        leave: /* @__PURE__ */ __name(({ name, type: type2, defaultValue, directives }) => join([name + ": " + type2, wrap("= ", defaultValue), join(directives, " ")], " "), "leave")
      },
      InterfaceTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      UnionTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
      },
      EnumTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      EnumValueDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join([name, join(directives, " ")], " "), "leave")
      },
      InputObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " "), "leave")
      },
      DirectiveDefinition: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | "), "leave")
      },
      SchemaExtension: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " "), "leave")
      },
      ScalarTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " "), "leave")
      },
      ObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      InterfaceTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
      },
      UnionTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
      },
      EnumTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " "), "leave")
      },
      InputObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " "), "leave")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    __name(printWithComments, "printWithComments");
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    __name(isFieldDefinitionNode, "isFieldDefinitionNode");
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    __name(getDescription, "getDescription");
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    __name(getComment, "getComment");
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    __name(getLeadingCommentBlock, "getLeadingCommentBlock");
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    __name(dedentBlockStringValue, "dedentBlockStringValue");
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent2 = leadingWhitespace(line);
        if (indent2 === line.length) {
          continue;
        }
        if (commonIndent === null || indent2 < commonIndent) {
          commonIndent = indent2;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    __name(getBlockStringIndentation, "getBlockStringIndentation");
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    __name(leadingWhitespace, "leadingWhitespace");
    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
    __name(isBlank, "isBlank");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = require_graphql2();
    var comments_js_1 = require_comments3();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);
          }
        } else {
          document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document
      };
    }
    __name(parseGraphQLSDL, "parseGraphQLSDL");
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: /* @__PURE__ */ __name((node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }, "leave")
      });
      return modifiedDoc;
    }
    __name(transformCommentsToDescriptions, "transformCommentsToDescriptions");
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    __name(isDescribable, "isDescribable");
    exports2.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = require_graphql2();
    var rootTypes_js_1 = require_rootTypes3();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    __name(addOperationVariable, "addOperationVariable");
    function resetOperationVariables() {
      operationVariables = [];
    }
    __name(resetOperationVariables, "resetOperationVariables");
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    __name(resetFieldMap, "resetFieldMap");
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    __name(buildOperationNodeForField, "buildOperationNodeForField");
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type2 = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type2.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type: type2,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    __name(buildOperationAndCollectVariables, "buildOperationAndCollectVariables");
    function resolveSelectionSet({ parent, type: type2, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type2)) {
        const types3 = type2.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types3.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type2,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type2)) {
        const types3 = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type2));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types3.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type2,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type2) && !rootTypeNames.has(type2.name)) {
        const isIgnored = ignore.includes(type2.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type2.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type2.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type: type2,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    __name(resolveSelectionSet, "resolveSelectionSet");
    function resolveVariable(arg, name) {
      function resolveVariableType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type2.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type2)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type2.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type2.name
          }
        };
      }
      __name(resolveVariableType, "resolveVariableType");
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    __name(resolveVariable, "resolveVariable");
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    __name(getArgumentName, "getArgumentName");
    function resolveField({ type: type2, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type2,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type2],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    __name(resolveField, "resolveField");
    function hasCircularRef(types3, config2 = {
      depth: 1
    }) {
      const type2 = types3[types3.length - 1];
      if ((0, graphql_1.isScalarType)(type2)) {
        return false;
      }
      const size = types3.filter((t) => t.name === type2.name).length;
      return size > config2.depth;
    }
    __name(hasCircularRef, "hasCircularRef");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/types.js
var require_types5 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = require_graphql2();
    function getObjectTypeFromTypeMap(typeMap, type2) {
      if (type2) {
        const maybeObjectType = typeMap[type2.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    __name(getObjectTypeFromTypeMap, "getObjectTypeFromTypeMap");
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = require_graphql2();
    function createNamedStub(name, type2) {
      let constructor;
      if (type2 === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type2 === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    __name(createNamedStub, "createNamedStub");
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type2) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type2));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type2));
        default:
          if (type2 === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    __name(createStub, "createStub");
    exports2.createStub = createStub;
    function isNamedStub(type2) {
      if ("getFields" in type2) {
        const fields = type2.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    __name(isNamedStub, "isNamedStub");
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type2) {
      switch (type2.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type2;
      }
    }
    __name(getBuiltInForStub, "getBuiltInForStub");
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = require_graphql2();
    var stub_js_1 = require_stub3();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          throw new Error(`Duplicate schema type name ${newName}`);
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      __name(rewireDirective, "rewireDirective");
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      __name(rewireArgs, "rewireArgs");
      function rewireNamedType(type2) {
        if ((0, graphql_1.isObjectType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields"),
            interfaces: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.interfaces), "interfaces")
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields")
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            types: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.types), "types")
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          const config2 = type2.toConfig();
          const newConfig = {
            ...config2,
            fields: /* @__PURE__ */ __name(() => rewireInputFields(config2.fields), "fields")
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type2)) {
          const enumConfig = type2.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type2)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type2)) {
            return type2;
          }
          const scalarConfig = type2.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type2}`);
      }
      __name(rewireNamedType, "rewireNamedType");
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      __name(rewireFields, "rewireFields");
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      __name(rewireInputFields, "rewireInputFields");
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      __name(rewireNamedTypes, "rewireNamedTypes");
      function rewireType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          const rewiredType = rewireType(type2.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type2)) {
          const rewiredType = rewireType(type2.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type2)) {
          let rewiredType = referenceTypeMap[type2.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type2) ? (0, stub_js_1.getBuiltInForStub)(type2) : rewireNamedType(type2);
            newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
      __name(rewireType, "rewireType");
    }
    __name(rewireTypes, "rewireTypes");
    exports2.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = require_graphql2();
    function transformInputValue(type2, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type2);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    __name(transformInputValue, "transformInputValue");
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type2, value) {
      return transformInputValue(type2, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    __name(serializeInputValue, "serializeInputValue");
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type2, value) {
      return transformInputValue(type2, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    __name(parseInputValue, "parseInputValue");
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type2, value) {
      return transformInputValue(type2, value, (t, v) => t.parseLiteral(v, {}));
    }
    __name(parseInputValueLiteral, "parseInputValueLiteral");
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = require_graphql2();
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap3();
    var Interfaces_js_1 = require_Interfaces3();
    var rewire_js_1 = require_rewire3();
    var transformInputValue_js_1 = require_transformInputValue3();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type2) => (0, graphql_1.isLeafType)(type2)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type2) => !(0, graphql_1.isLeafType)(type2)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    __name(mapSchema, "mapSchema");
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    __name(mapTypes, "mapTypes");
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => {
          const config2 = type2.toConfig();
          const originalEnumValueConfigMap = config2.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config2,
            values: newEnumValueConfigMap
          }));
        }
      }, (type2) => (0, graphql_1.isEnumType)(type2));
    }
    __name(mapEnumValues, "mapEnumValues");
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    __name(mapDefaultValues, "mapDefaultValues");
    function getNewType(newTypeMap, type2) {
      if ((0, graphql_1.isListType)(type2)) {
        const newType = getNewType(newTypeMap, type2.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type2)) {
        const newType = getNewType(newTypeMap, type2.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type2)) {
        const newType = newTypeMap[type2.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    __name(getNewType, "getNewType");
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    __name(mapFields, "mapFields");
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    __name(mapArguments, "mapArguments");
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    __name(mapDirectives, "mapDirectives");
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type2 = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    __name(getTypeSpecifiers, "getTypeSpecifiers");
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    __name(getTypeMapper, "getTypeMapper");
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type2 = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    __name(getFieldSpecifiers, "getFieldSpecifiers");
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    __name(getFieldMapper, "getFieldMapper");
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    __name(getArgumentMapper, "getArgumentMapper");
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    __name(getDirectiveMapper, "getDirectiveMapper");
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    __name(getEnumValueMapper, "getEnumValueMapper");
    function correctASTNodes(type2) {
      if ((0, graphql_1.isObjectType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config2);
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config2);
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config2);
      } else if ((0, graphql_1.isEnumType)(type2)) {
        const config2 = type2.toConfig();
        if (config2.astNode != null) {
          const values = [];
          for (const enumKey in config2.values) {
            const enumValueConfig = config2.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            values
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config2);
      } else {
        return type2;
      }
    }
    __name(correctASTNodes, "correctASTNodes");
    exports2.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = require_graphql2();
    var Interfaces_js_1 = require_Interfaces3();
    var mapSchema_js_1 = require_mapSchema3();
    function filterSchema({ schema, typeFilter = /* @__PURE__ */ __name(() => true, "typeFilter"), fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type2) => filterRootFields(type2, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type2) => filterRootFields(type2, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type2) => filterRootFields(type2, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLObjectType, type2, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLInterfaceType, type2, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type2) => typeFilter(type2.name, type2) ? filterElementFields(graphql_1.GraphQLInputObjectType, type2, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type2) => typeFilter(type2.name, type2) ? void 0 : null
      });
      return filteredSchema;
    }
    __name(filterSchema, "filterSchema");
    exports2.filterSchema = filterSchema;
    function filterRootFields(type2, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config2 = type2.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config2);
      }
      return type2;
    }
    __name(filterRootFields, "filterRootFields");
    function filterElementFields(ElementConstructor, type2, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config2 = type2.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (fieldFilter && !fieldFilter(type2.name, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type2.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config2);
      }
    }
    __name(filterElementFields, "filterElementFields");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = require_graphql2();
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    __name(healSchema, "healSchema");
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualName in actualNamedTypeMap) {
          throw new Error(`Duplicate schema type name ${actualName}`);
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type2) {
        if ((0, graphql_1.isObjectType)(type2)) {
          healFields(type2);
          healInterfaces(type2);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          healFields(type2);
          if ("getInterfaces" in type2) {
            healInterfaces(type2);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type2)) {
          healUnderlyingTypes(type2);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          healInputFields(type2);
          return;
        } else if ((0, graphql_1.isLeafType)(type2)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type2}`);
      }
      __name(healNamedType, "healNamedType");
      function healFields(type2) {
        const fieldMap = type2.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      __name(healFields, "healFields");
      function healInterfaces(type2) {
        if ("getInterfaces" in type2) {
          const interfaces = type2.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      __name(healInterfaces, "healInterfaces");
      function healInputFields(type2) {
        const fieldMap = type2.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      __name(healInputFields, "healInputFields");
      function healUnderlyingTypes(type2) {
        const types3 = type2.getTypes();
        types3.push(...types3.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      __name(healUnderlyingTypes, "healUnderlyingTypes");
      function healType(type2) {
        if ((0, graphql_1.isListType)(type2)) {
          const healedType = healType(type2.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type2)) {
          const healedType = healType(type2.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type2)) {
          const officialType = originalTypeMap[type2.name];
          if (officialType && type2 !== officialType) {
            return officialType;
          }
        }
        return type2;
      }
      __name(healType, "healType");
    }
    __name(healTypes, "healTypes");
    exports2.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = require_graphql2();
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers2 = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type2 = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type2)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type2)) {
              const config2 = type2.toConfig();
              delete config2.astNode;
              resolvers2[typeName] = new graphql_1.GraphQLScalarType(config2);
            }
          } else if ((0, graphql_1.isEnumType)(type2)) {
            resolvers2[typeName] = {};
            const values = type2.getValues();
            for (const value of values) {
              resolvers2[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type2)) {
            if (type2.resolveType != null) {
              resolvers2[typeName] = {
                __resolveType: type2.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type2)) {
            if (type2.resolveType != null) {
              resolvers2[typeName] = {
                __resolveType: type2.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type2)) {
            resolvers2[typeName] = {};
            if (type2.isTypeOf != null) {
              resolvers2[typeName].__isTypeOf = type2.isTypeOf;
            }
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers2[typeName][fieldName] = resolvers2[typeName][fieldName] || {};
                resolvers2[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers2[typeName][fieldName] = resolvers2[typeName][fieldName] || {};
                resolvers2[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers2;
    }
    __name(getResolversFromSchema, "getResolversFromSchema");
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = require_graphql2();
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type2).name.startsWith("__") && (0, graphql_1.isObjectType)(type2)) {
          const fields = type2.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    __name(forEachField, "forEachField");
    exports2.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = require_graphql2();
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type2 = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type2).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type2)) {
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type2)) {
            const fields = type2.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    __name(forEachDefaultValue, "forEachDefaultValue");
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = require_graphql2();
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap3();
    var rewire_js_1 = require_rewire3();
    function addTypes(schema, newTypesOrDirectives) {
      const config2 = schema.toConfig();
      const originalTypeMap = {};
      for (const type2 of config2.types) {
        originalTypeMap[type2.name] = type2;
      }
      const originalDirectiveMap = {};
      for (const directive of config2.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config2,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    __name(addTypes, "addTypes");
    exports2.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = require_graphql2();
    var mapSchema_js_1 = require_mapSchema3();
    var Interfaces_js_1 = require_Interfaces3();
    var rootTypes_js_1 = require_rootTypes3();
    var get_implementing_types_js_1 = require_get_implementing_types3();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type2 = prunedSchema.getType(typeName);
            if (type2 && skipPruning(type2)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type2) => {
            if (!visited.has(type2.name) && !(0, graphql_1.isSpecifiedScalarType)(type2)) {
              if ((0, graphql_1.isUnionType)(type2) || (0, graphql_1.isInputObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2) || (0, graphql_1.isObjectType)(type2) || (0, graphql_1.isScalarType)(type2)) {
                if (skipUnusedTypesPruning) {
                  return type2;
                }
                if ((0, graphql_1.isUnionType)(type2) && skipEmptyUnionPruning && !Object.keys(type2.getTypes()).length) {
                  return type2;
                }
                if ((0, graphql_1.isInputObjectType)(type2) || (0, graphql_1.isInterfaceType)(type2) || (0, graphql_1.isObjectType)(type2)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type2.getFields()).length) {
                    return type2;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type2) && skipUnimplementedInterfacesPruning) {
                  return type2;
                }
              }
              prunedTypes.push(type2.name);
              visited.delete(type2.name);
              return null;
            }
            return type2;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    __name(pruneSchema, "pruneSchema");
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type2 of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type2.name);
      }
      return visitQueue(queue, schema);
    }
    __name(visitSchema, "visitSchema");
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type2 = schema.getType(typeName);
        if (type2) {
          if ((0, graphql_1.isUnionType)(type2)) {
            queue.push(...type2.getTypes().map((type3) => type3.name));
          }
          if ((0, graphql_1.isInterfaceType)(type2) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type2.name, schema));
            revisit[typeName] = false;
          }
          if ("getInterfaces" in type2) {
            queue.push(...type2.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type2) {
            const fields = type2.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type2)) {
                queue.push(...field.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
    __name(visitQueue, "visitQueue");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers3();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject2(target) && isObject2(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject2(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    __name(mergeDeep, "mergeDeep");
    exports2.mergeDeep = mergeDeep;
    function isObject2(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
    __name(isObject2, "isObject");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = require_graphql2();
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    __name(parseSelectionSet, "parseSelectionSet");
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info3) {
      return info3.fieldNodes[0].alias != null ? info3.fieldNodes[0].alias.value : info3.fieldName;
    }
    __name(getResponseKeyFromInfo, "getResponseKeyFromInfo");
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = require_graphql2();
    var Interfaces_js_1 = require_Interfaces3();
    var mapSchema_js_1 = require_mapSchema3();
    var addTypes_js_1 = require_addTypes3();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    __name(appendObjectFields, "appendObjectFields");
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    __name(removeObjectFields, "removeObjectFields");
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    __name(selectObjectFields, "selectObjectFields");
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type2) => {
          if (type2.name === typeName) {
            const config2 = type2.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    __name(modifyObjectFields, "modifyObjectFields");
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = require_graphql2();
    function renameType(type2, newTypeName) {
      if ((0, graphql_1.isObjectType)(type2)) {
        return new graphql_1.GraphQLObjectType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type2)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type2)) {
        return new graphql_1.GraphQLUnionType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type2)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type2)) {
        return new graphql_1.GraphQLEnumType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type2)) {
        return new graphql_1.GraphQLScalarType({
          ...type2.toConfig(),
          name: newTypeName,
          astNode: type2.astNode == null ? type2.astNode : {
            ...type2.astNode,
            name: {
              ...type2.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type2.extensionASTNodes == null ? type2.extensionASTNodes : type2.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type2}.`);
    }
    __name(renameType, "renameType");
    exports2.renameType = renameType;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = /* @__PURE__ */ __name((error3) => {
          const rethrow = /* @__PURE__ */ __name(() => Promise.reject(error3), "rethrow");
          return $return.call(iterator).then(rethrow, rethrow);
        }, "abruptClose");
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      __name(mapResult, "mapResult");
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = /* @__PURE__ */ __name((error3) => asyncMapValue(error3, reject).then(iteratorResult, abruptClose), "mapReject");
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error3) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error3).then(mapResult, mapReject);
          }
          return Promise.reject(error3).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(mapAsyncIterator, "mapAsyncIterator");
    exports2.mapAsyncIterator = mapAsyncIterator;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    __name(asyncMapValue, "asyncMapValue");
    function iteratorResult(value) {
      return { value, done: false };
    }
    __name(iteratorResult, "iteratorResult");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = require_graphql2();
    var astFromType_js_1 = require_astFromType3();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type2, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type2)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    __name(updateArgument, "updateArgument");
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    __name(createVariableNameGenerator, "createVariableNameGenerator");
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = require_graphql2();
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    __name(implementsAbstractType, "implementsAbstractType");
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = /* @__PURE__ */ __name((value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      }, "pushValue");
      const pushError = /* @__PURE__ */ __name((error3) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error3] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error3] }, done: false });
        }
      }, "pushError");
      const pushDone = /* @__PURE__ */ __name(() => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      }, "pushDone");
      const pullValue = /* @__PURE__ */ __name(() => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      }), "pullValue");
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = /* @__PURE__ */ __name(() => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      }, "emptyQueue");
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error3) {
          emptyQueue();
          return Promise.reject(error3);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(observableToAsyncIterable, "observableToAsyncIterable");
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = require_graphql2();
    var memoize_js_1 = require_memoize4();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    __name(getOperationASTFromDocument, "getOperationASTFromDocument");
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(/* @__PURE__ */ __name(function getOperationASTFromRequest(request2) {
      return getOperationASTFromDocument(request2.document, request2.operationName);
    }, "getOperationASTFromRequest"));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize4();
    var graphql_1 = require_graphql2();
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    __name(collectFields, "collectFields");
    exports2.collectFields = collectFields;
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    __name(shouldIncludeNode, "shouldIncludeNode");
    function doesFragmentConditionMatch(schema, fragment, type2) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type2) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type2);
      }
      return false;
    }
    __name(doesFragmentConditionMatch, "doesFragmentConditionMatch");
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    __name(getFieldEntryKey, "getFieldEntryKey");
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(/* @__PURE__ */ __name(function collectSubFields(schema, fragments, variableValues, type2, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const fieldNode of fieldNodes) {
        if (fieldNode.selectionSet) {
          collectFields(schema, fragments, variableValues, type2, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    }, "collectSubFields"));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest3();
    var graphql_1 = require_graphql2();
    var collectFields_js_1 = require_collectFields4();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    __name(visitData, "visitData");
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error3) => visitor(error3));
    }
    __name(visitErrors, "visitErrors");
    exports2.visitErrors = visitErrors;
    function visitResult(result, request2, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request2.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request2.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request2);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    __name(visitResult, "visitResult");
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    __name(visitErrorsByType, "visitErrorsByType");
    function getOperationRootType(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    __name(getOperationRootType, "getOperationRootType");
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType(schema, operation);
      const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    __name(visitRoot, "visitRoot");
    function visitObjectValue(object, type2, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type2.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type2.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error3 of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error3);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type2, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error3 of errors2) {
            errorInfo.unpathedErrors.add(error3);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    __name(visitObjectValue, "visitObjectValue");
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    __name(updateObject, "updateObject");
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    __name(visitListValue, "visitListValue");
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    __name(visitFieldValue, "visitFieldValue");
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error3 of errors) {
        const pathSegment = (_a = error3.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error3);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error3);
        } else {
          errorMap[pathSegment] = [error3];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    __name(sortErrorsByPathSegment, "sortErrorsByPathSegment");
    function addPathSegmentInfo(type2, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error3 of errors) {
        const segmentInfo = {
          type: type2,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error3);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error3, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
    __name(addPathSegmentInfo, "addPathSegmentInfo");
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    __name(valueMatchesCriteria, "valueMatchesCriteria");
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    __name(isAsyncIterable, "isAsyncIterable");
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = require_graphql2();
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    __name(isDocumentNode, "isDocumentNode");
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize4();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    __name(defaultAsyncIteratorReturn, "defaultAsyncIteratorReturn");
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(/* @__PURE__ */ __name(function proxyMethodFactory2(target, targetMethod) {
      return /* @__PURE__ */ __name(function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      }, "proxyMethod");
    }, "proxyMethodFactory"));
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return /* @__PURE__ */ __name(async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            }, "returnWithCancel");
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    __name(getAsyncIteratorWithCancel, "getAsyncIteratorWithCancel");
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return /* @__PURE__ */ __name(function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            }, "asyncIteratorFactory");
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    __name(getAsyncIterableWithCancel, "getAsyncIterableWithCancel");
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = require_graphql2();
    var print_schema_with_directives_js_1 = require_print_schema_with_directives3();
    function buildFixedSchema(schema, options) {
      const document = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document, {
        ...options || {}
      });
    }
    __name(buildFixedSchema, "buildFixedSchema");
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    __name(fixSchemaAst, "fixSchemaAst");
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_loaders3(), exports2);
    tslib_1.__exportStar(require_helpers3(), exports2);
    tslib_1.__exportStar(require_get_directives3(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives3(), exports2);
    tslib_1.__exportStar(require_get_implementing_types3(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives3(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives3(), exports2);
    tslib_1.__exportStar(require_validate_documents3(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json3(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl3(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field3(), exports2);
    tslib_1.__exportStar(require_types5(), exports2);
    tslib_1.__exportStar(require_filterSchema3(), exports2);
    tslib_1.__exportStar(require_heal3(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema3(), exports2);
    tslib_1.__exportStar(require_forEachField3(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue3(), exports2);
    tslib_1.__exportStar(require_mapSchema3(), exports2);
    tslib_1.__exportStar(require_addTypes3(), exports2);
    tslib_1.__exportStar(require_rewire3(), exports2);
    tslib_1.__exportStar(require_prune3(), exports2);
    tslib_1.__exportStar(require_mergeDeep3(), exports2);
    tslib_1.__exportStar(require_Interfaces3(), exports2);
    tslib_1.__exportStar(require_stub3(), exports2);
    tslib_1.__exportStar(require_selectionSets3(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo3(), exports2);
    tslib_1.__exportStar(require_fields4(), exports2);
    tslib_1.__exportStar(require_renameType3(), exports2);
    tslib_1.__exportStar(require_transformInputValue3(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator4(), exports2);
    tslib_1.__exportStar(require_updateArgument3(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType3(), exports2);
    tslib_1.__exportStar(require_errors3(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable3(), exports2);
    tslib_1.__exportStar(require_visitResult3(), exports2);
    tslib_1.__exportStar(require_getArgumentValues3(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria3(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable4(), exports2);
    tslib_1.__exportStar(require_isDocumentNode3(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped3(), exports2);
    tslib_1.__exportStar(require_executor3(), exports2);
    tslib_1.__exportStar(require_withCancel3(), exports2);
    tslib_1.__exportStar(require_AggregateError3(), exports2);
    tslib_1.__exportStar(require_rootTypes3(), exports2);
    tslib_1.__exportStar(require_comments3(), exports2);
    tslib_1.__exportStar(require_collectFields4(), exports2);
    tslib_1.__exportStar(require_inspect4(), exports2);
    tslib_1.__exportStar(require_memoize4(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst3(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest3(), exports2);
  }
});

// node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeResolvers = void 0;
    var utils_1 = require_cjs6();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers2 = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers2.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers2, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    __name(mergeResolvers, "mergeResolvers");
    exports2.mergeResolvers = mergeResolvers;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeArguments = void 0;
    var utils_1 = require_cjs6();
    function mergeArguments(args1, args2, config2) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome));
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    __name(mergeArguments, "mergeArguments");
    exports2.mergeArguments = mergeArguments;
    function deduplicateArguments(args) {
      return args.reduce((acc, current) => {
        const dup = acc.find((arg) => arg.name.value === current.name.value);
        if (!dup) {
          return acc.concat([current]);
        }
        return acc;
      }, []);
    }
    __name(deduplicateArguments, "deduplicateArguments");
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives4 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDirective = exports2.mergeDirectives = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs6();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    __name(directiveAlreadyExists, "directiveAlreadyExists");
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    __name(nameAlreadyExists, "nameAlreadyExists");
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    __name(mergeArguments, "mergeArguments");
    function deduplicateDirectives(directives) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    __name(deduplicateDirectives, "deduplicateDirectives");
    function mergeDirectives(d1 = [], d2 = [], config2) {
      const reverseOrder = config2 && config2.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext]);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    __name(mergeDirectives, "mergeDirectives");
    exports2.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    __name(validateInputs, "validateInputs");
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    __name(mergeDirective, "mergeDirective");
    exports2.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
    __name(deduplicateLists, "deduplicateLists");
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnumValues = void 0;
    var directives_js_1 = require_directives4();
    var utils_1 = require_cjs6();
    function mergeEnumValues(first, second, config2) {
      if (config2 === null || config2 === void 0 ? void 0 : config2.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    __name(mergeEnumValues, "mergeEnumValues");
    exports2.mergeEnumValues = mergeEnumValues;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnum = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives4();
    var enum_values_js_1 = require_enum_values2();
    function mergeEnum(e1, e2, config2) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config2),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    __name(mergeEnum, "mergeEnum");
    exports2.mergeEnum = mergeEnum;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils4 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
    var graphql_1 = require_graphql2();
    function isStringTypes(types3) {
      return typeof types3 === "string";
    }
    __name(isStringTypes, "isStringTypes");
    exports2.isStringTypes = isStringTypes;
    function isSourceTypes(types3) {
      return types3 instanceof graphql_1.Source;
    }
    __name(isSourceTypes, "isSourceTypes");
    exports2.isSourceTypes = isSourceTypes;
    function extractType(type2) {
      let visitedType = type2;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    __name(extractType, "extractType");
    exports2.extractType = extractType;
    function isWrappingTypeNode(type2) {
      return type2.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    __name(isWrappingTypeNode, "isWrappingTypeNode");
    exports2.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type2) {
      return type2.kind === graphql_1.Kind.LIST_TYPE;
    }
    __name(isListTypeNode, "isListTypeNode");
    exports2.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type2) {
      return type2.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    __name(isNonNullTypeNode, "isNonNullTypeNode");
    exports2.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type2) {
      if (isListTypeNode(type2)) {
        return `[${printTypeNode(type2.type)}]`;
      }
      if (isNonNullTypeNode(type2)) {
        return `${printTypeNode(type2.type)}!`;
      }
      return type2.name.value;
    }
    __name(printTypeNode, "printTypeNode");
    exports2.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    __name(defaultStringComparator, "defaultStringComparator");
    exports2.defaultStringComparator = defaultStringComparator;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields5 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeFields = void 0;
    var utils_js_1 = require_utils4();
    var directives_js_1 = require_directives4();
    var utils_1 = require_cjs6();
    var arguments_js_1 = require_arguments2();
    function fieldAlreadyExists(fieldsArr, otherField, config2) {
      const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
      if (result && !(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
        const t1 = (0, utils_js_1.extractType)(result.type);
        const t2 = (0, utils_js_1.extractType)(otherField.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
      }
      return !!result;
    }
    __name(fieldAlreadyExists, "fieldAlreadyExists");
    function mergeFields(type2, f1, f2, config2) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          if (fieldAlreadyExists(result, field, config2)) {
            const existing = result.find((f) => f.name.value === field.name.value);
            if (!(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
              if (config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict) {
                preventConflicts(type2, existing, field, false);
              } else {
                preventConflicts(type2, existing, field, true);
              }
              if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {
                existing.type = field.type;
              }
            }
            existing.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing.arguments || [], config2);
            existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config2);
            existing.description = field.description || existing.description;
          } else {
            result.push(field);
          }
        }
      }
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config2 && config2.exclusions) {
        const exclusions = config2.exclusions;
        return result.filter((field) => !exclusions.includes(`${type2.name.value}.${field.name.value}`));
      }
      return result;
    }
    __name(mergeFields, "mergeFields");
    exports2.mergeFields = mergeFields;
    function preventConflicts(type2, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
        throw new Error(`Field '${type2.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
      }
    }
    __name(preventConflicts, "preventConflicts");
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
    __name(safeChangeForFieldType, "safeChangeForFieldType");
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInputType = void 0;
    var graphql_1 = require_graphql2();
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives4();
    function mergeInputType(node, existingNode, config2) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    __name(mergeInputType, "mergeInputType");
    exports2.mergeInputType = mergeInputType;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInterface = void 0;
    var graphql_1 = require_graphql2();
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives4();
    var index_js_1 = require_typedefs_mergers2();
    function mergeInterface(node, existingNode, config2) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2),
            interfaces: node["interfaces"] ? (0, index_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config2) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    __name(mergeInterface, "mergeInterface");
    exports2.mergeInterface = mergeInterface;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs6();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    __name(alreadyExists, "alreadyExists");
    function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    __name(mergeNamedTypeArray, "mergeNamedTypeArray");
    exports2.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type3 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeType = void 0;
    var graphql_1 = require_graphql2();
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives4();
    var merge_named_type_array_js_1 = require_merge_named_type_array2();
    function mergeType(node, existingNode, config2) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config2)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    __name(mergeType, "mergeType");
    exports2.mergeType = mergeType;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScalar = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives4();
    function mergeScalar(node, existingNode, config2) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    __name(mergeScalar, "mergeScalar");
    exports2.mergeScalar = mergeScalar;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeUnion = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives4();
    var merge_named_type_array_js_1 = require_merge_named_type_array2();
    function mergeUnion(first, second, config2) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config2),
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    __name(mergeUnion, "mergeUnion");
    exports2.mergeUnion = mergeUnion;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = require_graphql2();
    var directives_js_1 = require_directives4();
    exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    __name(mergeOperationTypes, "mergeOperationTypes");
    function mergeSchemaDefs(node, existingNode, config2) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    __name(mergeSchemaDefs, "mergeSchemaDefs");
    exports2.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
    var graphql_1 = require_graphql2();
    var type_js_1 = require_type3();
    var enum_js_1 = require_enum2();
    var scalar_js_1 = require_scalar2();
    var union_js_1 = require_union2();
    var input_type_js_1 = require_input_type2();
    var interface_js_1 = require_interface2();
    var directives_js_1 = require_directives4();
    var schema_def_js_1 = require_schema_def2();
    var utils_1 = require_cjs6();
    exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    __name(isNamedDefinitionNode, "isNamedDefinitionNode");
    exports2.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config2) {
      var _a, _b, _c;
      const mergedResultMap = {};
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config2);
        }
      }
      return mergedResultMap;
    }
    __name(mergeGraphQLNodes, "mergeGraphQLNodes");
    exports2.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
    var graphql_1 = require_graphql2();
    var utils_js_1 = require_utils4();
    var merge_nodes_js_1 = require_merge_nodes2();
    var utils_1 = require_cjs6();
    var schema_def_js_1 = require_schema_def2();
    function mergeTypeDefs(typeSource, config2) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config2
        })
      };
      let result;
      if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    __name(mergeTypeDefs, "mergeTypeDefs");
    exports2.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type2 of typeSource) {
            visitTypeSources(type2, options, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          allNodes.push(typeSource);
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return allNodes;
    }
    __name(visitTypeSources, "visitTypeSources");
    function mergeGraphQLTypes(typeSource, config2) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const allNodes = visitTypeSources(typeSource, config2);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config2);
      if (config2 === null || config2 === void 0 ? void 0 : config2.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config2 === null || config2 === void 0 ? void 0 : config2.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config2 === null || config2 === void 0 ? void 0 : config2.sort) {
        const sortFn = typeof config2.sort === "function" ? config2.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    __name(mergeGraphQLTypes, "mergeGraphQLTypes");
    exports2.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_arguments2(), exports2);
    tslib_1.__exportStar(require_directives4(), exports2);
    tslib_1.__exportStar(require_enum_values2(), exports2);
    tslib_1.__exportStar(require_enum2(), exports2);
    tslib_1.__exportStar(require_fields5(), exports2);
    tslib_1.__exportStar(require_input_type2(), exports2);
    tslib_1.__exportStar(require_interface2(), exports2);
    tslib_1.__exportStar(require_merge_named_type_array2(), exports2);
    tslib_1.__exportStar(require_merge_nodes2(), exports2);
    tslib_1.__exportStar(require_merge_typedefs2(), exports2);
    tslib_1.__exportStar(require_scalar2(), exports2);
    tslib_1.__exportStar(require_type3(), exports2);
    tslib_1.__exportStar(require_union2(), exports2);
    tslib_1.__exportStar(require_utils4(), exports2);
  }
});

// node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = exports2.applyExtensions = exports2.mergeExtensions = exports2.travelSchemaPossibleExtensions = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs6();
    function travelSchemaPossibleExtensions(schema, hooks) {
      hooks.onSchema(schema);
      const typesMap = schema.getTypeMap();
      for (const [, type2] of Object.entries(typesMap)) {
        const isPredefinedScalar = (0, graphql_1.isScalarType)(type2) && (0, graphql_1.isSpecifiedScalarType)(type2);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type2);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type2)) {
          hooks.onObjectType(type2);
          const fields = type2.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onObjectField(type2, field);
            const args = field.args || [];
            for (const arg of args) {
              hooks.onObjectFieldArg(type2, field, arg);
            }
          }
        } else if ((0, graphql_1.isInterfaceType)(type2)) {
          hooks.onInterface(type2);
          const fields = type2.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onInterfaceField(type2, field);
            const args = field.args || [];
            for (const arg of args) {
              hooks.onInterfaceFieldArg(type2, field, arg);
            }
          }
        } else if ((0, graphql_1.isInputObjectType)(type2)) {
          hooks.onInputType(type2);
          const fields = type2.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onInputFieldType(type2, field);
          }
        } else if ((0, graphql_1.isUnionType)(type2)) {
          hooks.onUnion(type2);
        } else if ((0, graphql_1.isScalarType)(type2)) {
          hooks.onScalar(type2);
        } else if ((0, graphql_1.isEnumType)(type2)) {
          hooks.onEnum(type2);
          for (const value of type2.getValues()) {
            hooks.onEnumValue(type2, value);
          }
        }
      }
    }
    __name(travelSchemaPossibleExtensions, "travelSchemaPossibleExtensions");
    exports2.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    __name(mergeExtensions, "mergeExtensions");
    exports2.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    __name(applyExtensionObject, "applyExtensionObject");
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type2 = schema.getType(typeName);
        if (type2) {
          applyExtensionObject(type2, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type2.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type2.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type2.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    __name(applyExtensions, "applyExtensions");
    exports2.applyExtensions = applyExtensions;
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: {},
        types: {}
      };
      travelSchemaPossibleExtensions(schema, {
        onSchema: /* @__PURE__ */ __name((schema2) => result.schemaExtensions = schema2.extensions || {}, "onSchema"),
        onObjectType: /* @__PURE__ */ __name((type2) => result.types[type2.name] = { fields: {}, type: "object", extensions: type2.extensions || {} }, "onObjectType"),
        onObjectField: /* @__PURE__ */ __name((type2, field) => result.types[type2.name].fields[field.name] = {
          arguments: {},
          extensions: field.extensions || {}
        }, "onObjectField"),
        onObjectFieldArg: /* @__PURE__ */ __name((type2, field, arg) => result.types[type2.name].fields[field.name].arguments[arg.name] = arg.extensions || {}, "onObjectFieldArg"),
        onInterface: /* @__PURE__ */ __name((type2) => result.types[type2.name] = { fields: {}, type: "interface", extensions: type2.extensions || {} }, "onInterface"),
        onInterfaceField: /* @__PURE__ */ __name((type2, field) => result.types[type2.name].fields[field.name] = {
          arguments: {},
          extensions: field.extensions || {}
        }, "onInterfaceField"),
        onInterfaceFieldArg: /* @__PURE__ */ __name((type2, field, arg) => result.types[type2.name].fields[field.name].arguments[arg.name] = arg.extensions || {}, "onInterfaceFieldArg"),
        onEnum: /* @__PURE__ */ __name((type2) => result.types[type2.name] = { values: {}, type: "enum", extensions: type2.extensions || {} }, "onEnum"),
        onEnumValue: /* @__PURE__ */ __name((type2, value) => result.types[type2.name].values[value.name] = value.extensions || {}, "onEnumValue"),
        onScalar: /* @__PURE__ */ __name((type2) => result.types[type2.name] = { type: "scalar", extensions: type2.extensions || {} }, "onScalar"),
        onUnion: /* @__PURE__ */ __name((type2) => result.types[type2.name] = { type: "union", extensions: type2.extensions || {} }, "onUnion"),
        onInputType: /* @__PURE__ */ __name((type2) => result.types[type2.name] = { fields: {}, type: "input", extensions: type2.extensions || {} }, "onInputType"),
        onInputFieldType: /* @__PURE__ */ __name((type2, field) => result.types[type2.name].fields[field.name] = { extensions: field.extensions || {} }, "onInputFieldType")
      });
      return result;
    }
    __name(extractExtensionsFromSchema, "extractExtensionsFromSchema");
    exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_merge_resolvers2(), exports2);
    tslib_1.__exportStar(require_typedefs_mergers2(), exports2);
    tslib_1.__exportStar(require_extensions2(), exports2);
  }
});

// node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeExecutableSchema = void 0;
    var graphql_1 = require_graphql2();
    var utils_1 = require_cjs5();
    var addResolversToSchema_js_1 = require_addResolversToSchema2();
    var assertResolversPresent_js_1 = require_assertResolversPresent2();
    var merge_1 = require_cjs7();
    function makeExecutableSchema({ typeDefs: typeDefs2, resolvers: resolvers2 = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs2) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs2)) {
        schema = typeDefs2;
      } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs2, {
          ...parseOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, parseOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs2, parseOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, parseOptions);
      }
      if (pruningOptions) {
        schema = (0, utils_1.pruneSchema)(schema);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers2),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    __name(makeExecutableSchema, "makeExecutableSchema");
    exports2.makeExecutableSchema = makeExecutableSchema;
  }
});

// node_modules/@graphql-tools/schema/cjs/types.js
var require_types6 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemas = void 0;
    var merge_1 = require_cjs7();
    var utils_1 = require_cjs5();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema2();
    function mergeSchemas(config2) {
      const extractedTypeDefs = (0, utils_1.asArray)(config2.typeDefs || []);
      const extractedResolvers = (0, utils_1.asArray)(config2.resolvers || []);
      const extractedSchemaExtensions = (0, utils_1.asArray)(config2.schemaExtensions || []);
      const schemas = config2.schemas || [];
      for (const schema of schemas) {
        extractedTypeDefs.push(schema);
        extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema, true));
        extractedSchemaExtensions.push((0, merge_1.extractExtensionsFromSchema)(schema));
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        parseOptions: config2,
        ...config2,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    __name(mergeSchemas, "mergeSchemas");
    exports2.mergeSchemas = mergeSchemas;
  }
});

// node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = exports2.checkForResolveTypeResolver = exports2.addResolversToSchema = exports2.chainResolvers = exports2.assertResolversPresent = void 0;
    var tslib_1 = require_tslib();
    var assertResolversPresent_js_1 = require_assertResolversPresent2();
    Object.defineProperty(exports2, "assertResolversPresent", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    }, "get") });
    var chainResolvers_js_1 = require_chainResolvers2();
    Object.defineProperty(exports2, "chainResolvers", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return chainResolvers_js_1.chainResolvers;
    }, "get") });
    var addResolversToSchema_js_1 = require_addResolversToSchema2();
    Object.defineProperty(exports2, "addResolversToSchema", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    }, "get") });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver2();
    Object.defineProperty(exports2, "checkForResolveTypeResolver", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    }, "get") });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces2();
    Object.defineProperty(exports2, "extendResolversFromInterfaces", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    }, "get") });
    tslib_1.__exportStar(require_makeExecutableSchema2(), exports2);
    tslib_1.__exportStar(require_types6(), exports2);
    tslib_1.__exportStar(require_merge_schemas2(), exports2);
  }
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports2, function() {
      "use strict";
      var noop = /* @__PURE__ */ __name(function() {
      }, "noop");
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      __name(bindMethod, "bindMethod");
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      __name(traceForIE, "traceForIE");
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      __name(realMethod, "realMethod");
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      __name(replaceLoggingMethods, "replaceLoggingMethods");
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      __name(enableLoggingWhenConsoleArrives, "enableLoggingWhenConsoleArrives");
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      __name(defaultMethodFactory, "defaultMethodFactory");
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        __name(persistLevelIfPossible, "persistLevelIfPossible");
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        __name(getPersistedLevel, "getPersistedLevel");
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        __name(clearPersistedLevel, "clearPersistedLevel");
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        __name(normalizeLevel, "normalizeLevel");
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      __name(Logger, "Logger");
      defaultLogger = new Logger();
      defaultLogger.getLogger = /* @__PURE__ */ __name(function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger;
      }, "getLogger");
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = /* @__PURE__ */ __name(function getLoggers() {
        return _loggersByName;
      }, "getLoggers");
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/@josephg/resolvable/index.js
var require_resolvable = __commonJS({
  "node_modules/@josephg/resolvable/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolvablePromise = /* @__PURE__ */ __name(() => {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      promise.resolve = resolve;
      promise.reject = reject;
      return promise;
    }, "resolvablePromise");
    exports2.default = resolvablePromise;
    module2.exports = resolvablePromise;
  }
});

// node_modules/apollo-server-core/dist/utils/schemaHash.js
var require_schemaHash = __commonJS({
  "node_modules/apollo-server-core/dist/utils/schemaHash.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateSchemaHash = void 0;
    var language_1 = require_language();
    var execution_1 = require_execution();
    var utilities_1 = require_utilities();
    var fast_json_stable_stringify_1 = __importDefault(require_fast_json_stable_stringify());
    var createSHA_1 = __importDefault(require_createSHA());
    function generateSchemaHash(schema) {
      const introspectionQuery = (0, utilities_1.getIntrospectionQuery)();
      const document = (0, language_1.parse)(introspectionQuery);
      const result = (0, execution_1.execute)({
        schema,
        document
      });
      if (result && typeof result.then === "function") {
        throw new Error([
          "The introspection query is resolving asynchronously; execution of an introspection query is not expected to return a `Promise`.",
          "",
          "Wrapped type resolvers should maintain the existing execution dynamics of the resolvers they wrap (i.e. async vs sync) or introspection types should be excluded from wrapping by checking them with `graphql/type`s, `isIntrospectionType` predicate function prior to wrapping."
        ].join("\n"));
      }
      if (!result || !result.data || !result.data.__schema) {
        throw new Error("Unable to generate server introspection document.");
      }
      const introspectionSchema = result.data.__schema;
      const stringifiedSchema = (0, fast_json_stable_stringify_1.default)(introspectionSchema);
      return (0, createSHA_1.default)("sha512").update(stringifiedSchema).digest("hex");
    }
    __name(generateSchemaHash, "generateSchemaHash");
    exports2.generateSchemaHash = generateSchemaHash;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js
var require_invariant2 = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.invariant = void 0;
    function invariant(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    __name(invariant, "invariant");
    exports2.invariant = invariant;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js
var require_predicates2 = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNotNullOrUndefined = void 0;
    function isNotNullOrUndefined(value) {
      return value !== null && typeof value !== "undefined";
    }
    __name(isNotNullOrUndefined, "isNotNullOrUndefined");
    exports2.isNotNullOrUndefined = isNotNullOrUndefined;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js
var require_graphql3 = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = exports2.isNode = void 0;
    var graphql_1 = require_graphql2();
    function isNode(maybeNode) {
      return maybeNode && typeof maybeNode.kind === "string";
    }
    __name(isNode, "isNode");
    exports2.isNode = isNode;
    function isDocumentNode(node) {
      return isNode(node) && node.kind === graphql_1.Kind.DOCUMENT;
    }
    __name(isDocumentNode, "isDocumentNode");
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/index.js
var require_utilities2 = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_invariant2(), exports2);
    __exportStar(require_predicates2(), exports2);
    __exportStar(require_graphql3(), exports2);
  }
});

// node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js
var require_resolverMap = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js
var require_resolveObject = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@apollographql/apollo-tools/lib/schema/index.js
var require_schema2 = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/schema/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_resolverMap(), exports2);
    __exportStar(require_resolveObject(), exports2);
  }
});

// node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js
var require_buildServiceDefinition = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildServiceDefinition = void 0;
    var graphql_1 = require_graphql2();
    var graphql_2 = require_graphql3();
    var predicates_1 = require_predicates2();
    function flattened(arr) {
      return new Array().concat(...arr);
    }
    __name(flattened, "flattened");
    function buildServiceDefinition(modules) {
      const errors = [];
      const typeDefinitionsMap = /* @__PURE__ */ Object.create(null);
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directivesMap = /* @__PURE__ */ Object.create(null);
      const schemaDefinitions = [];
      const schemaExtensions = [];
      for (let module3 of modules) {
        if ((0, graphql_2.isNode)(module3) && (0, graphql_2.isDocumentNode)(module3)) {
          module3 = { typeDefs: module3 };
        }
        for (const definition of module3.typeDefs.definitions) {
          if ((0, graphql_1.isTypeDefinitionNode)(definition)) {
            const typeName = definition.name.value;
            if (typeDefinitionsMap[typeName]) {
              typeDefinitionsMap[typeName].push(definition);
            } else {
              typeDefinitionsMap[typeName] = [definition];
            }
          } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {
            const typeName = definition.name.value;
            if (typeExtensionsMap[typeName]) {
              typeExtensionsMap[typeName].push(definition);
            } else {
              typeExtensionsMap[typeName] = [definition];
            }
          } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
            const directiveName = definition.name.value;
            if (directivesMap[directiveName]) {
              directivesMap[directiveName].push(definition);
            } else {
              directivesMap[directiveName] = [definition];
            }
          } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {
            schemaDefinitions.push(definition);
          } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(definition);
          }
        }
      }
      for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {
        if (typeDefinitions.length > 1) {
          errors.push(new graphql_1.GraphQLError(`Type "${typeName}" was defined more than once.`, typeDefinitions));
        }
      }
      for (const [directiveName, directives] of Object.entries(directivesMap)) {
        if (directives.length > 1) {
          errors.push(new graphql_1.GraphQLError(`Directive "${directiveName}" was defined more than once.`, directives));
        }
      }
      let operationTypeMap;
      if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {
        operationTypeMap = {};
        const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];
        const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map((node) => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));
        for (const operationType of operationTypes) {
          const typeName = operationType.type.name.value;
          const operation = operationType.operation;
          if (operationTypeMap[operation]) {
            throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);
          }
          if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {
            throw new graphql_1.GraphQLError(`Specified ${operation} type "${typeName}" not found in document.`, [schemaDefinition]);
          }
          operationTypeMap[operation] = typeName;
        }
      } else {
        operationTypeMap = {
          query: "Query",
          mutation: "Mutation",
          subscription: "Subscription"
        };
      }
      for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {
        if (!typeDefinitionsMap[typeName]) {
          if (Object.values(operationTypeMap).includes(typeName)) {
            typeDefinitionsMap[typeName] = [
              {
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: typeName
                }
              }
            ];
          } else {
            errors.push(new graphql_1.GraphQLError(`Cannot extend type "${typeName}" because it does not exist in the existing schema.`, typeExtensions));
          }
        }
      }
      if (errors.length > 0) {
        return { errors };
      }
      try {
        const typeDefinitions = flattened(Object.values(typeDefinitionsMap));
        const directives = flattened(Object.values(directivesMap));
        let schema = (0, graphql_1.buildASTSchema)({
          kind: graphql_1.Kind.DOCUMENT,
          definitions: [...typeDefinitions, ...directives]
        });
        const typeExtensions = flattened(Object.values(typeExtensionsMap));
        if (typeExtensions.length > 0) {
          schema = (0, graphql_1.extendSchema)(schema, {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: typeExtensions
          });
        }
        for (const module3 of modules) {
          if ("kind" in module3 || !module3.resolvers)
            continue;
          addResolversToSchema(schema, module3.resolvers);
        }
        return { schema };
      } catch (error3) {
        return { errors: [error3] };
      }
    }
    __name(buildServiceDefinition, "buildServiceDefinition");
    exports2.buildServiceDefinition = buildServiceDefinition;
    function addResolversToSchema(schema, resolvers2) {
      for (const [typeName, fieldConfigs] of Object.entries(resolvers2)) {
        const type2 = schema.getType(typeName);
        if (!(0, graphql_1.isObjectType)(type2))
          continue;
        const fieldMap = type2.getFields();
        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {
          if (fieldName.startsWith("__")) {
            type2[fieldName.substring(2)] = fieldConfig;
            continue;
          }
          const field = fieldMap[fieldName];
          if (!field)
            continue;
          if (typeof fieldConfig === "function") {
            field.resolve = fieldConfig;
          } else {
            if (fieldConfig.resolve) {
              field.resolve = fieldConfig.resolve;
            }
            if (fieldConfig.subscribe) {
              field.subscribe = fieldConfig.subscribe;
            }
          }
        }
      }
    }
    __name(addResolversToSchema, "addResolversToSchema");
  }
});

// node_modules/@apollographql/apollo-tools/lib/index.js
var require_lib = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_utilities2(), exports2);
    __exportStar(require_schema2(), exports2);
    __exportStar(require_buildServiceDefinition(), exports2);
  }
});

// node_modules/apollo-server-core/dist/determineApolloConfig.js
var require_determineApolloConfig = __commonJS({
  "node_modules/apollo-server-core/dist/determineApolloConfig.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.determineApolloConfig = void 0;
    var createSHA_1 = __importDefault(require_createSHA());
    function determineApolloConfig(input, logger) {
      var _a, _b, _c;
      const apolloConfig = {};
      const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT } = process.env;
      if (input === null || input === void 0 ? void 0 : input.key) {
        apolloConfig.key = input.key.trim();
      } else if (APOLLO_KEY) {
        apolloConfig.key = APOLLO_KEY.trim();
      }
      if (((_a = input === null || input === void 0 ? void 0 : input.key) !== null && _a !== void 0 ? _a : APOLLO_KEY) !== apolloConfig.key) {
        logger.warn("The provided API key has unexpected leading or trailing whitespace. Apollo Server will trim the key value before use.");
      }
      if (apolloConfig.key) {
        assertValidHeaderValue(apolloConfig.key);
      }
      if (apolloConfig.key) {
        apolloConfig.keyHash = (0, createSHA_1.default)("sha512").update(apolloConfig.key).digest("hex");
      }
      if (input === null || input === void 0 ? void 0 : input.graphRef) {
        apolloConfig.graphRef = input.graphRef;
      } else if (APOLLO_GRAPH_REF) {
        apolloConfig.graphRef = APOLLO_GRAPH_REF;
      }
      const graphId = (_b = input === null || input === void 0 ? void 0 : input.graphId) !== null && _b !== void 0 ? _b : APOLLO_GRAPH_ID;
      const graphVariant = (_c = input === null || input === void 0 ? void 0 : input.graphVariant) !== null && _c !== void 0 ? _c : APOLLO_GRAPH_VARIANT;
      if (apolloConfig.graphRef) {
        if (graphId) {
          throw new Error("Cannot specify both graph ref and graph ID. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.");
        }
        if (graphVariant) {
          throw new Error("Cannot specify both graph ref and graph variant. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.");
        }
      } else if (graphId) {
        apolloConfig.graphRef = graphVariant ? `${graphId}@${graphVariant}` : graphId;
      }
      return apolloConfig;
    }
    __name(determineApolloConfig, "determineApolloConfig");
    exports2.determineApolloConfig = determineApolloConfig;
    function assertValidHeaderValue(value) {
      const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
      if (invalidHeaderCharRegex.test(value)) {
        const invalidChars = value.match(invalidHeaderCharRegex);
        throw new Error(`The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(", ")}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`);
      }
    }
    __name(assertValidHeaderValue, "assertValidHeaderValue");
  }
});

// node_modules/unenv/dist/runtime/node/internal/os/constants.mjs
var UV_UDP_REUSEADDR, dlopen2, errno, signals, priority;
var init_constants2 = __esm({
  "node_modules/unenv/dist/runtime/node/internal/os/constants.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_UDP_REUSEADDR = 4;
    dlopen2 = {
      RTLD_LAZY: 1,
      RTLD_NOW: 2,
      RTLD_GLOBAL: 256,
      RTLD_LOCAL: 0,
      RTLD_DEEPBIND: 8
    };
    errno = {
      E2BIG: 7,
      EACCES: 13,
      EADDRINUSE: 98,
      EADDRNOTAVAIL: 99,
      EAFNOSUPPORT: 97,
      EAGAIN: 11,
      EALREADY: 114,
      EBADF: 9,
      EBADMSG: 74,
      EBUSY: 16,
      ECANCELED: 125,
      ECHILD: 10,
      ECONNABORTED: 103,
      ECONNREFUSED: 111,
      ECONNRESET: 104,
      EDEADLK: 35,
      EDESTADDRREQ: 89,
      EDOM: 33,
      EDQUOT: 122,
      EEXIST: 17,
      EFAULT: 14,
      EFBIG: 27,
      EHOSTUNREACH: 113,
      EIDRM: 43,
      EILSEQ: 84,
      EINPROGRESS: 115,
      EINTR: 4,
      EINVAL: 22,
      EIO: 5,
      EISCONN: 106,
      EISDIR: 21,
      ELOOP: 40,
      EMFILE: 24,
      EMLINK: 31,
      EMSGSIZE: 90,
      EMULTIHOP: 72,
      ENAMETOOLONG: 36,
      ENETDOWN: 100,
      ENETRESET: 102,
      ENETUNREACH: 101,
      ENFILE: 23,
      ENOBUFS: 105,
      ENODATA: 61,
      ENODEV: 19,
      ENOENT: 2,
      ENOEXEC: 8,
      ENOLCK: 37,
      ENOLINK: 67,
      ENOMEM: 12,
      ENOMSG: 42,
      ENOPROTOOPT: 92,
      ENOSPC: 28,
      ENOSR: 63,
      ENOSTR: 60,
      ENOSYS: 38,
      ENOTCONN: 107,
      ENOTDIR: 20,
      ENOTEMPTY: 39,
      ENOTSOCK: 88,
      ENOTSUP: 95,
      ENOTTY: 25,
      ENXIO: 6,
      EOPNOTSUPP: 95,
      EOVERFLOW: 75,
      EPERM: 1,
      EPIPE: 32,
      EPROTO: 71,
      EPROTONOSUPPORT: 93,
      EPROTOTYPE: 91,
      ERANGE: 34,
      EROFS: 30,
      ESPIPE: 29,
      ESRCH: 3,
      ESTALE: 116,
      ETIME: 62,
      ETIMEDOUT: 110,
      ETXTBSY: 26,
      EWOULDBLOCK: 11,
      EXDEV: 18
    };
    signals = {
      SIGHUP: 1,
      SIGINT: 2,
      SIGQUIT: 3,
      SIGILL: 4,
      SIGTRAP: 5,
      SIGABRT: 6,
      SIGIOT: 6,
      SIGBUS: 7,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGUSR1: 10,
      SIGSEGV: 11,
      SIGUSR2: 12,
      SIGPIPE: 13,
      SIGALRM: 14,
      SIGTERM: 15,
      SIGCHLD: 17,
      SIGSTKFLT: 16,
      SIGCONT: 18,
      SIGSTOP: 19,
      SIGTSTP: 20,
      SIGTTIN: 21,
      SIGTTOU: 22,
      SIGURG: 23,
      SIGXCPU: 24,
      SIGXFSZ: 25,
      SIGVTALRM: 26,
      SIGPROF: 27,
      SIGWINCH: 28,
      SIGIO: 29,
      SIGPOLL: 29,
      SIGPWR: 30,
      SIGSYS: 31
    };
    priority = {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20
    };
  }
});

// node_modules/unenv/dist/runtime/node/os.mjs
var constants2, NUM_CPUS, availableParallelism, arch2, machine, endianness, cpus, getPriority, setPriority, homedir, tmpdir, devNull, freemem, totalmem, loadavg, uptime2, hostname, networkInterfaces, platform2, type, release2, version2, userInfo, EOL, os_default;
var init_os = __esm({
  "node_modules/unenv/dist/runtime/node/os.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_constants2();
    constants2 = {
      UV_UDP_REUSEADDR,
      dlopen: dlopen2,
      errno,
      signals,
      priority
    };
    NUM_CPUS = 8;
    availableParallelism = /* @__PURE__ */ __name(() => NUM_CPUS, "availableParallelism");
    arch2 = /* @__PURE__ */ __name(() => "", "arch");
    machine = /* @__PURE__ */ __name(() => "", "machine");
    endianness = /* @__PURE__ */ __name(() => "LE", "endianness");
    cpus = /* @__PURE__ */ __name(() => {
      const info3 = {
        model: "",
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      };
      return Array.from({ length: NUM_CPUS }, () => info3);
    }, "cpus");
    getPriority = /* @__PURE__ */ __name(() => 0, "getPriority");
    setPriority = /* @__PURE__ */ notImplemented("os.setPriority");
    homedir = /* @__PURE__ */ __name(() => "/", "homedir");
    tmpdir = /* @__PURE__ */ __name(() => "/tmp", "tmpdir");
    devNull = "/dev/null";
    freemem = /* @__PURE__ */ __name(() => 0, "freemem");
    totalmem = /* @__PURE__ */ __name(() => 0, "totalmem");
    loadavg = /* @__PURE__ */ __name(() => [
      0,
      0,
      0
    ], "loadavg");
    uptime2 = /* @__PURE__ */ __name(() => 0, "uptime");
    hostname = /* @__PURE__ */ __name(() => "", "hostname");
    networkInterfaces = /* @__PURE__ */ __name(() => {
      return { lo0: [
        {
          address: "127.0.0.1",
          netmask: "255.0.0.0",
          family: "IPv4",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "127.0.0.1/8"
        },
        {
          address: "::1",
          netmask: "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "::1/128",
          scopeid: 0
        },
        {
          address: "fe80::1",
          netmask: "ffff:ffff:ffff:ffff::",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "fe80::1/64",
          scopeid: 1
        }
      ] };
    }, "networkInterfaces");
    platform2 = /* @__PURE__ */ __name(() => "linux", "platform");
    type = /* @__PURE__ */ __name(() => "Linux", "type");
    release2 = /* @__PURE__ */ __name(() => "", "release");
    version2 = /* @__PURE__ */ __name(() => "", "version");
    userInfo = /* @__PURE__ */ __name((opts) => {
      const encode = /* @__PURE__ */ __name((str) => {
        if (opts?.encoding) {
          const buff = Buffer.from(str);
          return opts.encoding === "buffer" ? buff : buff.toString(opts.encoding);
        }
        return str;
      }, "encode");
      return {
        gid: 1e3,
        uid: 1e3,
        homedir: encode("/"),
        shell: encode("/bin/sh"),
        username: encode("root")
      };
    }, "userInfo");
    EOL = "\n";
    os_default = {
      arch: arch2,
      availableParallelism,
      constants: constants2,
      cpus,
      EOL,
      endianness,
      devNull,
      freemem,
      getPriority,
      homedir,
      hostname,
      loadavg,
      machine,
      networkInterfaces,
      platform: platform2,
      release: release2,
      setPriority,
      tmpdir,
      totalmem,
      type,
      uptime: uptime2,
      userInfo,
      version: version2
    };
  }
});

// node-built-in-modules:os
var require_os = __commonJS({
  "node-built-in-modules:os"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_os();
    module2.exports = os_default;
  }
});

// node-built-in-modules:util
var require_util = __commonJS({
  "node-built-in-modules:util"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    module2.exports = util_default;
  }
});

// node-built-in-modules:zlib
import libDefault2 from "zlib";
var require_zlib = __commonJS({
  "node-built-in-modules:zlib"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = libDefault2;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error3 = this._errors[i];
        var message = error3.message;
        var count3 = (counts[message] || 0) + 1;
        counts[message] = count3;
        if (count3 >= mainErrorCount) {
          mainError = error3;
          mainErrorCount = count3;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = require_retry();
  }
});

// node_modules/async-retry/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/async-retry/lib/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var retrier = require_retry2();
    function retry(fn, opts) {
      function run(resolve, reject) {
        var options = opts || {};
        var op;
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        op = retrier.operation(options);
        function bail(err) {
          reject(err || new Error("Aborted"));
        }
        __name(bail, "bail");
        function onError(err, num) {
          if (err.bail) {
            bail(err);
            return;
          }
          if (!op.retry(err)) {
            reject(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err, num);
          }
        }
        __name(onError, "onError");
        function runAttempt(num) {
          var val;
          try {
            val = fn(bail, num);
          } catch (err) {
            onError(err, num);
            return;
          }
          Promise.resolve(val).then(resolve).catch(/* @__PURE__ */ __name(function catchIt(err) {
            onError(err, num);
          }, "catchIt"));
        }
        __name(runAttempt, "runAttempt");
        op.attempt(runAttempt);
      }
      __name(run, "run");
      return new Promise(run);
    }
    __name(retry, "retry");
    module2.exports = retry;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(/* @__PURE__ */ __name(function executor(resolve, reject) {
        params[offset] = /* @__PURE__ */ __name(function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        }, "callback");
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      }, "executor"));
    }
    __name(asPromise, "asPromise");
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var base64 = exports2;
    base64.length = /* @__PURE__ */ __name(function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    }, "length");
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = /* @__PURE__ */ __name(function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    }, "encode");
    var invalidEncoding = "invalid encoding";
    base64.decode = /* @__PURE__ */ __name(function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    }, "decode");
    base64.test = /* @__PURE__ */ __name(function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    }, "test");
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = EventEmitter3;
    function EventEmitter3() {
      this._listeners = {};
    }
    __name(EventEmitter3, "EventEmitter");
    EventEmitter3.prototype.on = /* @__PURE__ */ __name(function on2(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    }, "on");
    EventEmitter3.prototype.off = /* @__PURE__ */ __name(function off2(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners2 = this._listeners[evt];
          for (var i = 0; i < listeners2.length; )
            if (listeners2[i].fn === fn)
              listeners2.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    }, "off");
    EventEmitter3.prototype.emit = /* @__PURE__ */ __name(function emit2(evt) {
      var listeners2 = this._listeners[evt];
      if (listeners2) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners2.length; )
          listeners2[i].fn.apply(listeners2[i++].ctx, args);
      }
      return this;
    }, "emit");
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        __name(writeFloat_f32_cpy, "writeFloat_f32_cpy");
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        __name(writeFloat_f32_rev, "writeFloat_f32_rev");
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        __name(readFloat_f32_cpy, "readFloat_f32_cpy");
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        __name(readFloat_f32_rev, "readFloat_f32_rev");
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        __name(writeFloat_ieee754, "writeFloat_ieee754");
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        __name(readFloat_ieee754, "readFloat_ieee754");
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        __name(writeDouble_f64_cpy, "writeDouble_f64_cpy");
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        __name(writeDouble_f64_rev, "writeDouble_f64_rev");
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        __name(readDouble_f64_cpy, "readDouble_f64_cpy");
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        __name(readDouble_f64_rev, "readDouble_f64_rev");
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        __name(writeDouble_ieee754, "writeDouble_ieee754");
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        __name(readDouble_ieee754, "readDouble_ieee754");
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    __name(factory, "factory");
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeUintLE, "writeUintLE");
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    __name(writeUintBE, "writeUintBE");
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    __name(readUintLE, "readUintLE");
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
    __name(readUintBE, "readUintBE");
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
    __name(inquire, "inquire");
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utf8 = exports2;
    utf8.length = /* @__PURE__ */ __name(function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }, "utf8_length");
    utf8.read = /* @__PURE__ */ __name(function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    }, "utf8_read");
    utf8.write = /* @__PURE__ */ __name(function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }, "utf8_write");
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return /* @__PURE__ */ __name(function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      }, "pool_alloc");
    }
    __name(pool, "pool");
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    __name(LongBits, "LongBits");
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = /* @__PURE__ */ __name(function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    }, "fromNumber");
    LongBits.from = /* @__PURE__ */ __name(function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }, "from");
    LongBits.prototype.toNumber = /* @__PURE__ */ __name(function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }, "toNumber");
    LongBits.prototype.toLong = /* @__PURE__ */ __name(function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    }, "toLong");
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = /* @__PURE__ */ __name(function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    }, "fromHash");
    LongBits.prototype.toHash = /* @__PURE__ */ __name(function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    }, "toHash");
    LongBits.prototype.zzEncode = /* @__PURE__ */ __name(function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }, "zzEncode");
    LongBits.prototype.zzDecode = /* @__PURE__ */ __name(function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }, "zzDecode");
    LongBits.prototype.length = /* @__PURE__ */ __name(function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }, "length");
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    /* @__PURE__ */ __name(function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }, "isInteger");
    util.isString = /* @__PURE__ */ __name(function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }, "isString");
    util.isObject = /* @__PURE__ */ __name(function isObject2(value) {
      return value && typeof value === "object";
    }, "isObject");
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = /* @__PURE__ */ __name(function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    }, "isSet");
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = /* @__PURE__ */ __name(function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    }, "newBuffer");
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = /* @__PURE__ */ __name(function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    }, "longToHash");
    util.longFromHash = /* @__PURE__ */ __name(function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    }, "longFromHash");
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    __name(merge, "merge");
    util.merge = merge;
    util.lcFirst = /* @__PURE__ */ __name(function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    }, "lcFirst");
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: /* @__PURE__ */ __name(function() {
          return message;
        }, "get") });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      __name(CustomError, "CustomError");
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: /* @__PURE__ */ __name(function() {
        return name;
      }, "get") });
      CustomError.prototype.toString = /* @__PURE__ */ __name(function toString() {
        return this.name + ": " + this.message;
      }, "toString");
      return CustomError;
    }
    __name(newError, "newError");
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = /* @__PURE__ */ __name(function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    }, "getOneOf");
    util.oneOfSetter = /* @__PURE__ */ __name(function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    }, "setOneOf");
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      }, "Buffer_from");
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      }, "Buffer_allocUnsafe");
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(Op, "Op");
    function noop() {
    }
    __name(noop, "noop");
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    __name(State, "State");
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    __name(Writer, "Writer");
    Writer.create = util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup() {
      return (Writer.create = /* @__PURE__ */ __name(function create_buffer() {
        return new BufferWriter();
      }, "create_buffer"))();
    }, "create_buffer_setup") : /* @__PURE__ */ __name(function create_array() {
      return new Writer();
    }, "create_array");
    Writer.alloc = /* @__PURE__ */ __name(function alloc(size) {
      return new util.Array(size);
    }, "alloc");
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = /* @__PURE__ */ __name(function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }, "push");
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    __name(writeByte, "writeByte");
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    __name(writeVarint32, "writeVarint32");
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(VarintOp, "VarintOp");
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = /* @__PURE__ */ __name(function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    }, "write_uint32");
    Writer.prototype.int32 = /* @__PURE__ */ __name(function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }, "write_int32");
    Writer.prototype.sint32 = /* @__PURE__ */ __name(function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }, "write_sint32");
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    __name(writeVarint64, "writeVarint64");
    Writer.prototype.uint64 = /* @__PURE__ */ __name(function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_uint64");
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = /* @__PURE__ */ __name(function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_sint64");
    Writer.prototype.bool = /* @__PURE__ */ __name(function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }, "write_bool");
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeFixed32, "writeFixed32");
    Writer.prototype.fixed32 = /* @__PURE__ */ __name(function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }, "write_fixed32");
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = /* @__PURE__ */ __name(function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }, "write_fixed64");
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = /* @__PURE__ */ __name(function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    }, "write_float");
    Writer.prototype.double = /* @__PURE__ */ __name(function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    }, "write_double");
    var writeBytes = util.Array.prototype.set ? /* @__PURE__ */ __name(function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytes_set") : /* @__PURE__ */ __name(function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    }, "writeBytes_for");
    Writer.prototype.bytes = /* @__PURE__ */ __name(function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }, "write_bytes");
    Writer.prototype.string = /* @__PURE__ */ __name(function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    }, "write_string");
    Writer.prototype.fork = /* @__PURE__ */ __name(function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }, "fork");
    Writer.prototype.reset = /* @__PURE__ */ __name(function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }, "reset");
    Writer.prototype.ldelim = /* @__PURE__ */ __name(function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }, "ldelim");
    Writer.prototype.finish = /* @__PURE__ */ __name(function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }, "finish");
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    __name(BufferWriter, "BufferWriter");
    BufferWriter.alloc = /* @__PURE__ */ __name(function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    }, "alloc_buffer");
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? /* @__PURE__ */ __name(function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytesBuffer_set") : /* @__PURE__ */ __name(function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else for (var i = 0; i < val.length; )
        buf[pos++] = val[i++];
    }, "writeBytesBuffer_copy");
    BufferWriter.prototype.bytes = /* @__PURE__ */ __name(function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    }, "write_bytes_buffer");
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    __name(writeStringBuffer, "writeStringBuffer");
    BufferWriter.prototype.string = /* @__PURE__ */ __name(function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    }, "write_string_buffer");
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    __name(indexOutOfRange, "indexOutOfRange");
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    __name(Reader, "Reader");
    var create_array = typeof Uint8Array !== "undefined" ? /* @__PURE__ */ __name(function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_typed_array") : /* @__PURE__ */ __name(function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_array");
    Reader.create = util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup(buffer) {
      return (Reader.create = /* @__PURE__ */ __name(function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      }, "create_buffer"))(buffer);
    }, "create_buffer_setup") : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = (/* @__PURE__ */ __name(function read_uint32_setup() {
      var value = 4294967295;
      return /* @__PURE__ */ __name(function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      }, "read_uint32");
    }, "read_uint32_setup"))();
    Reader.prototype.int32 = /* @__PURE__ */ __name(function read_int32() {
      return this.uint32() | 0;
    }, "read_int32");
    Reader.prototype.sint32 = /* @__PURE__ */ __name(function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }, "read_sint32");
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    __name(readLongVarint, "readLongVarint");
    Reader.prototype.bool = /* @__PURE__ */ __name(function read_bool() {
      return this.uint32() !== 0;
    }, "read_bool");
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    __name(readFixed32_end, "readFixed32_end");
    Reader.prototype.fixed32 = /* @__PURE__ */ __name(function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    }, "read_fixed32");
    Reader.prototype.sfixed32 = /* @__PURE__ */ __name(function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    }, "read_sfixed32");
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    __name(readFixed64, "readFixed64");
    Reader.prototype.float = /* @__PURE__ */ __name(function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }, "read_float");
    Reader.prototype.double = /* @__PURE__ */ __name(function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }, "read_double");
    Reader.prototype.bytes = /* @__PURE__ */ __name(function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    }, "read_bytes");
    Reader.prototype.string = /* @__PURE__ */ __name(function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    }, "read_string");
    Reader.prototype.skip = /* @__PURE__ */ __name(function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }, "skip");
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: /* @__PURE__ */ __name(function read_int64() {
          return readLongVarint.call(this)[fn](false);
        }, "read_int64"),
        uint64: /* @__PURE__ */ __name(function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        }, "read_uint64"),
        sint64: /* @__PURE__ */ __name(function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        }, "read_sint64"),
        fixed64: /* @__PURE__ */ __name(function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        }, "read_fixed64"),
        sfixed64: /* @__PURE__ */ __name(function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }, "read_sfixed64")
      });
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    __name(BufferReader, "BufferReader");
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = /* @__PURE__ */ __name(function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    }, "read_string_buffer");
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    __name(Service, "Service");
    Service.prototype.rpcCall = /* @__PURE__ */ __name(function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          /* @__PURE__ */ __name(function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }, "rpcCallback")
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    }, "rpcCall");
    Service.prototype.end = /* @__PURE__ */ __name(function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    }, "end");
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {};
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    __name(configure, "configure");
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = require_index_minimal();
  }
});

// node_modules/apollo-reporting-protobuf/generated/protobuf.js
var require_protobuf = __commonJS({
  "node_modules/apollo-reporting-protobuf/generated/protobuf.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.Trace = function() {
      function Trace(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Trace, "Trace");
      Trace.prototype.startTime = null;
      Trace.prototype.endTime = null;
      Trace.prototype.durationNs = 0;
      Trace.prototype.root = null;
      Trace.prototype.isIncomplete = false;
      Trace.prototype.signature = "";
      Trace.prototype.unexecutedOperationBody = "";
      Trace.prototype.unexecutedOperationName = "";
      Trace.prototype.details = null;
      Trace.prototype.clientName = "";
      Trace.prototype.clientVersion = "";
      Trace.prototype.http = null;
      Trace.prototype.cachePolicy = null;
      Trace.prototype.queryPlan = null;
      Trace.prototype.fullQueryCacheHit = false;
      Trace.prototype.persistedQueryHit = false;
      Trace.prototype.persistedQueryRegister = false;
      Trace.prototype.registeredOperation = false;
      Trace.prototype.forbiddenOperation = false;
      Trace.prototype.fieldExecutionWeight = 0;
      Trace.create = /* @__PURE__ */ __name(function create(properties) {
        return new Trace(properties);
      }, "create");
      Trace.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      }, "encode");
      Trace.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Trace.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Trace.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Trace.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error3 = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error3)
            return "startTime." + error3;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error3 = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error3 = $root.Trace.Node.verify(message.root);
          if (error3)
            return "root." + error3;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error3 = $root.Trace.Details.verify(message.details);
          if (error3)
            return "details." + error3;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error3 = $root.Trace.HTTP.verify(message.http);
          if (error3)
            return "http." + error3;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error3 = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error3)
            return "cachePolicy." + error3;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error3 = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error3)
            return "queryPlan." + error3;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      }, "verify");
      Trace.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      }, "toObject");
      Trace.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      Trace.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(CachePolicy, "CachePolicy");
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = /* @__PURE__ */ __name(function create(properties) {
          return new CachePolicy(properties);
        }, "create");
        CachePolicy.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        }, "encode");
        CachePolicy.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        CachePolicy.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        CachePolicy.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        CachePolicy.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        }, "verify");
        CachePolicy.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        }, "toObject");
        CachePolicy.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Details, "Details");
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = /* @__PURE__ */ __name(function create(properties) {
          return new Details(properties);
        }, "create");
        Details.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        }, "encode");
        Details.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Details.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Details.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Details.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        }, "verify");
        Details.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        }, "toObject");
        Details.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Details;
      }();
      Trace.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Error2, "Error");
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = /* @__PURE__ */ __name(function create(properties) {
          return new Error2(properties);
        }, "create");
        Error2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        }, "encode");
        Error2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Error2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Error2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Error2.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error3 = $root.Trace.Location.verify(message.location[i]);
              if (error3)
                return "location." + error3;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        }, "verify");
        Error2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        }, "toObject");
        Error2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Error2;
      }();
      Trace.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(HTTP, "HTTP");
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = /* @__PURE__ */ __name(function create(properties) {
          return new HTTP(properties);
        }, "create");
        HTTP.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        }, "encode");
        HTTP.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        HTTP.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        HTTP.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        HTTP.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error3 = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error3)
                return "requestHeaders." + error3;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error3 = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error3)
                return "responseHeaders." + error3;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        }, "verify");
        HTTP.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        }, "toObject");
        HTTP.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Values, "Values");
          Values.prototype.value = $util.emptyArray;
          Values.create = /* @__PURE__ */ __name(function create(properties) {
            return new Values(properties);
          }, "create");
          Values.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          }, "encode");
          Values.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Values.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Values.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Values.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          }, "verify");
          Values.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          }, "toObject");
          Values.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace.Location = function() {
        function Location(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Location, "Location");
        Location.prototype.line = 0;
        Location.prototype.column = 0;
        Location.create = /* @__PURE__ */ __name(function create(properties) {
          return new Location(properties);
        }, "create");
        Location.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        }, "encode");
        Location.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Location.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Location.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Location.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        }, "verify");
        Location.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        }, "toObject");
        Location.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Location;
      }();
      Trace.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Node, "Node");
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = /* @__PURE__ */ __name(function create(properties) {
          return new Node(properties);
        }, "create");
        Node.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        }, "encode");
        Node.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Node.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Node.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Node.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error3 = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error3)
              return "cachePolicy." + error3;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error3 = $root.Trace.Error.verify(message.error[i]);
              if (error3)
                return "error." + error3;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error3 = $root.Trace.Node.verify(message.child[i]);
              if (error3)
                return "child." + error3;
            }
          }
          return null;
        }, "verify");
        Node.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        }, "toObject");
        Node.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Node;
      }();
      Trace.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(QueryPlanNode, "QueryPlanNode");
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = /* @__PURE__ */ __name(function create(properties) {
          return new QueryPlanNode(properties);
        }, "create");
        QueryPlanNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        }, "encode");
        QueryPlanNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        QueryPlanNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        QueryPlanNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        QueryPlanNode.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error3)
                return "sequence." + error3;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error3)
                return "parallel." + error3;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error3)
                return "fetch." + error3;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error3)
                return "flatten." + error3;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error3)
                return "defer." + error3;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error3)
                return "condition." + error3;
            }
          }
          return null;
        }, "verify");
        QueryPlanNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        }, "toObject");
        QueryPlanNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(SequenceNode, "SequenceNode");
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new SequenceNode(properties);
          }, "create");
          SequenceNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          SequenceNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          SequenceNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          SequenceNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          SequenceNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          SequenceNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          SequenceNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ParallelNode, "ParallelNode");
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ParallelNode(properties);
          }, "create");
          ParallelNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          ParallelNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ParallelNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ParallelNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ParallelNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          ParallelNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          ParallelNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FetchNode, "FetchNode");
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FetchNode(properties);
          }, "create");
          FetchNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FetchNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FetchNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FetchNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FetchNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error3 = $root.Trace.verify(message.trace);
              if (error3)
                return "trace." + error3;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error3 = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error3)
                return "sentTime." + error3;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error3 = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error3)
                return "receivedTime." + error3;
            }
            return null;
          }, "verify");
          FetchNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          }, "toObject");
          FetchNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FlattenNode, "FlattenNode");
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FlattenNode(properties);
          }, "create");
          FlattenNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FlattenNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FlattenNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FlattenNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FlattenNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error3)
                  return "responsePath." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          FlattenNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          FlattenNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNode, "DeferNode");
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNode(properties);
          }, "create");
          DeferNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error3 = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error3)
                return "primary." + error3;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error3)
                  return "deferred." + error3;
              }
            }
            return null;
          }, "verify");
          DeferNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          }, "toObject");
          DeferNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ConditionNode, "ConditionNode");
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ConditionNode(properties);
          }, "create");
          ConditionNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          }, "encode");
          ConditionNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ConditionNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ConditionNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ConditionNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error3)
                return "ifClause." + error3;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error3)
                return "elseClause." + error3;
            }
            return null;
          }, "verify");
          ConditionNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          }, "toObject");
          ConditionNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNodePrimary, "DeferNodePrimary");
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNodePrimary(properties);
          }, "create");
          DeferNodePrimary.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNodePrimary.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNodePrimary.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNodePrimary.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNodePrimary.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferNodePrimary.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferNodePrimary.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNode, "DeferredNode");
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNode(properties);
          }, "create");
          DeferredNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferredNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error3)
                  return "depends." + error3;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error3)
                  return "path." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferredNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferredNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNodeDepends, "DeferredNodeDepends");
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNodeDepends(properties);
          }, "create");
          DeferredNodeDepends.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          }, "encode");
          DeferredNodeDepends.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNodeDepends.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNodeDepends.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNodeDepends.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          }, "verify");
          DeferredNodeDepends.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          }, "toObject");
          DeferredNodeDepends.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ResponsePathElement, "ResponsePathElement");
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = /* @__PURE__ */ __name(function create(properties) {
            return new ResponsePathElement(properties);
          }, "create");
          ResponsePathElement.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          }, "encode");
          ResponsePathElement.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ResponsePathElement.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ResponsePathElement.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ResponsePathElement.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          }, "verify");
          ResponsePathElement.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          }, "toObject");
          ResponsePathElement.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace;
    }();
    $root.ReportHeader = function() {
      function ReportHeader(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReportHeader, "ReportHeader");
      ReportHeader.prototype.graphRef = "";
      ReportHeader.prototype.hostname = "";
      ReportHeader.prototype.agentVersion = "";
      ReportHeader.prototype.serviceVersion = "";
      ReportHeader.prototype.runtimeVersion = "";
      ReportHeader.prototype.uname = "";
      ReportHeader.prototype.executableSchemaId = "";
      ReportHeader.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReportHeader(properties);
      }, "create");
      ReportHeader.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      }, "encode");
      ReportHeader.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReportHeader.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReportHeader.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReportHeader.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      }, "verify");
      ReportHeader.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      }, "toObject");
      ReportHeader.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ReportHeader;
    }();
    $root.PathErrorStats = function() {
      function PathErrorStats(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(PathErrorStats, "PathErrorStats");
      PathErrorStats.prototype.children = $util.emptyObject;
      PathErrorStats.prototype.errorsCount = 0;
      PathErrorStats.prototype.requestsWithErrorsCount = 0;
      PathErrorStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new PathErrorStats(properties);
      }, "create");
      PathErrorStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      }, "encode");
      PathErrorStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      PathErrorStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      PathErrorStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      PathErrorStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error3)
              return "children." + error3;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      }, "verify");
      PathErrorStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      }, "toObject");
      PathErrorStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return PathErrorStats;
    }();
    $root.QueryLatencyStats = function() {
      function QueryLatencyStats(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(QueryLatencyStats, "QueryLatencyStats");
      QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.requestCount = 0;
      QueryLatencyStats.prototype.cacheHits = 0;
      QueryLatencyStats.prototype.persistedQueryHits = 0;
      QueryLatencyStats.prototype.persistedQueryMisses = 0;
      QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.rootErrorStats = null;
      QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.registeredOperationCount = 0;
      QueryLatencyStats.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new QueryLatencyStats(properties);
      }, "create");
      QueryLatencyStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      }, "encode");
      QueryLatencyStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      QueryLatencyStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      QueryLatencyStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      QueryLatencyStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error3 = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error3)
            return "rootErrorStats." + error3;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      }, "verify");
      QueryLatencyStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      }, "toObject");
      QueryLatencyStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return QueryLatencyStats;
    }();
    $root.StatsContext = function() {
      function StatsContext(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(StatsContext, "StatsContext");
      StatsContext.prototype.clientName = "";
      StatsContext.prototype.clientVersion = "";
      StatsContext.create = /* @__PURE__ */ __name(function create(properties) {
        return new StatsContext(properties);
      }, "create");
      StatsContext.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      }, "encode");
      StatsContext.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      StatsContext.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      StatsContext.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      StatsContext.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      }, "verify");
      StatsContext.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      }, "toObject");
      StatsContext.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return StatsContext;
    }();
    $root.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedQueryLatencyStats, "ContextualizedQueryLatencyStats");
      ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats.prototype.context = null;
      ContextualizedQueryLatencyStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedQueryLatencyStats(properties);
      }, "create");
      ContextualizedQueryLatencyStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      }, "encode");
      ContextualizedQueryLatencyStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedQueryLatencyStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedQueryLatencyStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedQueryLatencyStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error3 = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        return null;
      }, "verify");
      ContextualizedQueryLatencyStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      }, "toObject");
      ContextualizedQueryLatencyStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedQueryLatencyStats;
    }();
    $root.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedTypeStats, "ContextualizedTypeStats");
      ContextualizedTypeStats.prototype.context = null;
      ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedTypeStats(properties);
      }, "create");
      ContextualizedTypeStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedTypeStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedTypeStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedTypeStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedTypeStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedTypeStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedTypeStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedTypeStats;
    }();
    $root.FieldStat = function() {
      function FieldStat(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(FieldStat, "FieldStat");
      FieldStat.prototype.returnType = "";
      FieldStat.prototype.errorsCount = 0;
      FieldStat.prototype.observedExecutionCount = 0;
      FieldStat.prototype.estimatedExecutionCount = 0;
      FieldStat.prototype.requestsWithErrorsCount = 0;
      FieldStat.prototype.latencyCount = $util.emptyArray;
      FieldStat.create = /* @__PURE__ */ __name(function create(properties) {
        return new FieldStat(properties);
      }, "create");
      FieldStat.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      }, "encode");
      FieldStat.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      FieldStat.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      FieldStat.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      FieldStat.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      }, "verify");
      FieldStat.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      }, "toObject");
      FieldStat.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return FieldStat;
    }();
    $root.TypeStat = function() {
      function TypeStat(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TypeStat, "TypeStat");
      TypeStat.prototype.perFieldStat = $util.emptyObject;
      TypeStat.create = /* @__PURE__ */ __name(function create(properties) {
        return new TypeStat(properties);
      }, "create");
      TypeStat.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TypeStat.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TypeStat.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TypeStat.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TypeStat.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error3)
              return "perFieldStat." + error3;
          }
        }
        return null;
      }, "verify");
      TypeStat.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TypeStat.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return TypeStat;
    }();
    $root.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReferencedFieldsForType, "ReferencedFieldsForType");
      ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType.prototype.isInterface = false;
      ReferencedFieldsForType.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReferencedFieldsForType(properties);
      }, "create");
      ReferencedFieldsForType.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      }, "encode");
      ReferencedFieldsForType.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReferencedFieldsForType.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReferencedFieldsForType.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReferencedFieldsForType.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      }, "verify");
      ReferencedFieldsForType.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      }, "toObject");
      ReferencedFieldsForType.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ReferencedFieldsForType;
    }();
    $root.Report = function() {
      function Report(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Report, "Report");
      Report.prototype.header = null;
      Report.prototype.tracesPerQuery = $util.emptyObject;
      Report.prototype.endTime = null;
      Report.prototype.operationCount = 0;
      Report.prototype.tracesPreAggregated = false;
      Report.create = /* @__PURE__ */ __name(function create(properties) {
        return new Report(properties);
      }, "create");
      Report.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      }, "encode");
      Report.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Report.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Report.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Report.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error3 = $root.ReportHeader.verify(message.header);
          if (error3)
            return "header." + error3;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error3)
              return "tracesPerQuery." + error3;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error3 = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      }, "verify");
      Report.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      }, "toObject");
      Report.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return Report;
    }();
    $root.ContextualizedStats = function() {
      function ContextualizedStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedStats, "ContextualizedStats");
      ContextualizedStats.prototype.context = null;
      ContextualizedStats.prototype.queryLatencyStats = null;
      ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedStats(properties);
      }, "create");
      ContextualizedStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error3 = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedStats;
    }();
    $root.TracesAndStats = function() {
      function TracesAndStats(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TracesAndStats, "TracesAndStats");
      TracesAndStats.prototype.trace = $util.emptyArray;
      TracesAndStats.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new TracesAndStats(properties);
      }, "create");
      TracesAndStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TracesAndStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TracesAndStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TracesAndStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TracesAndStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error3 = $root.Trace.verify(message.trace[i]);
              if (error3)
                return "trace." + error3;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error3 = $root.ContextualizedStats.verify(array2[i]);
            if (error3)
              return "statsWithContext." + error3;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error3)
              return "referencedFieldsByType." + error3;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error3 = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error3)
                return "internalTracesContributingToStats." + error3;
            }
        }
        return null;
      }, "verify");
      TracesAndStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TracesAndStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return TracesAndStats;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Timestamp, "Timestamp");
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = /* @__PURE__ */ __name(function create(properties) {
            return new Timestamp(properties);
          }, "create");
          Timestamp.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          }, "encode");
          Timestamp.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Timestamp.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Timestamp.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Timestamp.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          }, "verify");
          Timestamp.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          }, "toObject");
          Timestamp.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return Timestamp;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// node_modules/apollo-reporting-protobuf/generated/index.js
var require_generated = __commonJS({
  "node_modules/apollo-reporting-protobuf/generated/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var protobuf = require_protobuf();
    var protobufJS = require_minimal2();
    protobufJS.util.Long = void 0;
    protobufJS.configure();
    module2.exports = protobuf;
  }
});

// node_modules/node-abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/node-abort-controller/browser.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    if (!_global) {
      throw new Error(
        `Unable to find global scope. Are you sure this is running in the browser?`
      );
    }
    if (!_global.AbortController) {
      throw new Error(
        `Could not find "AbortController" in the global scope. You need to polyfill it first`
      );
    }
    module2.exports.AbortController = _global.AbortController;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    __name(Yallist, "Yallist");
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    __name(insert, "insert");
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    __name(push, "push");
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    __name(unshift, "unshift");
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    __name(Node, "Node");
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache2 = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = /* @__PURE__ */ __name(() => 1, "naiveLength");
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get2(this, key, true);
      }
      peek(key) {
        return get2(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get2(this, key, false));
      }
    };
    var get2 = /* @__PURE__ */ __name((self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    }, "get");
    var isStale = /* @__PURE__ */ __name((self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    }, "isStale");
    var trim = /* @__PURE__ */ __name((self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    }, "trim");
    var del = /* @__PURE__ */ __name((self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    }, "del");
    var Entry = class {
      static {
        __name(this, "Entry");
      }
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = /* @__PURE__ */ __name((self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    }, "forEachStep");
    module2.exports = LRUCache;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js
var require_operationDerivedDataCache = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operationDerivedDataCacheKey = exports2.createOperationDerivedDataCache = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache2());
    function createOperationDerivedDataCache({ logger }) {
      let lastWarn;
      let lastDisposals = 0;
      return new lru_cache_1.default({
        length(obj) {
          return Buffer.byteLength(JSON.stringify(obj), "utf8");
        },
        max: Math.pow(2, 20) * 10,
        dispose() {
          lastDisposals++;
          if (!lastWarn || (/* @__PURE__ */ new Date()).getTime() - lastWarn.getTime() > 6e4) {
            lastWarn = /* @__PURE__ */ new Date();
            logger.warn([
              "This server is processing a high number of unique operations.  ",
              `A total of ${lastDisposals} records have been `,
              "ejected from the ApolloServerPluginUsageReporting signature cache in the past ",
              "interval.  If you see this warning frequently, please open an ",
              "issue on the Apollo Server repository."
            ].join(""));
            lastDisposals = 0;
          }
        }
      });
    }
    __name(createOperationDerivedDataCache, "createOperationDerivedDataCache");
    exports2.createOperationDerivedDataCache = createOperationDerivedDataCache;
    function operationDerivedDataCacheKey(queryHash, operationName) {
      return `${queryHash}${operationName && ":" + operationName}`;
    }
    __name(operationDerivedDataCacheKey, "operationDerivedDataCacheKey");
    exports2.operationDerivedDataCacheKey = operationDerivedDataCacheKey;
  }
});

// node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = LongBits;
    var util = require_minimal3();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    __name(LongBits, "LongBits");
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = /* @__PURE__ */ __name(function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    }, "fromNumber");
    LongBits.from = /* @__PURE__ */ __name(function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }, "from");
    LongBits.prototype.toNumber = /* @__PURE__ */ __name(function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }, "toNumber");
    LongBits.prototype.toLong = /* @__PURE__ */ __name(function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    }, "toLong");
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = /* @__PURE__ */ __name(function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    }, "fromHash");
    LongBits.prototype.toHash = /* @__PURE__ */ __name(function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    }, "toHash");
    LongBits.prototype.zzEncode = /* @__PURE__ */ __name(function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }, "zzEncode");
    LongBits.prototype.zzDecode = /* @__PURE__ */ __name(function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }, "zzDecode");
    LongBits.prototype.length = /* @__PURE__ */ __name(function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }, "length");
  }
});

// node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal3 = __commonJS({
  "node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits2();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    /* @__PURE__ */ __name(function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }, "isInteger");
    util.isString = /* @__PURE__ */ __name(function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }, "isString");
    util.isObject = /* @__PURE__ */ __name(function isObject2(value) {
      return value && typeof value === "object";
    }, "isObject");
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = /* @__PURE__ */ __name(function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    }, "isSet");
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = /* @__PURE__ */ __name(function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    }, "newBuffer");
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = /* @__PURE__ */ __name(function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    }, "longToHash");
    util.longFromHash = /* @__PURE__ */ __name(function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    }, "longFromHash");
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    __name(merge, "merge");
    util.merge = merge;
    util.lcFirst = /* @__PURE__ */ __name(function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    }, "lcFirst");
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: /* @__PURE__ */ __name(function() {
          return message;
        }, "get") });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      __name(CustomError, "CustomError");
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: /* @__PURE__ */ __name(function() {
        return name;
      }, "get") });
      CustomError.prototype.toString = /* @__PURE__ */ __name(function toString() {
        return this.name + ": " + this.message;
      }, "toString");
      return CustomError;
    }
    __name(newError, "newError");
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = /* @__PURE__ */ __name(function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    }, "getOneOf");
    util.oneOfSetter = /* @__PURE__ */ __name(function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    }, "setOneOf");
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      }, "Buffer_from");
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      }, "Buffer_allocUnsafe");
    };
  }
});

// node_modules/@apollo/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Writer;
    var util = require_minimal3();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(Op, "Op");
    function noop() {
    }
    __name(noop, "noop");
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    __name(State, "State");
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    __name(Writer, "Writer");
    Writer.create = util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup() {
      return (Writer.create = /* @__PURE__ */ __name(function create_buffer() {
        return new BufferWriter();
      }, "create_buffer"))();
    }, "create_buffer_setup") : /* @__PURE__ */ __name(function create_array() {
      return new Writer();
    }, "create_array");
    Writer.alloc = /* @__PURE__ */ __name(function alloc(size) {
      return new util.Array(size);
    }, "alloc");
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = /* @__PURE__ */ __name(function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }, "push");
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    __name(writeByte, "writeByte");
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    __name(writeVarint32, "writeVarint32");
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(VarintOp, "VarintOp");
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = /* @__PURE__ */ __name(function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    }, "write_uint32");
    Writer.prototype.int32 = /* @__PURE__ */ __name(function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }, "write_int32");
    Writer.prototype.sint32 = /* @__PURE__ */ __name(function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }, "write_sint32");
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    __name(writeVarint64, "writeVarint64");
    Writer.prototype.uint64 = /* @__PURE__ */ __name(function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_uint64");
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = /* @__PURE__ */ __name(function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_sint64");
    Writer.prototype.bool = /* @__PURE__ */ __name(function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }, "write_bool");
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeFixed32, "writeFixed32");
    Writer.prototype.fixed32 = /* @__PURE__ */ __name(function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }, "write_fixed32");
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = /* @__PURE__ */ __name(function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }, "write_fixed64");
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = /* @__PURE__ */ __name(function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    }, "write_float");
    Writer.prototype.double = /* @__PURE__ */ __name(function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    }, "write_double");
    var writeBytes = util.Array.prototype.set ? /* @__PURE__ */ __name(function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytes_set") : /* @__PURE__ */ __name(function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    }, "writeBytes_for");
    Writer.prototype.bytes = /* @__PURE__ */ __name(function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }, "write_bytes");
    Writer.prototype.string = /* @__PURE__ */ __name(function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    }, "write_string");
    Writer.prototype.fork = /* @__PURE__ */ __name(function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }, "fork");
    Writer.prototype.reset = /* @__PURE__ */ __name(function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }, "reset");
    Writer.prototype.ldelim = /* @__PURE__ */ __name(function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }, "ldelim");
    Writer.prototype.finish = /* @__PURE__ */ __name(function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }, "finish");
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal3();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    __name(BufferWriter, "BufferWriter");
    BufferWriter.alloc = /* @__PURE__ */ __name(function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    }, "alloc_buffer");
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? /* @__PURE__ */ __name(function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytesBuffer_set") : /* @__PURE__ */ __name(function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else for (var i = 0; i < val.length; )
        buf[pos++] = val[i++];
    }, "writeBytesBuffer_copy");
    BufferWriter.prototype.bytes = /* @__PURE__ */ __name(function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    }, "write_bytes_buffer");
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    __name(writeStringBuffer, "writeStringBuffer");
    BufferWriter.prototype.string = /* @__PURE__ */ __name(function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    }, "write_string_buffer");
  }
});

// node_modules/@apollo/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Reader;
    var util = require_minimal3();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    __name(indexOutOfRange, "indexOutOfRange");
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    __name(Reader, "Reader");
    var create_array = typeof Uint8Array !== "undefined" ? /* @__PURE__ */ __name(function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_typed_array") : /* @__PURE__ */ __name(function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_array");
    Reader.create = util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup(buffer) {
      return (Reader.create = /* @__PURE__ */ __name(function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      }, "create_buffer"))(buffer);
    }, "create_buffer_setup") : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = (/* @__PURE__ */ __name(function read_uint32_setup() {
      var value = 4294967295;
      return /* @__PURE__ */ __name(function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      }, "read_uint32");
    }, "read_uint32_setup"))();
    Reader.prototype.int32 = /* @__PURE__ */ __name(function read_int32() {
      return this.uint32() | 0;
    }, "read_int32");
    Reader.prototype.sint32 = /* @__PURE__ */ __name(function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }, "read_sint32");
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    __name(readLongVarint, "readLongVarint");
    Reader.prototype.bool = /* @__PURE__ */ __name(function read_bool() {
      return this.uint32() !== 0;
    }, "read_bool");
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    __name(readFixed32_end, "readFixed32_end");
    Reader.prototype.fixed32 = /* @__PURE__ */ __name(function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    }, "read_fixed32");
    Reader.prototype.sfixed32 = /* @__PURE__ */ __name(function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    }, "read_sfixed32");
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    __name(readFixed64, "readFixed64");
    Reader.prototype.float = /* @__PURE__ */ __name(function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }, "read_float");
    Reader.prototype.double = /* @__PURE__ */ __name(function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }, "read_double");
    Reader.prototype.bytes = /* @__PURE__ */ __name(function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    }, "read_bytes");
    Reader.prototype.string = /* @__PURE__ */ __name(function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    }, "read_string");
    Reader.prototype.skip = /* @__PURE__ */ __name(function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }, "skip");
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: /* @__PURE__ */ __name(function read_int64() {
          return readLongVarint.call(this)[fn](false);
        }, "read_int64"),
        uint64: /* @__PURE__ */ __name(function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        }, "read_uint64"),
        sint64: /* @__PURE__ */ __name(function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        }, "read_sint64"),
        fixed64: /* @__PURE__ */ __name(function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        }, "read_fixed64"),
        sfixed64: /* @__PURE__ */ __name(function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }, "read_sfixed64")
      });
    };
  }
});

// node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal3();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    __name(BufferReader, "BufferReader");
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = /* @__PURE__ */ __name(function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    }, "read_string_buffer");
  }
});

// node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Service;
    var util = require_minimal3();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    __name(Service, "Service");
    Service.prototype.rpcCall = /* @__PURE__ */ __name(function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          /* @__PURE__ */ __name(function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }, "rpcCallback")
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    }, "rpcCall");
    Service.prototype.end = /* @__PURE__ */ __name(function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    }, "end");
  }
});

// node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});

// node_modules/@apollo/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {};
  }
});

// node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal3();
    protobuf.rpc = require_rpc2();
    protobuf.roots = require_roots2();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    __name(configure, "configure");
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// node_modules/@apollo/protobufjs/minimal.js
var require_minimal4 = __commonJS({
  "node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = require_index_minimal2();
  }
});

// node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js
var require_protobuf2 = __commonJS({
  "node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js"(exports2, module2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var $protobuf = require_minimal4();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.Trace = function() {
      function Trace(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Trace, "Trace");
      Trace.prototype.startTime = null;
      Trace.prototype.endTime = null;
      Trace.prototype.durationNs = 0;
      Trace.prototype.root = null;
      Trace.prototype.isIncomplete = false;
      Trace.prototype.signature = "";
      Trace.prototype.unexecutedOperationBody = "";
      Trace.prototype.unexecutedOperationName = "";
      Trace.prototype.details = null;
      Trace.prototype.clientName = "";
      Trace.prototype.clientVersion = "";
      Trace.prototype.http = null;
      Trace.prototype.cachePolicy = null;
      Trace.prototype.queryPlan = null;
      Trace.prototype.fullQueryCacheHit = false;
      Trace.prototype.persistedQueryHit = false;
      Trace.prototype.persistedQueryRegister = false;
      Trace.prototype.registeredOperation = false;
      Trace.prototype.forbiddenOperation = false;
      Trace.prototype.fieldExecutionWeight = 0;
      Trace.create = /* @__PURE__ */ __name(function create(properties) {
        return new Trace(properties);
      }, "create");
      Trace.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      }, "encode");
      Trace.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Trace.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Trace.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Trace.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error3 = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error3)
            return "startTime." + error3;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error3 = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error3 = $root.Trace.Node.verify(message.root);
          if (error3)
            return "root." + error3;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error3 = $root.Trace.Details.verify(message.details);
          if (error3)
            return "details." + error3;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error3 = $root.Trace.HTTP.verify(message.http);
          if (error3)
            return "http." + error3;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error3 = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error3)
            return "cachePolicy." + error3;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error3 = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error3)
            return "queryPlan." + error3;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      }, "verify");
      Trace.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      }, "toObject");
      Trace.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      Trace.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(CachePolicy, "CachePolicy");
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = /* @__PURE__ */ __name(function create(properties) {
          return new CachePolicy(properties);
        }, "create");
        CachePolicy.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        }, "encode");
        CachePolicy.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        CachePolicy.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        CachePolicy.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        CachePolicy.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        }, "verify");
        CachePolicy.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        }, "toObject");
        CachePolicy.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Details, "Details");
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = /* @__PURE__ */ __name(function create(properties) {
          return new Details(properties);
        }, "create");
        Details.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        }, "encode");
        Details.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Details.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Details.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Details.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        }, "verify");
        Details.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        }, "toObject");
        Details.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Details;
      }();
      Trace.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Error2, "Error");
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = /* @__PURE__ */ __name(function create(properties) {
          return new Error2(properties);
        }, "create");
        Error2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        }, "encode");
        Error2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Error2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Error2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Error2.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error3 = $root.Trace.Location.verify(message.location[i]);
              if (error3)
                return "location." + error3;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        }, "verify");
        Error2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        }, "toObject");
        Error2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Error2;
      }();
      Trace.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(HTTP, "HTTP");
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = /* @__PURE__ */ __name(function create(properties) {
          return new HTTP(properties);
        }, "create");
        HTTP.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        }, "encode");
        HTTP.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        HTTP.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        HTTP.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        HTTP.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error3 = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error3)
                return "requestHeaders." + error3;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error3 = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error3)
                return "responseHeaders." + error3;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        }, "verify");
        HTTP.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        }, "toObject");
        HTTP.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Values, "Values");
          Values.prototype.value = $util.emptyArray;
          Values.create = /* @__PURE__ */ __name(function create(properties) {
            return new Values(properties);
          }, "create");
          Values.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          }, "encode");
          Values.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Values.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Values.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Values.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          }, "verify");
          Values.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          }, "toObject");
          Values.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace.Location = function() {
        function Location(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Location, "Location");
        Location.prototype.line = 0;
        Location.prototype.column = 0;
        Location.create = /* @__PURE__ */ __name(function create(properties) {
          return new Location(properties);
        }, "create");
        Location.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        }, "encode");
        Location.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Location.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Location.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Location.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        }, "verify");
        Location.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        }, "toObject");
        Location.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Location;
      }();
      Trace.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Node, "Node");
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = /* @__PURE__ */ __name(function create(properties) {
          return new Node(properties);
        }, "create");
        Node.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        }, "encode");
        Node.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Node.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Node.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Node.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error3 = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error3)
              return "cachePolicy." + error3;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error3 = $root.Trace.Error.verify(message.error[i]);
              if (error3)
                return "error." + error3;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error3 = $root.Trace.Node.verify(message.child[i]);
              if (error3)
                return "child." + error3;
            }
          }
          return null;
        }, "verify");
        Node.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        }, "toObject");
        Node.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        return Node;
      }();
      Trace.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(QueryPlanNode, "QueryPlanNode");
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = /* @__PURE__ */ __name(function create(properties) {
          return new QueryPlanNode(properties);
        }, "create");
        QueryPlanNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        }, "encode");
        QueryPlanNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        QueryPlanNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        QueryPlanNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        QueryPlanNode.verify = /* @__PURE__ */ __name(function verify2(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error3)
                return "sequence." + error3;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error3)
                return "parallel." + error3;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error3)
                return "fetch." + error3;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error3)
                return "flatten." + error3;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error3)
                return "defer." + error3;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error3)
                return "condition." + error3;
            }
          }
          return null;
        }, "verify");
        QueryPlanNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        }, "toObject");
        QueryPlanNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        }, "toJSON");
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(SequenceNode, "SequenceNode");
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new SequenceNode(properties);
          }, "create");
          SequenceNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          SequenceNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          SequenceNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          SequenceNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          SequenceNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          SequenceNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          SequenceNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ParallelNode, "ParallelNode");
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ParallelNode(properties);
          }, "create");
          ParallelNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          ParallelNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ParallelNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ParallelNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ParallelNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          ParallelNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          ParallelNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FetchNode, "FetchNode");
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FetchNode(properties);
          }, "create");
          FetchNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FetchNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FetchNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FetchNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FetchNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error3 = $root.Trace.verify(message.trace);
              if (error3)
                return "trace." + error3;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error3 = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error3)
                return "sentTime." + error3;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error3 = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error3)
                return "receivedTime." + error3;
            }
            return null;
          }, "verify");
          FetchNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          }, "toObject");
          FetchNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FlattenNode, "FlattenNode");
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FlattenNode(properties);
          }, "create");
          FlattenNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FlattenNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FlattenNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FlattenNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FlattenNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error3)
                  return "responsePath." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          FlattenNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          FlattenNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNode, "DeferNode");
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNode(properties);
          }, "create");
          DeferNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error3 = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error3)
                return "primary." + error3;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error3)
                  return "deferred." + error3;
              }
            }
            return null;
          }, "verify");
          DeferNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          }, "toObject");
          DeferNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ConditionNode, "ConditionNode");
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ConditionNode(properties);
          }, "create");
          ConditionNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          }, "encode");
          ConditionNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ConditionNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ConditionNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ConditionNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error3)
                return "ifClause." + error3;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error3)
                return "elseClause." + error3;
            }
            return null;
          }, "verify");
          ConditionNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          }, "toObject");
          ConditionNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNodePrimary, "DeferNodePrimary");
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNodePrimary(properties);
          }, "create");
          DeferNodePrimary.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNodePrimary.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNodePrimary.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNodePrimary.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNodePrimary.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferNodePrimary.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferNodePrimary.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNode, "DeferredNode");
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNode(properties);
          }, "create");
          DeferredNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferredNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNode.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error3)
                  return "depends." + error3;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error3 = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error3)
                  return "path." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferredNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferredNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNodeDepends, "DeferredNodeDepends");
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNodeDepends(properties);
          }, "create");
          DeferredNodeDepends.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          }, "encode");
          DeferredNodeDepends.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNodeDepends.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNodeDepends.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNodeDepends.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          }, "verify");
          DeferredNodeDepends.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          }, "toObject");
          DeferredNodeDepends.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ResponsePathElement, "ResponsePathElement");
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = /* @__PURE__ */ __name(function create(properties) {
            return new ResponsePathElement(properties);
          }, "create");
          ResponsePathElement.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          }, "encode");
          ResponsePathElement.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ResponsePathElement.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ResponsePathElement.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ResponsePathElement.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          }, "verify");
          ResponsePathElement.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          }, "toObject");
          ResponsePathElement.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace;
    }();
    $root.ReportHeader = function() {
      function ReportHeader(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReportHeader, "ReportHeader");
      ReportHeader.prototype.graphRef = "";
      ReportHeader.prototype.hostname = "";
      ReportHeader.prototype.agentVersion = "";
      ReportHeader.prototype.serviceVersion = "";
      ReportHeader.prototype.runtimeVersion = "";
      ReportHeader.prototype.uname = "";
      ReportHeader.prototype.executableSchemaId = "";
      ReportHeader.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReportHeader(properties);
      }, "create");
      ReportHeader.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      }, "encode");
      ReportHeader.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReportHeader.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReportHeader.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReportHeader.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      }, "verify");
      ReportHeader.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      }, "toObject");
      ReportHeader.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ReportHeader;
    }();
    $root.PathErrorStats = function() {
      function PathErrorStats(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(PathErrorStats, "PathErrorStats");
      PathErrorStats.prototype.children = $util.emptyObject;
      PathErrorStats.prototype.errorsCount = 0;
      PathErrorStats.prototype.requestsWithErrorsCount = 0;
      PathErrorStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new PathErrorStats(properties);
      }, "create");
      PathErrorStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      }, "encode");
      PathErrorStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      PathErrorStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      PathErrorStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      PathErrorStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error3)
              return "children." + error3;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      }, "verify");
      PathErrorStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      }, "toObject");
      PathErrorStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return PathErrorStats;
    }();
    $root.QueryLatencyStats = function() {
      function QueryLatencyStats(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(QueryLatencyStats, "QueryLatencyStats");
      QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.requestCount = 0;
      QueryLatencyStats.prototype.cacheHits = 0;
      QueryLatencyStats.prototype.persistedQueryHits = 0;
      QueryLatencyStats.prototype.persistedQueryMisses = 0;
      QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.rootErrorStats = null;
      QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.registeredOperationCount = 0;
      QueryLatencyStats.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new QueryLatencyStats(properties);
      }, "create");
      QueryLatencyStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      }, "encode");
      QueryLatencyStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      QueryLatencyStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      QueryLatencyStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      QueryLatencyStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error3 = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error3)
            return "rootErrorStats." + error3;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      }, "verify");
      QueryLatencyStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      }, "toObject");
      QueryLatencyStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return QueryLatencyStats;
    }();
    $root.StatsContext = function() {
      function StatsContext(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(StatsContext, "StatsContext");
      StatsContext.prototype.clientName = "";
      StatsContext.prototype.clientVersion = "";
      StatsContext.create = /* @__PURE__ */ __name(function create(properties) {
        return new StatsContext(properties);
      }, "create");
      StatsContext.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      }, "encode");
      StatsContext.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      StatsContext.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      StatsContext.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      StatsContext.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      }, "verify");
      StatsContext.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      }, "toObject");
      StatsContext.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return StatsContext;
    }();
    $root.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedQueryLatencyStats, "ContextualizedQueryLatencyStats");
      ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats.prototype.context = null;
      ContextualizedQueryLatencyStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedQueryLatencyStats(properties);
      }, "create");
      ContextualizedQueryLatencyStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      }, "encode");
      ContextualizedQueryLatencyStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedQueryLatencyStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedQueryLatencyStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedQueryLatencyStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error3 = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        return null;
      }, "verify");
      ContextualizedQueryLatencyStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      }, "toObject");
      ContextualizedQueryLatencyStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedQueryLatencyStats;
    }();
    $root.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedTypeStats, "ContextualizedTypeStats");
      ContextualizedTypeStats.prototype.context = null;
      ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedTypeStats(properties);
      }, "create");
      ContextualizedTypeStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedTypeStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedTypeStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedTypeStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedTypeStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedTypeStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedTypeStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedTypeStats;
    }();
    $root.FieldStat = function() {
      function FieldStat(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(FieldStat, "FieldStat");
      FieldStat.prototype.returnType = "";
      FieldStat.prototype.errorsCount = 0;
      FieldStat.prototype.observedExecutionCount = 0;
      FieldStat.prototype.estimatedExecutionCount = 0;
      FieldStat.prototype.requestsWithErrorsCount = 0;
      FieldStat.prototype.latencyCount = $util.emptyArray;
      FieldStat.create = /* @__PURE__ */ __name(function create(properties) {
        return new FieldStat(properties);
      }, "create");
      FieldStat.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      }, "encode");
      FieldStat.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      FieldStat.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      FieldStat.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      FieldStat.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      }, "verify");
      FieldStat.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      }, "toObject");
      FieldStat.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return FieldStat;
    }();
    $root.TypeStat = function() {
      function TypeStat(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TypeStat, "TypeStat");
      TypeStat.prototype.perFieldStat = $util.emptyObject;
      TypeStat.create = /* @__PURE__ */ __name(function create(properties) {
        return new TypeStat(properties);
      }, "create");
      TypeStat.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TypeStat.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TypeStat.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TypeStat.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TypeStat.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error3)
              return "perFieldStat." + error3;
          }
        }
        return null;
      }, "verify");
      TypeStat.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TypeStat.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return TypeStat;
    }();
    $root.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReferencedFieldsForType, "ReferencedFieldsForType");
      ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType.prototype.isInterface = false;
      ReferencedFieldsForType.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReferencedFieldsForType(properties);
      }, "create");
      ReferencedFieldsForType.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      }, "encode");
      ReferencedFieldsForType.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReferencedFieldsForType.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReferencedFieldsForType.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReferencedFieldsForType.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      }, "verify");
      ReferencedFieldsForType.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      }, "toObject");
      ReferencedFieldsForType.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ReferencedFieldsForType;
    }();
    $root.Report = function() {
      function Report(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Report, "Report");
      Report.prototype.header = null;
      Report.prototype.tracesPerQuery = $util.emptyObject;
      Report.prototype.endTime = null;
      Report.prototype.operationCount = 0;
      Report.prototype.tracesPreAggregated = false;
      Report.create = /* @__PURE__ */ __name(function create(properties) {
        return new Report(properties);
      }, "create");
      Report.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      }, "encode");
      Report.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Report.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Report.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Report.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error3 = $root.ReportHeader.verify(message.header);
          if (error3)
            return "header." + error3;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error3)
              return "tracesPerQuery." + error3;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error3 = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      }, "verify");
      Report.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      }, "toObject");
      Report.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return Report;
    }();
    $root.ContextualizedStats = function() {
      function ContextualizedStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedStats, "ContextualizedStats");
      ContextualizedStats.prototype.context = null;
      ContextualizedStats.prototype.queryLatencyStats = null;
      ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedStats(properties);
      }, "create");
      ContextualizedStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error3 = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedStats;
    }();
    $root.TracesAndStats = function() {
      function TracesAndStats(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TracesAndStats, "TracesAndStats");
      TracesAndStats.prototype.trace = $util.emptyArray;
      TracesAndStats.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats.create = /* @__PURE__ */ __name(function create(properties) {
        return new TracesAndStats(properties);
      }, "create");
      TracesAndStats.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TracesAndStats.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TracesAndStats.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TracesAndStats.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TracesAndStats.verify = /* @__PURE__ */ __name(function verify2(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error3 = $root.Trace.verify(message.trace[i]);
              if (error3)
                return "trace." + error3;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error3 = $root.ContextualizedStats.verify(array2[i]);
            if (error3)
              return "statsWithContext." + error3;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error3)
              return "referencedFieldsByType." + error3;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error3 = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error3)
                return "internalTracesContributingToStats." + error3;
            }
        }
        return null;
      }, "verify");
      TracesAndStats.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TracesAndStats.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, "toJSON");
      return TracesAndStats;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Timestamp, "Timestamp");
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = /* @__PURE__ */ __name(function create(properties) {
            return new Timestamp(properties);
          }, "create");
          Timestamp.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          }, "encode");
          Timestamp.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Timestamp.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Timestamp.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Timestamp.verify = /* @__PURE__ */ __name(function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          }, "verify");
          Timestamp.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          }, "toObject");
          Timestamp.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          }, "toJSON");
          return Timestamp;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js
var require_calculateReferencedFieldsByType = __commonJS({
  "node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateReferencedFieldsByType = void 0;
    var graphql_1 = require_graphql2();
    var usage_reporting_protobuf_1 = require_protobuf2();
    function calculateReferencedFieldsByType({ document, schema, resolvedOperationName }) {
      const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document);
      const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""];
      if (!filteredDocument) {
        throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""}' not found`);
      }
      const typeInfo = new graphql_1.TypeInfo(schema);
      const interfaces = /* @__PURE__ */ new Set();
      const referencedFieldSetByType = /* @__PURE__ */ Object.create(null);
      (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
        Field(field) {
          const fieldName = field.name.value;
          const parentType = typeInfo.getParentType();
          if (!parentType) {
            throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);
          }
          const parentTypeName = parentType.name;
          if (!referencedFieldSetByType[parentTypeName]) {
            referencedFieldSetByType[parentTypeName] = /* @__PURE__ */ new Set();
            if ((0, graphql_1.isInterfaceType)(parentType)) {
              interfaces.add(parentTypeName);
            }
          }
          referencedFieldSetByType[parentTypeName].add(fieldName);
        }
      }));
      const referencedFieldsByType = /* @__PURE__ */ Object.create(null);
      for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {
        referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({
          fieldNames: [...fieldNames],
          isInterface: interfaces.has(typeName)
        });
      }
      return referencedFieldsByType;
    }
    __name(calculateReferencedFieldsByType, "calculateReferencedFieldsByType");
    exports2.calculateReferencedFieldsByType = calculateReferencedFieldsByType;
  }
});

// node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dropUnusedDefinitions = void 0;
    var graphql_1 = require_graphql2();
    function dropUnusedDefinitions(ast, operationName) {
      const separated = (0, graphql_1.separateOperations)(ast)[operationName];
      if (!separated) {
        return ast;
      }
      return separated;
    }
    __name(dropUnusedDefinitions, "dropUnusedDefinitions");
    exports2.dropUnusedDefinitions = dropUnusedDefinitions;
  }
});

// node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stripSensitiveLiterals = void 0;
    var graphql_1 = require_graphql2();
    function stripSensitiveLiterals(ast, options = {
      hideListAndObjectLiterals: false
    }) {
      const listAndObjectVisitorIfEnabled = options.hideListAndObjectLiterals ? {
        ListValue(node) {
          return { ...node, values: [] };
        },
        ObjectValue(node) {
          return { ...node, fields: [] };
        }
      } : {};
      return (0, graphql_1.visit)(ast, {
        IntValue(node) {
          return { ...node, value: "0" };
        },
        FloatValue(node) {
          return { ...node, value: "0" };
        },
        StringValue(node) {
          return { ...node, value: "", block: false };
        },
        ...listAndObjectVisitorIfEnabled
      });
    }
    __name(stripSensitiveLiterals, "stripSensitiveLiterals");
    exports2.stripSensitiveLiterals = stripSensitiveLiterals;
  }
});

// node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printWithReducedWhitespace = void 0;
    var graphql_1 = require_graphql2();
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = (0, graphql_1.visit)(ast, {
        StringValue(node) {
          return {
            ...node,
            value: Buffer.from(node.value, "utf8").toString("hex"),
            block: false
          };
        }
      });
      const withWhitespace = (0, graphql_1.print)(sanitizedAST);
      const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
    }
    __name(printWithReducedWhitespace, "printWithReducedWhitespace");
    exports2.printWithReducedWhitespace = printWithReducedWhitespace;
  }
});

// node_modules/@apollo/utils.removealiases/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@apollo/utils.removealiases/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeAliases = void 0;
    var graphql_1 = require_graphql2();
    function removeAliases(ast) {
      return (0, graphql_1.visit)(ast, {
        Field(node) {
          const { alias, ...rest } = node;
          return rest;
        }
      });
    }
    __name(removeAliases, "removeAliases");
    exports2.removeAliases = removeAliases;
  }
});

// node_modules/lodash.sortby/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.sortby/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    __name(baseSortBy, "baseSortBy");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash2(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash2, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete, "hashDelete");
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    __name(hashHas, "hashHas");
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    __name(Stack, "Stack");
    function stackClear() {
      this.__data__ = new ListCache();
    }
    __name(stackClear, "stackClear");
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    __name(stackDelete, "stackDelete");
    function stackGet(key) {
      return this.__data__.get(key);
    }
    __name(stackGet, "stackGet");
    function stackHas(key) {
      return this.__data__.has(key);
    }
    __name(stackHas, "stackHas");
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    __name(stackSet, "stackSet");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    __name(baseFlatten, "baseFlatten");
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    __name(baseForOwn, "baseForOwn");
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    __name(baseGetTag, "baseGetTag");
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject2(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    __name(baseIsTypedArray, "baseIsTypedArray");
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    __name(baseMap, "baseMap");
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get2(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    __name(baseOrderBy, "baseOrderBy");
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    __name(baseRest, "baseRest");
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    function castPath(value) {
      return isArray2(value) ? value : stringToPath(value);
    }
    __name(castPath, "castPath");
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    __name(compareAscending, "compareAscending");
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    __name(compareMultiple, "compareMultiple");
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    __name(createBaseEach, "createBaseEach");
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    __name(createBaseFor, "createBaseFor");
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    __name(equalArrays, "equalArrays");
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    __name(equalObjects, "equalObjects");
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
    }
    __name(hasPath, "hasPath");
    function isFlattenable(value) {
      return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    __name(isFlattenable, "isFlattenable");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isIterateeCall(value, index, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    __name(isIterateeCall, "isIterateeCall");
    function isKey(value, object) {
      if (isArray2(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction2(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject2, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString, "toString");
    function get2(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    __name(get2, "get");
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    __name(hasIn, "hasIn");
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    __name(property, "property");
    module2.exports = sortBy;
  }
});

// node_modules/@apollo/utils.sortast/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@apollo/utils.sortast/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortAST = void 0;
    var graphql_1 = require_graphql2();
    var lodash_sortby_1 = __importDefault(require_lodash());
    function sortAST(ast) {
      return (0, graphql_1.visit)(ast, {
        Document(node) {
          return {
            ...node,
            definitions: (0, lodash_sortby_1.default)(node.definitions, "kind", "name.value")
          };
        },
        OperationDefinition(node) {
          return sortVariableDefinitions(node);
        },
        SelectionSet(node) {
          return {
            ...node,
            selections: (0, lodash_sortby_1.default)(node.selections, "kind", "name.value")
          };
        },
        Field(node) {
          return sortArguments(node);
        },
        FragmentSpread(node) {
          return sortDirectives(node);
        },
        InlineFragment(node) {
          return sortDirectives(node);
        },
        FragmentDefinition(node) {
          return sortDirectives(sortVariableDefinitions(node));
        },
        Directive(node) {
          return sortArguments(node);
        }
      });
    }
    __name(sortAST, "sortAST");
    exports2.sortAST = sortAST;
    function sortDirectives(node) {
      return "directives" in node ? { ...node, directives: (0, lodash_sortby_1.default)(node.directives, "name.value") } : node;
    }
    __name(sortDirectives, "sortDirectives");
    function sortArguments(node) {
      return "arguments" in node ? { ...node, arguments: (0, lodash_sortby_1.default)(node.arguments, "name.value") } : node;
    }
    __name(sortArguments, "sortArguments");
    function sortVariableDefinitions(node) {
      return "variableDefinitions" in node ? {
        ...node,
        variableDefinitions: (0, lodash_sortby_1.default)(node.variableDefinitions, "variable.name.value")
      } : node;
    }
    __name(sortVariableDefinitions, "sortVariableDefinitions");
  }
});

// node_modules/@apollo/utils.usagereporting/dist/signature.js
var require_signature = __commonJS({
  "node_modules/@apollo/utils.usagereporting/dist/signature.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = void 0;
    var utils_dropunuseddefinitions_1 = require_dist4();
    var utils_stripsensitiveliterals_1 = require_dist5();
    var utils_printwithreducedwhitespace_1 = require_dist6();
    var utils_removealiases_1 = require_dist7();
    var utils_sortast_1 = require_dist8();
    function usageReportingSignature(ast, operationName) {
      return (0, utils_printwithreducedwhitespace_1.printWithReducedWhitespace)((0, utils_sortast_1.sortAST)((0, utils_removealiases_1.removeAliases)((0, utils_stripsensitiveliterals_1.stripSensitiveLiterals)((0, utils_dropunuseddefinitions_1.dropUnusedDefinitions)(ast, operationName), {
        hideListAndObjectLiterals: true
      }))));
    }
    __name(usageReportingSignature, "usageReportingSignature");
    exports2.usageReportingSignature = usageReportingSignature;
  }
});

// node_modules/@apollo/utils.usagereporting/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@apollo/utils.usagereporting/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = exports2.calculateReferencedFieldsByType = void 0;
    var calculateReferencedFieldsByType_1 = require_calculateReferencedFieldsByType();
    Object.defineProperty(exports2, "calculateReferencedFieldsByType", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return calculateReferencedFieldsByType_1.calculateReferencedFieldsByType;
    }, "get") });
    var signature_1 = require_signature();
    Object.defineProperty(exports2, "usageReportingSignature", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return signature_1.usageReportingSignature;
    }, "get") });
  }
});

// node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js
var require_traceTreeBuilder = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateToProtoTimestamp = exports2.TraceTreeBuilder = void 0;
    var graphql_1 = require_graphql2();
    var apollo_reporting_protobuf_1 = require_generated();
    function internalError(message) {
      return new Error(`[internal apollo-server error] ${message}`);
    }
    __name(internalError, "internalError");
    var TraceTreeBuilder = class {
      static {
        __name(this, "TraceTreeBuilder");
      }
      constructor(options) {
        this.rootNode = new apollo_reporting_protobuf_1.Trace.Node();
        this.logger = console;
        this.trace = new apollo_reporting_protobuf_1.Trace({
          root: this.rootNode,
          fieldExecutionWeight: 1
        });
        this.stopped = false;
        this.nodes = /* @__PURE__ */ new Map([
          [responsePathAsString(), this.rootNode]
        ]);
        this.rewriteError = options.rewriteError;
        if (options.logger)
          this.logger = options.logger;
      }
      startTiming() {
        if (this.startHrTime) {
          throw internalError("startTiming called twice!");
        }
        if (this.stopped) {
          throw internalError("startTiming called after stopTiming!");
        }
        this.trace.startTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.startHrTime = process.hrtime();
      }
      stopTiming() {
        if (!this.startHrTime) {
          throw internalError("stopTiming called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("stopTiming called twice!");
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.stopped = true;
      }
      willResolveField(info3) {
        if (!this.startHrTime) {
          throw internalError("willResolveField called before startTiming!");
        }
        if (this.stopped) {
          return () => {
          };
        }
        const path = info3.path;
        const node = this.newNode(path);
        node.type = info3.returnType.toString();
        node.parentType = info3.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === "string" && path.key !== info3.fieldName) {
          node.originalFieldName = info3.fieldName;
        }
        return () => {
          node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
      }
      didEncounterErrors(errors) {
        errors.forEach((err) => {
          var _a;
          if ((_a = err.extensions) === null || _a === void 0 ? void 0 : _a.serviceName) {
            return;
          }
          const errorForReporting = this.rewriteAndNormalizeError(err);
          if (errorForReporting === null) {
            return;
          }
          this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
      }
      addProtobufError(path, error3) {
        if (!this.startHrTime) {
          throw internalError("addProtobufError called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("addProtobufError called after stopTiming!");
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
          const specificNode = this.nodes.get(path.join("."));
          if (specificNode) {
            node = specificNode;
          } else {
            this.logger.warn(`Could not find node with path ${path.join(".")}; defaulting to put errors on root node.`);
          }
        }
        node.error.push(error3);
      }
      newNode(path) {
        const node = new apollo_reporting_protobuf_1.Trace.Node();
        const id = path.key;
        if (typeof id === "number") {
          node.index = id;
        } else {
          node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
      }
      ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
          return parentNode;
        }
        return this.newNode(path.prev);
      }
      rewriteAndNormalizeError(err) {
        if (this.rewriteError) {
          const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
          const rewrittenError = this.rewriteError(clonedError);
          if (rewrittenError === null) {
            return null;
          }
          if (!(rewrittenError instanceof graphql_1.GraphQLError)) {
            return err;
          }
          return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);
        }
        return err;
      }
    };
    exports2.TraceTreeBuilder = TraceTreeBuilder;
    function durationHrTimeToNanos(hrtime4) {
      return hrtime4[0] * 1e9 + hrtime4[1];
    }
    __name(durationHrTimeToNanos, "durationHrTimeToNanos");
    function responsePathAsString(p) {
      if (p === void 0) {
        return "";
      }
      let res = String(p.key);
      while ((p = p.prev) !== void 0) {
        res = `${p.key}.${res}`;
      }
      return res;
    }
    __name(responsePathAsString, "responsePathAsString");
    function errorToProtobufError(error3) {
      return new apollo_reporting_protobuf_1.Trace.Error({
        message: error3.message,
        location: (error3.locations || []).map(({ line, column }) => new apollo_reporting_protobuf_1.Trace.Location({ line, column })),
        json: JSON.stringify(error3)
      });
    }
    __name(errorToProtobufError, "errorToProtobufError");
    function dateToProtoTimestamp(date) {
      const totalMillis = +date;
      const millis = totalMillis % 1e3;
      return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1e3,
        nanos: millis * 1e6
      });
    }
    __name(dateToProtoTimestamp, "dateToProtoTimestamp");
    exports2.dateToProtoTimestamp = dateToProtoTimestamp;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js
var require_traceDetails = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeTraceDetails = void 0;
    var apollo_reporting_protobuf_1 = require_generated();
    function makeTraceDetails(variables, sendVariableValues, operationString) {
      const details = new apollo_reporting_protobuf_1.Trace.Details();
      const variablesToRecord = (() => {
        if (sendVariableValues && "transform" in sendVariableValues) {
          const originalKeys = Object.keys(variables);
          try {
            const modifiedVariables = sendVariableValues.transform({
              variables,
              operationString
            });
            return cleanModifiedVariables(originalKeys, modifiedVariables);
          } catch (e) {
            return handleVariableValueTransformError(originalKeys);
          }
        } else {
          return variables;
        }
      })();
      Object.keys(variablesToRecord).forEach((name) => {
        if (!sendVariableValues || "none" in sendVariableValues && sendVariableValues.none || "all" in sendVariableValues && !sendVariableValues.all || "exceptNames" in sendVariableValues && sendVariableValues.exceptNames.includes(name) || "onlyNames" in sendVariableValues && !sendVariableValues.onlyNames.includes(name)) {
          details.variablesJson[name] = "";
        } else {
          try {
            details.variablesJson[name] = typeof variablesToRecord[name] === "undefined" ? "" : JSON.stringify(variablesToRecord[name]);
          } catch (e) {
            details.variablesJson[name] = JSON.stringify("[Unable to convert value to JSON]");
          }
        }
      });
      return details;
    }
    __name(makeTraceDetails, "makeTraceDetails");
    exports2.makeTraceDetails = makeTraceDetails;
    function handleVariableValueTransformError(variableNames) {
      const modifiedVariables = /* @__PURE__ */ Object.create(null);
      variableNames.forEach((name) => {
        modifiedVariables[name] = "[PREDICATE_FUNCTION_ERROR]";
      });
      return modifiedVariables;
    }
    __name(handleVariableValueTransformError, "handleVariableValueTransformError");
    function cleanModifiedVariables(originalKeys, modifiedVariables) {
      const cleanedVariables = /* @__PURE__ */ Object.create(null);
      originalKeys.forEach((name) => {
        cleanedVariables[name] = modifiedVariables[name];
      });
      return cleanedVariables;
    }
    __name(cleanModifiedVariables, "cleanModifiedVariables");
  }
});

// node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/rng.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var getRandomValues2;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues2) {
        getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues2) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues2(rnds8);
    }
    __name(rng, "rng");
  }
});

// node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/regex.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/validate.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    __name(validate, "validate");
    var _default = validate;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    __name(unsafeStringify, "unsafeStringify");
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    __name(stringify, "stringify");
    var _default = stringify;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v1.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    __name(v1, "v1");
    var _default = v1;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/parse.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    __name(parse, "parse");
    var _default = parse;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v35.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.URL = exports2.DNS = void 0;
    exports2.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    __name(stringToBytes, "stringToBytes");
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function v35(name, version3, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version3;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      __name(generateUUID, "generateUUID");
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
    __name(v35, "v35");
  }
});

// node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/md5.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    __name(md5, "md5");
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    __name(md5ToHexEncodedArray, "md5ToHexEncodedArray");
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    __name(getOutputLength, "getOutputLength");
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    __name(wordsToMd5, "wordsToMd5");
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    __name(bytesToWords, "bytesToWords");
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    __name(safeAdd, "safeAdd");
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    __name(bitRotateLeft, "bitRotateLeft");
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    __name(md5cmn, "md5cmn");
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    __name(md5ff, "md5ff");
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    __name(md5gg, "md5gg");
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    __name(md5hh, "md5hh");
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    __name(md5ii, "md5ii");
    var _default = md5;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v3.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/native.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID: randomUUID2
    };
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v4.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    __name(v4, "v4");
    var _default = v4;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha12 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    __name(f, "f");
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    __name(ROTL, "ROTL");
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    __name(sha1, "sha1");
    var _default = sha1;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v5.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha12());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/nil.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/version.js
var require_version2 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/version.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function version3(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    __name(version3, "version");
    var _default = version3;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _nil.default;
      }, "get")
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _parse.default;
      }, "get")
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _stringify.default;
      }, "get")
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _v.default;
      }, "get")
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _v2.default;
      }, "get")
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _v3.default;
      }, "get")
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _v4.default;
      }, "get")
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _validate.default;
      }, "get")
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get2() {
        return _version.default;
      }, "get")
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version2());
    var _validate = _interopRequireDefault(require_validate3());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
  }
});

// node_modules/graphql-tag/lib/graphql-tag.umd.js
var require_graphql_tag_umd = __commonJS({
  "node_modules/graphql-tag/lib/graphql-tag.umd.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_tslib(), require_graphql2()) : typeof define === "function" && define.amd ? define(["exports", "tslib", "graphql"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["graphql-tag"] = {}, global2.tslib, global2.graphql));
    })(exports2, function(exports3, tslib, graphql) {
      "use strict";
      var docCache = /* @__PURE__ */ new Map();
      var fragmentSourceMap = /* @__PURE__ */ new Map();
      var printFragmentWarnings = true;
      var experimentalFragmentVariables = false;
      function normalize(string) {
        return string.replace(/[\s,]+/g, " ").trim();
      }
      __name(normalize, "normalize");
      function cacheKeyFromLoc(loc) {
        return normalize(loc.source.body.substring(loc.start, loc.end));
      }
      __name(cacheKeyFromLoc, "cacheKeyFromLoc");
      function processFragments(ast) {
        var seenKeys = /* @__PURE__ */ new Set();
        var definitions = [];
        ast.definitions.forEach(function(fragmentDefinition) {
          if (fragmentDefinition.kind === "FragmentDefinition") {
            var fragmentName = fragmentDefinition.name.value;
            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
            var sourceKeySet = fragmentSourceMap.get(fragmentName);
            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
              if (printFragmentWarnings) {
                console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
              }
            } else if (!sourceKeySet) {
              fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
            }
            sourceKeySet.add(sourceKey);
            if (!seenKeys.has(sourceKey)) {
              seenKeys.add(sourceKey);
              definitions.push(fragmentDefinition);
            }
          } else {
            definitions.push(fragmentDefinition);
          }
        });
        return tslib.__assign(tslib.__assign({}, ast), { definitions });
      }
      __name(processFragments, "processFragments");
      function stripLoc(doc) {
        var workSet = new Set(doc.definitions);
        workSet.forEach(function(node) {
          if (node.loc)
            delete node.loc;
          Object.keys(node).forEach(function(key) {
            var value = node[key];
            if (value && typeof value === "object") {
              workSet.add(value);
            }
          });
        });
        var loc = doc.loc;
        if (loc) {
          delete loc.startToken;
          delete loc.endToken;
        }
        return doc;
      }
      __name(stripLoc, "stripLoc");
      function parseDocument(source) {
        var cacheKey = normalize(source);
        if (!docCache.has(cacheKey)) {
          var parsed = graphql.parse(source, {
            experimentalFragmentVariables,
            allowLegacyFragmentVariables: experimentalFragmentVariables
          });
          if (!parsed || parsed.kind !== "Document") {
            throw new Error("Not a valid GraphQL document.");
          }
          docCache.set(cacheKey, stripLoc(processFragments(parsed)));
        }
        return docCache.get(cacheKey);
      }
      __name(parseDocument, "parseDocument");
      function gql2(literals) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof literals === "string") {
          literals = [literals];
        }
        var result = literals[0];
        args.forEach(function(arg, i) {
          if (arg && arg.kind === "Document") {
            result += arg.loc.source.body;
          } else {
            result += arg;
          }
          result += literals[i + 1];
        });
        return parseDocument(result);
      }
      __name(gql2, "gql");
      function resetCaches() {
        docCache.clear();
        fragmentSourceMap.clear();
      }
      __name(resetCaches, "resetCaches");
      function disableFragmentWarnings() {
        printFragmentWarnings = false;
      }
      __name(disableFragmentWarnings, "disableFragmentWarnings");
      function enableExperimentalFragmentVariables() {
        experimentalFragmentVariables = true;
      }
      __name(enableExperimentalFragmentVariables, "enableExperimentalFragmentVariables");
      function disableExperimentalFragmentVariables() {
        experimentalFragmentVariables = false;
      }
      __name(disableExperimentalFragmentVariables, "disableExperimentalFragmentVariables");
      var extras = {
        gql: gql2,
        resetCaches,
        disableFragmentWarnings,
        enableExperimentalFragmentVariables,
        disableExperimentalFragmentVariables
      };
      (function(gql_1) {
        gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
      })(gql2 || (gql2 = {}));
      gql2["default"] = gql2;
      var gql$1 = gql2;
      exports3.default = gql$1;
      exports3.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
      exports3.disableFragmentWarnings = disableFragmentWarnings;
      exports3.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
      exports3.gql = gql2;
      exports3.resetCaches = resetCaches;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/graphql-tag/main.js
var require_main = __commonJS({
  "node_modules/graphql-tag/main.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = require_graphql_tag_umd().gql;
  }
});

// node_modules/apollo-server-core/dist/gql.js
var require_gql = __commonJS({
  "node_modules/apollo-server-core/dist/gql.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gql = void 0;
    var graphql_tag_1 = __importDefault(require_main());
    exports2.gql = graphql_tag_1.default;
  }
});

// node_modules/apollo-server-core/package.json
var require_package = __commonJS({
  "node_modules/apollo-server-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "apollo-server-core",
      version: "3.13.0",
      description: "Core engine for Apollo GraphQL server",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/apollographql/apollo-server",
        directory: "packages/apollo-server-core"
      },
      keywords: [
        "GraphQL",
        "Apollo",
        "Server",
        "Javascript"
      ],
      author: "Apollo <packages@apollographql.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/apollographql/apollo-server/issues"
      },
      homepage: "https://github.com/apollographql/apollo-server#readme",
      engines: {
        node: ">=12.0"
      },
      dependencies: {
        "@apollo/utils.keyvaluecache": "^1.0.1",
        "@apollo/utils.logger": "^1.0.0",
        "@apollo/utils.usagereporting": "^1.0.0",
        "@apollographql/apollo-tools": "^0.5.3",
        "@apollographql/graphql-playground-html": "1.6.29",
        "@graphql-tools/mock": "^8.1.2",
        "@graphql-tools/schema": "^8.0.0",
        "@josephg/resolvable": "^1.0.0",
        "apollo-datasource": "^3.3.2",
        "apollo-reporting-protobuf": "^3.4.0",
        "apollo-server-env": "^4.2.1",
        "apollo-server-errors": "^3.3.1",
        "apollo-server-plugin-base": "^3.7.2",
        "apollo-server-types": "^3.8.0",
        "async-retry": "^1.2.1",
        "fast-json-stable-stringify": "^2.1.0",
        "graphql-tag": "^2.11.0",
        loglevel: "^1.6.8",
        "lru-cache": "^6.0.0",
        "node-abort-controller": "^3.0.1",
        "sha.js": "^2.4.11",
        uuid: "^9.0.0",
        "whatwg-mimetype": "^3.0.0"
      },
      peerDependencies: {
        graphql: "^15.3.0 || ^16.0.0"
      },
      gitHead: "f93284e853efd6da46d91ae40da47a2dd15b61fe"
    };
  }
});

// node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js
var require_schemaReporter = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SchemaReporter = exports2.schemaReportGql = void 0;
    var gql_1 = require_gql();
    var apollo_server_env_1 = require_index_browser();
    var graphql_1 = require_graphql2();
    exports2.schemaReportGql = (0, graphql_1.print)((0, gql_1.gql)`
  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
    reportSchema(report: $report, coreSchema: $coreSchema) {
      __typename
      ... on ReportSchemaError {
        message
        code
      }
      ... on ReportSchemaResponse {
        inSeconds
        withCoreSchema
      }
    }
  }
`);
    var SchemaReporter = class {
      static {
        __name(this, "SchemaReporter");
      }
      constructor(options) {
        var _a;
        this.headers = new apollo_server_env_1.Headers();
        this.headers.set("Content-Type", "application/json");
        this.headers.set("x-api-key", options.apiKey);
        this.headers.set("apollographql-client-name", "ApolloServerPluginSchemaReporting");
        this.headers.set("apollographql-client-version", require_package().version);
        this.endpointUrl = options.endpointUrl || "https://schema-reporting.api.apollographql.com/api/graphql";
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;
      }
      stopped() {
        return this.isStopped;
      }
      start() {
        this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
      }
      stop() {
        this.isStopped = true;
        if (this.pollTimer) {
          clearTimeout(this.pollTimer);
          this.pollTimer = void 0;
        }
      }
      async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = void 0;
        if (this.stopped())
          return;
        try {
          const result = await this.reportSchema(sendNextWithCoreSchema);
          if (!result) {
            return;
          }
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1e3);
          }
          return;
        } catch (error3) {
          this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error3}`);
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
          }
        }
      }
      async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
          report: this.schemaReport,
          coreSchema: withCoreSchema ? this.coreSchema : null
        });
        if (errors) {
          throw new Error(errors.map((x) => x.message).join("\n"));
        }
        function msgForUnexpectedResponse(data2) {
          return [
            "Unexpected response shape from Apollo when",
            "reporting schema. If this continues, please reach",
            "out to support@apollographql.com.",
            "Received response:",
            JSON.stringify(data2)
          ].join(" ");
        }
        __name(msgForUnexpectedResponse, "msgForUnexpectedResponse");
        if (!data || !data.reportSchema) {
          throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === "ReportSchemaResponse") {
          return data.reportSchema;
        } else if (data.reportSchema.__typename === "ReportSchemaError") {
          this.logger.error([
            "Received input validation error from Apollo:",
            data.reportSchema.message,
            "Stopping reporting. Please fix the input errors."
          ].join(" "));
          this.stop();
          return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
      }
      async apolloQuery(variables) {
        const request2 = {
          query: exports2.schemaReportGql,
          variables
        };
        const httpRequest = new apollo_server_env_1.Request(this.endpointUrl, {
          method: "POST",
          headers: this.headers,
          body: JSON.stringify(request2)
        });
        const httpResponse = await this.fetcher(httpRequest);
        if (!httpResponse.ok) {
          throw new Error([
            `An unexpected HTTP status code (${httpResponse.status}) was`,
            "encountered during schema reporting."
          ].join(" "));
        }
        try {
          return await httpResponse.json();
        } catch (error3) {
          throw new Error([
            "Couldn't report schema to Apollo.",
            "Parsing response as JSON failed.",
            "If this continues please reach out to support@apollographql.com",
            error3
          ].join(" "));
        }
      }
    };
    exports2.SchemaReporter = SchemaReporter;
  }
});

// node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js
var require_schemaIsFederated = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.schemaIsFederated = void 0;
    var graphql_1 = require_graphql2();
    function schemaIsFederated(schema) {
      const serviceType = schema.getType("_Service");
      if (!(0, graphql_1.isObjectType)(serviceType)) {
        return false;
      }
      const sdlField = serviceType.getFields().sdl;
      if (!sdlField) {
        return false;
      }
      const sdlFieldType = sdlField.type;
      if (!(0, graphql_1.isScalarType)(sdlFieldType)) {
        return false;
      }
      return sdlFieldType.name == "String";
    }
    __name(schemaIsFederated, "schemaIsFederated");
    exports2.schemaIsFederated = schemaIsFederated;
  }
});

// node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js
var require_schemaReporting = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeCoreSchemaHash = exports2.ApolloServerPluginSchemaReporting = void 0;
    var os_1 = __importDefault(require_os());
    var uuid_1 = require_commonjs_browser();
    var graphql_1 = require_graphql2();
    var schemaReporter_1 = require_schemaReporter();
    var createSHA_1 = __importDefault(require_createSHA());
    var schemaIsFederated_1 = require_schemaIsFederated();
    function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher } = /* @__PURE__ */ Object.create(null)) {
      const bootId = (0, uuid_1.v4)();
      return {
        __internal_plugin_id__() {
          return "SchemaReporting";
        },
        async serverWillStart({ apollo, schema, logger }) {
          const { key, graphRef } = apollo;
          if (!key) {
            throw Error("To use ApolloServerPluginSchemaReporting, you must provide an Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`");
          }
          if (!graphRef) {
            throw Error("To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, 'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment variable or passing `new ApolloServer({apollo: {graphRef}})`.");
          }
          if (overrideReportedSchema) {
            try {
              const validationErrors = (0, graphql_1.validateSchema)((0, graphql_1.buildSchema)(overrideReportedSchema, { noLocation: true }));
              if (validationErrors.length) {
                throw new Error(validationErrors.map((error3) => error3.message).join("\n"));
              }
            } catch (err) {
              throw new Error(`The schema provided to overrideReportedSchema failed to parse or validate: ${err.message}`);
            }
          }
          if ((0, schemaIsFederated_1.schemaIsFederated)(schema)) {
            throw Error([
              "Schema reporting is not yet compatible with federated services.",
              "If you're interested in using schema reporting with federated",
              "services, please contact Apollo support. To set up managed federation, see",
              "https://go.apollo.dev/s/managed-federation"
            ].join(" "));
          }
          if (endpointUrl !== void 0) {
            logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
          }
          const baseSchemaReport = {
            bootId,
            graphRef,
            platform: process.env.APOLLO_SERVER_PLATFORM || "local",
            runtimeVersion: `node ${process.version}`,
            userVersion: process.env.APOLLO_SERVER_USER_VERSION,
            serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_1.default.hostname(),
            libraryVersion: `apollo-server-core@${require_package().version}`
          };
          let currentSchemaReporter;
          return {
            schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
              var _a;
              if (overrideReportedSchema !== void 0) {
                if (currentSchemaReporter) {
                  return;
                } else {
                  logger.info("Apollo schema reporting: schema to report has been overridden");
                }
              }
              const coreSchema = (_a = overrideReportedSchema !== null && overrideReportedSchema !== void 0 ? overrideReportedSchema : coreSupergraphSdl) !== null && _a !== void 0 ? _a : (0, graphql_1.printSchema)(apiSchema);
              const coreSchemaHash = computeCoreSchemaHash(coreSchema);
              const schemaReport = {
                ...baseSchemaReport,
                coreSchemaHash
              };
              currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
              currentSchemaReporter = new schemaReporter_1.SchemaReporter({
                schemaReport,
                coreSchema,
                apiKey: key,
                endpointUrl,
                logger,
                initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs !== null && initialDelayMaxMs !== void 0 ? initialDelayMaxMs : 1e4)),
                fallbackReportingDelayInMs: 2e4,
                fetcher
              });
              currentSchemaReporter.start();
              logger.info(`Apollo schema reporting: reporting a new schema to Studio! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
            },
            async serverWillStop() {
              currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
            }
          };
        }
      };
    }
    __name(ApolloServerPluginSchemaReporting, "ApolloServerPluginSchemaReporting");
    exports2.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
    function computeCoreSchemaHash(schema) {
      return (0, createSHA_1.default)("sha256").update(schema).digest("hex");
    }
    __name(computeCoreSchemaHash, "computeCoreSchemaHash");
    exports2.computeCoreSchemaHash = computeCoreSchemaHash;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js
var require_durationHistogram = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DurationHistogram = void 0;
    var DurationHistogram = class _DurationHistogram {
      static {
        __name(this, "DurationHistogram");
      }
      constructor(options) {
        const initSize = (options === null || options === void 0 ? void 0 : options.initSize) || 74;
        const buckets = options === null || options === void 0 ? void 0 : options.buckets;
        const arrayInitSize = Math.max((buckets === null || buckets === void 0 ? void 0 : buckets.length) || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
          buckets.forEach((val, index) => this.buckets[index] = val);
        }
      }
      toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets) {
          if (value === 0) {
            bufferedZeroes++;
          } else {
            if (bufferedZeroes === 1) {
              outputArray.push(0);
            } else if (bufferedZeroes !== 0) {
              outputArray.push(-bufferedZeroes);
            }
            outputArray.push(Math.floor(value));
            bufferedZeroes = 0;
          }
        }
        return outputArray;
      }
      static durationToBucket(durationNs) {
        const log4 = Math.log(durationNs / 1e3);
        const unboundedBucket = Math.ceil(log4 / _DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= _DurationHistogram.BUCKET_COUNT ? _DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;
      }
      incrementDuration(durationNs, value = 1) {
        this.incrementBucket(_DurationHistogram.durationToBucket(durationNs), value);
        return this;
      }
      incrementBucket(bucket, value = 1) {
        if (bucket >= _DurationHistogram.BUCKET_COUNT) {
          throw Error("Bucket is out of bounds of the buckets array");
        }
        if (bucket >= this.buckets.length) {
          const oldLength = this.buckets.length;
          this.buckets.length = bucket + 1;
          this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
      }
      combine(otherHistogram) {
        for (let i = 0; i < otherHistogram.buckets.length; i++) {
          this.incrementBucket(i, otherHistogram.buckets[i]);
        }
      }
    };
    exports2.DurationHistogram = DurationHistogram;
    DurationHistogram.BUCKET_COUNT = 384;
    DurationHistogram.EXPONENT_LOG = Math.log(1.1);
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js
var require_iterateOverTrace = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iterateOverTrace = void 0;
    function iterateOverTrace(trace3, f, includePath) {
      const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;
      if (trace3.root) {
        if (iterateOverTraceNode(trace3.root, rootPath, f))
          return;
      }
      if (trace3.queryPlan) {
        if (iterateOverQueryPlan(trace3.queryPlan, rootPath, f))
          return;
      }
    }
    __name(iterateOverTrace, "iterateOverTrace");
    exports2.iterateOverTrace = iterateOverTrace;
    function iterateOverQueryPlan(node, rootPath, f) {
      var _a, _b, _c, _d, _e;
      if (!node)
        return false;
      if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {
        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
      }
      if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {
        return iterateOverQueryPlan(node.flatten.node, rootPath, f);
      }
      if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {
        return node.parallel.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
      }
      if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {
        return node.sequence.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
      }
      return false;
    }
    __name(iterateOverQueryPlan, "iterateOverQueryPlan");
    function iterateOverTraceNode(node, path, f) {
      var _a, _b;
      if (f(node, path)) {
        return true;
      }
      return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some((child) => {
        const childPath = child.responseName ? path.child(child.responseName) : path;
        return iterateOverTraceNode(child, childPath, f);
      })) !== null && _b !== void 0 ? _b : false;
    }
    __name(iterateOverTraceNode, "iterateOverTraceNode");
    var notCollectingPathsResponseNamePath = {
      toArray() {
        throw Error("not collecting paths!");
      },
      child() {
        return this;
      }
    };
    var RootCollectingPathsResponseNamePath = class {
      static {
        __name(this, "RootCollectingPathsResponseNamePath");
      }
      toArray() {
        return [];
      }
      child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
    var ChildCollectingPathsResponseNamePath = class _ChildCollectingPathsResponseNamePath {
      static {
        __name(this, "ChildCollectingPathsResponseNamePath");
      }
      constructor(responseName, prev) {
        this.responseName = responseName;
        this.prev = prev;
      }
      toArray() {
        const out = [];
        let curr = this;
        while (curr instanceof _ChildCollectingPathsResponseNamePath) {
          out.push(curr.responseName);
          curr = curr.prev;
        }
        return out.reverse();
      }
      child(responseName) {
        return new _ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js
var require_stats = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OurContextualizedStats = exports2.OurReport = exports2.SizeEstimator = void 0;
    var durationHistogram_1 = require_durationHistogram();
    var apollo_reporting_protobuf_1 = require_generated();
    var iterateOverTrace_1 = require_iterateOverTrace();
    var SizeEstimator = class {
      static {
        __name(this, "SizeEstimator");
      }
      constructor() {
        this.bytes = 0;
      }
    };
    exports2.SizeEstimator = SizeEstimator;
    var OurReport = class {
      static {
        __name(this, "OurReport");
      }
      constructor(header) {
        this.header = header;
        this.tracesPreAggregated = false;
        this.tracesPerQuery = /* @__PURE__ */ Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
      }
      ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
          tracesAndStats.ensureCountsAreIntegers();
        }
      }
      addTrace({ statsReportKey, trace: trace3, asTrace, includeTracesContributingToStats, referencedFieldsByType }) {
        const tracesAndStats = this.getTracesAndStats({
          statsReportKey,
          referencedFieldsByType
        });
        if (asTrace) {
          const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace3).finish();
          tracesAndStats.trace.push(encodedTrace);
          this.sizeEstimator.bytes += 2 + encodedTrace.length;
        } else {
          tracesAndStats.statsWithContext.addTrace(trace3, this.sizeEstimator);
          if (includeTracesContributingToStats) {
            const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace3).finish();
            tracesAndStats.internalTracesContributingToStats.push(encodedTrace);
            this.sizeEstimator.bytes += 2 + encodedTrace.length;
          }
        }
      }
      getTracesAndStats({ statsReportKey, referencedFieldsByType }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
          return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
          this.sizeEstimator.bytes += 2 + 2;
          if (referencedFieldsForType.isInterface) {
            this.sizeEstimator.bytes += 2;
          }
          this.sizeEstimator.bytes += estimatedBytesForString(typeName);
          for (const fieldName of referencedFieldsForType.fieldNames) {
            this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
          }
        }
        return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);
      }
    };
    exports2.OurReport = OurReport;
    var OurTracesAndStats = class {
      static {
        __name(this, "OurTracesAndStats");
      }
      constructor(referencedFieldsByType) {
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
      }
      ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
      }
    };
    var StatsByContext = class {
      static {
        __name(this, "StatsByContext");
      }
      constructor() {
        this.map = /* @__PURE__ */ Object.create(null);
      }
      toArray() {
        return Object.values(this.map);
      }
      ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)) {
          contextualizedStats.ensureCountsAreIntegers();
        }
      }
      addTrace(trace3, sizeEstimator) {
        this.getContextualizedStats(trace3, sizeEstimator).addTrace(trace3, sizeEstimator);
      }
      getContextualizedStats(trace3, sizeEstimator) {
        const statsContext = {
          clientName: trace3.clientName,
          clientVersion: trace3.clientVersion
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += 20 + estimatedBytesForString(trace3.clientName) + estimatedBytesForString(trace3.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
      }
    };
    var OurContextualizedStats = class {
      static {
        __name(this, "OurContextualizedStats");
      }
      constructor(context2) {
        this.context = context2;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = /* @__PURE__ */ Object.create(null);
      }
      ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)) {
          typeStat.ensureCountsAreIntegers();
        }
      }
      addTrace(trace3, sizeEstimator) {
        var _a;
        const { fieldExecutionWeight } = trace3;
        if (!fieldExecutionWeight) {
          this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace3.fullQueryCacheHit) {
          this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace3.durationNs);
          this.queryLatencyStats.cacheHits++;
        } else {
          this.queryLatencyStats.latencyCount.incrementDuration(trace3.durationNs);
        }
        if (!trace3.fullQueryCacheHit && ((_a = trace3.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {
          switch (trace3.cachePolicy.scope) {
            case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:
              this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace3.cachePolicy.maxAgeNs);
              break;
            case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:
              this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace3.cachePolicy.maxAgeNs);
              break;
          }
        }
        if (trace3.persistedQueryHit) {
          this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace3.persistedQueryRegister) {
          this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace3.forbiddenOperation) {
          this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace3.registeredOperation) {
          this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const traceNodeStats = /* @__PURE__ */ __name((node, path) => {
          var _a2, _b, _c, _d, _e;
          if ((_a2 = node.error) === null || _a2 === void 0 ? void 0 : _a2.length) {
            hasError = true;
            let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
            path.toArray().forEach((subPath) => {
              currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
            });
            currPathErrorStats.requestsWithErrorsCount += 1;
            currPathErrorStats.errorsCount += node.error.length;
          }
          if (fieldExecutionWeight) {
            const fieldName = node.originalFieldName || node.responseName;
            if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {
              const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
              const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
              fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
              fieldStat.observedExecutionCount++;
              fieldStat.estimatedExecutionCount += fieldExecutionWeight;
              fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;
              fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
            }
          }
          return false;
        }, "traceNodeStats");
        (0, iterateOverTrace_1.iterateOverTrace)(trace3, traceNodeStats, true);
        if (hasError) {
          this.queryLatencyStats.requestsWithErrorsCount++;
        }
      }
      getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
      }
    };
    exports2.OurContextualizedStats = OurContextualizedStats;
    var OurQueryLatencyStats = class {
      static {
        __name(this, "OurQueryLatencyStats");
      }
      constructor() {
        this.latencyCount = new durationHistogram_1.DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
      }
    };
    var OurPathErrorStats = class _OurPathErrorStats {
      static {
        __name(this, "OurPathErrorStats");
      }
      constructor() {
        this.children = /* @__PURE__ */ Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
      }
      getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
          return existing;
        }
        const child = new _OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
      }
    };
    var OurTypeStat = class {
      static {
        __name(this, "OurTypeStat");
      }
      constructor() {
        this.perFieldStat = /* @__PURE__ */ Object.create(null);
      }
      getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
      }
      ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)) {
          fieldStat.ensureCountsAreIntegers();
        }
      }
    };
    var OurFieldStat = class {
      static {
        __name(this, "OurFieldStat");
      }
      constructor(returnType) {
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new durationHistogram_1.DurationHistogram();
      }
      ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
      }
    };
    function estimatedBytesForString(s) {
      return 2 + Buffer.byteLength(s);
    }
    __name(estimatedBytesForString, "estimatedBytesForString");
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js
var require_defaultSendOperationsAsTrace = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultSendOperationsAsTrace = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache2());
    var iterateOverTrace_1 = require_iterateOverTrace();
    var durationHistogram_1 = require_durationHistogram();
    function defaultSendOperationsAsTrace() {
      const cache = new lru_cache_1.default({
        max: Math.pow(2, 20),
        length: /* @__PURE__ */ __name((_val, key) => {
          return key && Buffer.byteLength(key) || 0;
        }, "length")
      });
      return (trace3, statsReportKey) => {
        var _a;
        const endTimeSeconds = (_a = trace3.endTime) === null || _a === void 0 ? void 0 : _a.seconds;
        if (endTimeSeconds == null) {
          throw Error("programming error: endTime not set on trace");
        }
        const hasErrors = traceHasErrors(trace3);
        const cacheKey = JSON.stringify([
          statsReportKey,
          durationHistogram_1.DurationHistogram.durationToBucket(trace3.durationNs),
          Math.floor(endTimeSeconds / 60),
          hasErrors ? Math.floor(endTimeSeconds / 5) : ""
        ]);
        if (cache.get(cacheKey)) {
          return false;
        }
        cache.set(cacheKey, true);
        return true;
      };
    }
    __name(defaultSendOperationsAsTrace, "defaultSendOperationsAsTrace");
    exports2.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;
    function traceHasErrors(trace3) {
      let hasErrors = false;
      function traceNodeStats(node) {
        var _a, _b;
        if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {
          hasErrors = true;
        }
        return hasErrors;
      }
      __name(traceNodeStats, "traceNodeStats");
      (0, iterateOverTrace_1.iterateOverTrace)(trace3, traceNodeStats, false);
      return hasErrors;
    }
    __name(traceHasErrors, "traceHasErrors");
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js
var require_plugin = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginUsageReportingDisabled = exports2.makeHTTPRequestHeaders = exports2.ApolloServerPluginUsageReporting = void 0;
    var os_1 = __importDefault(require_os());
    var util_1 = require_util();
    var zlib_1 = require_zlib();
    var async_retry_1 = __importDefault(require_lib2());
    var apollo_reporting_protobuf_1 = require_generated();
    var apollo_server_env_1 = require_index_browser();
    var node_abort_controller_1 = require_browser();
    var apollo_server_types_1 = require_dist2();
    var operationDerivedDataCache_1 = require_operationDerivedDataCache();
    var utils_usagereporting_1 = require_dist9();
    var traceTreeBuilder_1 = require_traceTreeBuilder();
    var traceDetails_1 = require_traceDetails();
    var graphql_1 = require_graphql2();
    var schemaReporting_1 = require_schemaReporting();
    var stats_1 = require_stats();
    var defaultSendOperationsAsTrace_1 = require_defaultSendOperationsAsTrace();
    var utils_usagereporting_2 = require_dist9();
    var gzipPromise = (0, util_1.promisify)(zlib_1.gzip);
    var reportHeaderDefaults = {
      hostname: os_1.default.hostname(),
      agentVersion: `apollo-server-core@${require_package().version}`,
      runtimeVersion: `node ${process.version}`,
      uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`
    };
    function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
      const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
      const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === "number" ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;
      let requestDidStartHandler;
      return {
        __internal_plugin_id__() {
          return "UsageReporting";
        },
        async requestDidStart(requestContext) {
          if (!requestDidStartHandler) {
            throw Error("The usage reporting plugin has been asked to handle a request before the server has started. See https://github.com/apollographql/apollo-server/issues/4588 for more details.");
          }
          return requestDidStartHandler(requestContext);
        },
        async serverWillStart({ logger: serverLogger, apollo, serverlessFramework }) {
          var _a, _b, _c, _d;
          const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;
          const { key, graphRef } = apollo;
          if (!(key && graphRef)) {
            throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, but you also need to provide your Apollo API key and graph ref, via the APOLLO_KEY/APOLLO_GRAPH_REF environment variables or via `new ApolloServer({apollo: {key, graphRef})`.");
          }
          logger.info(`Apollo usage reporting starting! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
          const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;
          let operationDerivedDataCache = null;
          const reportByExecutableSchemaId = /* @__PURE__ */ new Map();
          const getReportWhichMustBeUsedImmediately = /* @__PURE__ */ __name((executableSchemaId) => {
            const existing = reportByExecutableSchemaId.get(executableSchemaId);
            if (existing) {
              return existing;
            }
            const report2 = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({
              ...reportHeaderDefaults,
              executableSchemaId,
              graphRef
            }));
            reportByExecutableSchemaId.set(executableSchemaId, report2);
            return report2;
          }, "getReportWhichMustBeUsedImmediately");
          const getAndDeleteReport = /* @__PURE__ */ __name((executableSchemaId) => {
            const report2 = reportByExecutableSchemaId.get(executableSchemaId);
            if (report2) {
              reportByExecutableSchemaId.delete(executableSchemaId);
              return report2;
            }
            return null;
          }, "getAndDeleteReport");
          const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : void 0;
          let lastSeenExecutableSchemaToId;
          let reportTimer;
          if (!sendReportsImmediately) {
            reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1e3);
          }
          let graphMightSupportTraces = true;
          const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();
          const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;
          let stopped = false;
          function executableSchemaIdForSchema(schema) {
            if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {
              return lastSeenExecutableSchemaToId.executableSchemaId;
            }
            const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));
            lastSeenExecutableSchemaToId = {
              executableSchema: schema,
              executableSchemaId: id
            };
            return id;
          }
          __name(executableSchemaIdForSchema, "executableSchemaIdForSchema");
          async function sendAllReportsAndReportErrors() {
            await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
          }
          __name(sendAllReportsAndReportErrors, "sendAllReportsAndReportErrors");
          async function sendReportAndReportErrors(executableSchemaId) {
            return sendReport(executableSchemaId).catch((err) => {
              if (options.reportErrorFunction) {
                options.reportErrorFunction(err);
              } else {
                logger.error(err.message);
              }
            });
          }
          __name(sendReportAndReportErrors, "sendReportAndReportErrors");
          const sendReport = /* @__PURE__ */ __name(async (executableSchemaId) => {
            var _a2, _b2;
            let report2 = getAndDeleteReport(executableSchemaId);
            if (!report2 || Object.keys(report2.tracesPerQuery).length === 0 && report2.operationCount === 0) {
              return;
            }
            report2.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(/* @__PURE__ */ new Date());
            report2.ensureCountsAreIntegers();
            const protobufError = apollo_reporting_protobuf_1.Report.verify(report2);
            if (protobufError) {
              throw new Error(`Error verifying report: ${protobufError}`);
            }
            let message = apollo_reporting_protobuf_1.Report.encode(report2).finish();
            report2 = null;
            if (options.debugPrintReports) {
              const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);
              logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
            }
            const compressed = await gzipPromise(message);
            message = null;
            const fetcher = (_a2 = options.fetcher) !== null && _a2 !== void 0 ? _a2 : apollo_server_env_1.fetch;
            const response = await (0, async_retry_1.default)(async () => {
              var _a3;
              const controller = new node_abort_controller_1.AbortController();
              const abortTimeout = setTimeout(() => {
                controller.abort();
              }, (_a3 = options.requestTimeoutMs) !== null && _a3 !== void 0 ? _a3 : 3e4);
              let curResponse;
              try {
                const requestInit = {
                  method: "POST",
                  headers: {
                    "user-agent": "ApolloServerPluginUsageReporting",
                    "x-api-key": key,
                    "content-encoding": "gzip",
                    accept: "application/json"
                  },
                  body: compressed,
                  agent: options.requestAgent
                };
                requestInit.signal = controller.signal;
                curResponse = await fetcher((options.endpointUrl || "https://usage-reporting.api.apollographql.com") + "/api/ingress/traces", requestInit);
              } finally {
                clearTimeout(abortTimeout);
              }
              if (curResponse.status >= 500 && curResponse.status < 600) {
                throw new Error(`HTTP status ${curResponse.status}, ${await curResponse.text() || "(no body)"}`);
              } else {
                return curResponse;
              }
            }, {
              retries: (options.maxAttempts || 5) - 1,
              minTimeout: options.minimumRetryDelayMs || 100,
              factor: 2
            }).catch((err) => {
              throw new Error(`Error sending report to Apollo servers: ${err.message}`);
            });
            if (response.status < 200 || response.status >= 300) {
              throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${await response.text() || "(no body)"}`);
            }
            if (graphMightSupportTraces && response.status === 200 && ((_b2 = response.headers.get("content-type")) === null || _b2 === void 0 ? void 0 : _b2.match(/^\s*application\/json\s*(?:;|$)/i))) {
              const body = await response.text();
              let parsedBody;
              try {
                parsedBody = JSON.parse(body);
              } catch (e) {
                throw new Error(`Error parsing response from Apollo servers: ${e}`);
              }
              if (parsedBody.tracesIgnored === true) {
                logger.debug("This graph's organization does not have access to traces; sending all subsequent operations as traces.");
                graphMightSupportTraces = false;
              }
            }
            if (options.debugPrintReports) {
              logger.warn(`Apollo usage report: status ${response.status}`);
            }
          }, "sendReport");
          requestDidStartHandler = /* @__PURE__ */ __name(({ logger: requestLogger, metrics, schema, request: { http, variables } }) => {
            var _a2;
            const logger2 = (_a2 = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a2 !== void 0 ? _a2 : serverLogger;
            const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
              rewriteError: options.rewriteError,
              logger: logger2
            });
            treeBuilder.startTiming();
            metrics.startHrTime = treeBuilder.startHrTime;
            let graphqlValidationFailure = false;
            let graphqlUnknownOperationName = false;
            let includeOperationInUsageReporting = null;
            if (http) {
              treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({
                method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN
              });
              if (options.sendHeaders) {
                makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
              }
            }
            async function maybeCallIncludeRequestHook(requestContext) {
              if (includeOperationInUsageReporting !== null)
                return;
              if (typeof options.includeRequest !== "function") {
                includeOperationInUsageReporting = true;
                return;
              }
              includeOperationInUsageReporting = await options.includeRequest(requestContext);
              if (typeof includeOperationInUsageReporting !== "boolean") {
                logger2.warn("The 'includeRequest' async predicate function must return a boolean value.");
                includeOperationInUsageReporting = true;
              }
            }
            __name(maybeCallIncludeRequestHook, "maybeCallIncludeRequestHook");
            let didResolveSource = false;
            return {
              async didResolveSource(requestContext) {
                didResolveSource = true;
                if (metrics.persistedQueryHit) {
                  treeBuilder.trace.persistedQueryHit = true;
                }
                if (metrics.persistedQueryRegister) {
                  treeBuilder.trace.persistedQueryRegister = true;
                }
                if (variables) {
                  treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);
                }
                const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
                if (clientInfo) {
                  const { clientName, clientVersion } = clientInfo;
                  treeBuilder.trace.clientVersion = clientVersion || "";
                  treeBuilder.trace.clientName = clientName || "";
                }
              },
              async validationDidStart() {
                return async (validationErrors) => {
                  graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;
                };
              },
              async didResolveOperation(requestContext) {
                graphqlUnknownOperationName = requestContext.operation === void 0;
                await maybeCallIncludeRequestHook(requestContext);
                if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {
                  if (metrics.captureTraces === void 0) {
                    const rawWeight = await fieldLevelInstrumentation(requestContext);
                    treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === "number" ? rawWeight : rawWeight ? 1 : 0;
                    metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;
                  }
                }
              },
              async executionDidStart() {
                if (!metrics.captureTraces)
                  return;
                return {
                  willResolveField({ info: info3 }) {
                    return treeBuilder.willResolveField(info3);
                  }
                };
              },
              async willSendResponse(requestContext) {
                if (!didResolveSource)
                  return;
                if (requestContext.errors) {
                  treeBuilder.didEncounterErrors(requestContext.errors);
                }
                const resolvedOperation = !!requestContext.operation;
                await maybeCallIncludeRequestHook(requestContext);
                treeBuilder.stopTiming();
                const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                if (includeOperationInUsageReporting === false) {
                  if (resolvedOperation)
                    getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
                  return;
                }
                treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
                treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
                treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
                const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
                if (policyIfCacheable) {
                  treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({
                    scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,
                    maxAgeNs: policyIfCacheable.maxAge * 1e9
                  });
                }
                if (metrics.queryPlanTrace) {
                  treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                }
                addTrace().catch(logger2.error);
                async function addTrace() {
                  if (stopped) {
                    return;
                  }
                  await new Promise((res) => setImmediate(res));
                  const executableSchemaId2 = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                  const { trace: trace3 } = treeBuilder;
                  let statsReportKey = void 0;
                  let referencedFieldsByType;
                  if (!requestContext.document) {
                    statsReportKey = `## GraphQLParseFailure
`;
                  } else if (graphqlValidationFailure) {
                    statsReportKey = `## GraphQLValidationFailure
`;
                  } else if (graphqlUnknownOperationName) {
                    statsReportKey = `## GraphQLUnknownOperationName
`;
                  }
                  const isExecutable = statsReportKey === void 0;
                  if (statsReportKey) {
                    if (options.sendUnexecutableOperationDocuments) {
                      trace3.unexecutedOperationBody = requestContext.source;
                      trace3.unexecutedOperationName = requestContext.request.operationName || "";
                    }
                    referencedFieldsByType = /* @__PURE__ */ Object.create(null);
                  } else {
                    const operationDerivedData = getOperationDerivedData();
                    statsReportKey = `# ${requestContext.operationName || "-"}
${operationDerivedData.signature}`;
                    referencedFieldsByType = operationDerivedData.referencedFieldsByType;
                  }
                  const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace3);
                  if (protobufError) {
                    throw new Error(`Error encoding trace: ${protobufError}`);
                  }
                  if (resolvedOperation) {
                    getReportWhichMustBeUsedImmediately(executableSchemaId2).operationCount++;
                  }
                  getReportWhichMustBeUsedImmediately(executableSchemaId2).addTrace({
                    statsReportKey,
                    trace: trace3,
                    asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace3, statsReportKey),
                    includeTracesContributingToStats,
                    referencedFieldsByType
                  });
                  if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId2).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                    await sendReportAndReportErrors(executableSchemaId2);
                  }
                }
                __name(addTrace, "addTrace");
                function getOperationDerivedData() {
                  var _a3;
                  if (!requestContext.document) {
                    throw new Error("No document?");
                  }
                  const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || "");
                  if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {
                    operationDerivedDataCache = {
                      forSchema: schema,
                      cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({ logger: logger2 })
                    };
                  }
                  const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                  if (cachedOperationDerivedData) {
                    return cachedOperationDerivedData;
                  }
                  const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || "");
                  const generatedOperationDerivedData = {
                    signature: generatedSignature,
                    referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({
                      document: requestContext.document,
                      schema,
                      resolvedOperationName: (_a3 = requestContext.operationName) !== null && _a3 !== void 0 ? _a3 : null
                    })
                  };
                  operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                  return generatedOperationDerivedData;
                }
                __name(getOperationDerivedData, "getOperationDerivedData");
              }
            };
          }, "requestDidStartHandler");
          return {
            async serverWillStop() {
              if (reportTimer) {
                clearInterval(reportTimer);
                reportTimer = void 0;
              }
              stopped = true;
              await sendAllReportsAndReportErrors();
            }
          };
        }
      };
    }
    __name(ApolloServerPluginUsageReporting, "ApolloServerPluginUsageReporting");
    exports2.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
    function makeHTTPRequestHeaders(http, headers, sendHeaders) {
      if (!sendHeaders || "none" in sendHeaders && sendHeaders.none || "all" in sendHeaders && !sendHeaders.all) {
        return;
      }
      for (const [key, value] of headers) {
        const lowerCaseKey = key.toLowerCase();
        if ("exceptNames" in sendHeaders && sendHeaders.exceptNames.some((exceptHeader) => {
          return exceptHeader.toLowerCase() === lowerCaseKey;
        }) || "onlyNames" in sendHeaders && !sendHeaders.onlyNames.some((header) => {
          return header.toLowerCase() === lowerCaseKey;
        })) {
          continue;
        }
        switch (key) {
          case "authorization":
          case "cookie":
          case "set-cookie":
            break;
          default:
            http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({
              value: [value]
            });
        }
      }
    }
    __name(makeHTTPRequestHeaders, "makeHTTPRequestHeaders");
    exports2.makeHTTPRequestHeaders = makeHTTPRequestHeaders;
    function defaultGenerateClientInfo({ request: request2 }) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const clientNameHeaderKey = "apollographql-client-name";
      const clientVersionHeaderKey = "apollographql-client-version";
      if (((_b = (_a = request2.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request2.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey))) {
        return {
          clientName: (_f = (_e = request2.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientNameHeaderKey),
          clientVersion: (_h = (_g = request2.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientVersionHeaderKey)
        };
      } else if ((_j = request2.extensions) === null || _j === void 0 ? void 0 : _j.clientInfo) {
        return request2.extensions.clientInfo;
      } else {
        return {};
      }
    }
    __name(defaultGenerateClientInfo, "defaultGenerateClientInfo");
    function ApolloServerPluginUsageReportingDisabled() {
      return {
        __internal_plugin_id__() {
          return "UsageReporting";
        }
      };
    }
    __name(ApolloServerPluginUsageReportingDisabled, "ApolloServerPluginUsageReportingDisabled");
    exports2.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/options.js
var require_options = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/options.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/index.js
var require_usageReporting = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginUsageReportingDisabled = exports2.ApolloServerPluginUsageReporting = void 0;
    var plugin_1 = require_plugin();
    Object.defineProperty(exports2, "ApolloServerPluginUsageReporting", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return plugin_1.ApolloServerPluginUsageReporting;
    }, "get") });
    Object.defineProperty(exports2, "ApolloServerPluginUsageReportingDisabled", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return plugin_1.ApolloServerPluginUsageReportingDisabled;
    }, "get") });
    var options_1 = require_options();
  }
});

// node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js
var require_inlineTrace = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginInlineTraceDisabled = exports2.ApolloServerPluginInlineTrace = void 0;
    var apollo_reporting_protobuf_1 = require_generated();
    var traceTreeBuilder_1 = require_traceTreeBuilder();
    var schemaIsFederated_1 = require_schemaIsFederated();
    function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
      let enabled = options.__onlyIfSchemaIsFederated ? null : true;
      return {
        __internal_plugin_id__() {
          return "InlineTrace";
        },
        async serverWillStart({ schema, logger }) {
          if (enabled === null) {
            enabled = (0, schemaIsFederated_1.schemaIsFederated)(schema);
            if (enabled) {
              logger.info("Enabling inline tracing for this federated service. To disable, use ApolloServerPluginInlineTraceDisabled.");
            }
          }
        },
        async requestDidStart({ request: { http }, metrics }) {
          if (!enabled) {
            return;
          }
          const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
            rewriteError: options.rewriteError
          });
          if ((http === null || http === void 0 ? void 0 : http.headers.get("apollo-federation-include-trace")) !== "ftv1") {
            return;
          }
          if (metrics.captureTraces === false) {
            return;
          }
          metrics.captureTraces = true;
          treeBuilder.startTiming();
          return {
            async executionDidStart() {
              return {
                willResolveField({ info: info3 }) {
                  return treeBuilder.willResolveField(info3);
                }
              };
            },
            async didEncounterErrors({ errors }) {
              treeBuilder.didEncounterErrors(errors);
            },
            async willSendResponse({ response }) {
              treeBuilder.stopTiming();
              if (metrics.queryPlanTrace) {
                treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
              }
              const encodedUint8Array = apollo_reporting_protobuf_1.Trace.encode(treeBuilder.trace).finish();
              const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
              const extensions = response.extensions || (response.extensions = /* @__PURE__ */ Object.create(null));
              if (typeof extensions.ftv1 !== "undefined") {
                throw new Error("The `ftv1` extension was already present.");
              }
              extensions.ftv1 = encodedBuffer.toString("base64");
            }
          };
        }
      };
    }
    __name(ApolloServerPluginInlineTrace, "ApolloServerPluginInlineTrace");
    exports2.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
    function ApolloServerPluginInlineTraceDisabled() {
      return {
        __internal_plugin_id__() {
          return "InlineTrace";
        }
      };
    }
    __name(ApolloServerPluginInlineTraceDisabled, "ApolloServerPluginInlineTraceDisabled");
    exports2.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
  }
});

// node_modules/apollo-server-core/dist/plugin/cacheControl/index.js
var require_cacheControl = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/cacheControl/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginCacheControlDisabled = exports2.ApolloServerPluginCacheControl = void 0;
    var graphql_1 = require_graphql2();
    var cachePolicy_1 = require_cachePolicy();
    var lru_cache_1 = __importDefault(require_lru_cache2());
    function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
      const typeAnnotationCache = new lru_cache_1.default();
      const fieldAnnotationCache = new lru_cache_1.default();
      function memoizedCacheAnnotationFromType(t) {
        const existing = typeAnnotationCache.get(t);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromType(t);
        typeAnnotationCache.set(t, annotation);
        return annotation;
      }
      __name(memoizedCacheAnnotationFromType, "memoizedCacheAnnotationFromType");
      function memoizedCacheAnnotationFromField(field) {
        const existing = fieldAnnotationCache.get(field);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromField(field);
        fieldAnnotationCache.set(field, annotation);
        return annotation;
      }
      __name(memoizedCacheAnnotationFromField, "memoizedCacheAnnotationFromField");
      return {
        __internal_plugin_id__() {
          return "CacheControl";
        },
        async serverWillStart({ schema }) {
          typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;
          fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap((t) => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap((t) => Object.values(t.getFields())).length;
          return void 0;
        },
        async requestDidStart(requestContext) {
          var _a, _b;
          const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== void 0 ? _a : 0;
          const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== void 0 ? _b : true;
          const { __testing__cacheHints } = options;
          return {
            async executionDidStart() {
              if (isRestricted(requestContext.overallCachePolicy)) {
                const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                return {
                  willResolveField({ info: info3 }) {
                    info3.cacheControl = {
                      setCacheHint: /* @__PURE__ */ __name((dynamicHint) => {
                        fakeFieldPolicy.replace(dynamicHint);
                      }, "setCacheHint"),
                      cacheHint: fakeFieldPolicy,
                      cacheHintFromType: memoizedCacheAnnotationFromType
                    };
                  }
                };
              }
              return {
                willResolveField({ info: info3 }) {
                  const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                  let inheritMaxAge = false;
                  const targetType = (0, graphql_1.getNamedType)(info3.returnType);
                  if ((0, graphql_1.isCompositeType)(targetType)) {
                    const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                    fieldPolicy.replace(typeAnnotation);
                    inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                  }
                  const fieldAnnotation = memoizedCacheAnnotationFromField(info3.parentType.getFields()[info3.fieldName]);
                  if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === void 0) {
                    inheritMaxAge = true;
                    if (fieldAnnotation.scope) {
                      fieldPolicy.replace({ scope: fieldAnnotation.scope });
                    }
                  } else {
                    fieldPolicy.replace(fieldAnnotation);
                  }
                  info3.cacheControl = {
                    setCacheHint: /* @__PURE__ */ __name((dynamicHint) => {
                      fieldPolicy.replace(dynamicHint);
                    }, "setCacheHint"),
                    cacheHint: fieldPolicy,
                    cacheHintFromType: memoizedCacheAnnotationFromType
                  };
                  return () => {
                    if (fieldPolicy.maxAge === void 0 && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info3.path.prev)) {
                      fieldPolicy.restrict({ maxAge: defaultMaxAge });
                    }
                    if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                      const path = (0, graphql_1.responsePathAsArray)(info3.path).join(".");
                      if (__testing__cacheHints.has(path)) {
                        throw Error("shouldn't happen: addHint should only be called once per path");
                      }
                      __testing__cacheHints.set(path, {
                        maxAge: fieldPolicy.maxAge,
                        scope: fieldPolicy.scope
                      });
                    }
                    requestContext.overallCachePolicy.restrict(fieldPolicy);
                  };
                }
              };
            },
            async willSendResponse(requestContext2) {
              const { response, overallCachePolicy, requestIsBatched } = requestContext2;
              const policyIfCacheable = overallCachePolicy.policyIfCacheable();
              if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {
                response.http.headers.set("Cache-Control", `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
              }
            }
          };
        }
      };
    }
    __name(ApolloServerPluginCacheControl, "ApolloServerPluginCacheControl");
    exports2.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
    function cacheAnnotationFromDirectives(directives) {
      var _a, _b, _c;
      if (!directives)
        return void 0;
      const cacheControlDirective = directives.find((directive) => directive.name.value === "cacheControl");
      if (!cacheControlDirective)
        return void 0;
      if (!cacheControlDirective.arguments)
        return void 0;
      const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "maxAge");
      const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "scope");
      const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "inheritMaxAge");
      const scope = ((_a = scopeArgument === null || scopeArgument === void 0 ? void 0 : scopeArgument.value) === null || _a === void 0 ? void 0 : _a.kind) === "EnumValue" ? scopeArgument.value.value : void 0;
      if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === void 0 ? void 0 : inheritMaxAgeArgument.value) === null || _b === void 0 ? void 0 : _b.kind) === "BooleanValue" && inheritMaxAgeArgument.value.value) {
        return { inheritMaxAge: true, scope };
      }
      return {
        maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === void 0 ? void 0 : maxAgeArgument.value) === null || _c === void 0 ? void 0 : _c.kind) === "IntValue" ? parseInt(maxAgeArgument.value.value) : void 0,
        scope
      };
    }
    __name(cacheAnnotationFromDirectives, "cacheAnnotationFromDirectives");
    function cacheAnnotationFromType(t) {
      if (t.astNode) {
        const hint = cacheAnnotationFromDirectives(t.astNode.directives);
        if (hint) {
          return hint;
        }
      }
      if (t.extensionASTNodes) {
        for (const node of t.extensionASTNodes) {
          const hint = cacheAnnotationFromDirectives(node.directives);
          if (hint) {
            return hint;
          }
        }
      }
      return {};
    }
    __name(cacheAnnotationFromType, "cacheAnnotationFromType");
    function cacheAnnotationFromField(field) {
      if (field.astNode) {
        const hint = cacheAnnotationFromDirectives(field.astNode.directives);
        if (hint) {
          return hint;
        }
      }
      return {};
    }
    __name(cacheAnnotationFromField, "cacheAnnotationFromField");
    function isRestricted(hint) {
      return hint.maxAge !== void 0 || hint.scope !== void 0;
    }
    __name(isRestricted, "isRestricted");
    function ApolloServerPluginCacheControlDisabled() {
      return {
        __internal_plugin_id__() {
          return "CacheControl";
        }
      };
    }
    __name(ApolloServerPluginCacheControlDisabled, "ApolloServerPluginCacheControlDisabled");
    exports2.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
  }
});

// node_modules/unenv/dist/runtime/node/internal/http/agent.mjs
import { EventEmitter as EventEmitter2 } from "node:events";
var Agent;
var init_agent = __esm({
  "node_modules/unenv/dist/runtime/node/internal/http/agent.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Agent = class extends EventEmitter2 {
      static {
        __name(this, "Agent");
      }
      __unenv__ = {};
      maxFreeSockets = 256;
      maxSockets = Infinity;
      maxTotalSockets = Infinity;
      freeSockets = {};
      sockets = {};
      requests = {};
      destroy() {
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/https.mjs
var Server, Agent2, globalAgent, get, createServer, request, https_default;
var init_https = __esm({
  "node_modules/unenv/dist/runtime/node/https.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_agent();
    Server = /* @__PURE__ */ notImplementedClass("https.Server");
    Agent2 = Agent;
    globalAgent = /* @__PURE__ */ new Agent2();
    get = /* @__PURE__ */ notImplemented("https.get");
    createServer = /* @__PURE__ */ notImplemented("https.createServer");
    request = /* @__PURE__ */ notImplemented("https.request");
    https_default = {
      Server,
      Agent: Agent2,
      globalAgent,
      get,
      createServer,
      request
    };
  }
});

// node-built-in-modules:https
var require_https = __commonJS({
  "node-built-in-modules:https"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_https();
    module2.exports = https_default;
  }
});

// node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js
var require_stoppable = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Stopper = void 0;
    var https_1 = __importDefault(require_https());
    var Stopper = class {
      static {
        __name(this, "Stopper");
      }
      constructor(server) {
        this.server = server;
        this.requestCountPerSocket = /* @__PURE__ */ new Map();
        this.stopped = false;
        server.on(server instanceof https_1.default.Server ? "secureConnection" : "connection", (socket) => {
          this.requestCountPerSocket.set(socket, 0);
          socket.once("close", () => this.requestCountPerSocket.delete(socket));
        });
        server.on("request", (req, res) => {
          var _a;
          this.requestCountPerSocket.set(req.socket, ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) + 1);
          res.once("finish", () => {
            var _a2;
            const pending = ((_a2 = this.requestCountPerSocket.get(req.socket)) !== null && _a2 !== void 0 ? _a2 : 0) - 1;
            this.requestCountPerSocket.set(req.socket, pending);
            if (this.stopped && pending === 0) {
              req.socket.end();
            }
          });
        });
      }
      async stop(stopGracePeriodMillis = Infinity) {
        let gracefully = true;
        await new Promise((resolve) => setImmediate(resolve));
        this.stopped = true;
        let timeout = null;
        if (stopGracePeriodMillis < Infinity) {
          timeout = setTimeout(() => {
            gracefully = false;
            this.requestCountPerSocket.forEach((_, socket) => socket.end());
            setImmediate(() => {
              this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
            });
          }, stopGracePeriodMillis);
        }
        const closePromise = new Promise((resolve) => this.server.close(() => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          resolve();
        }));
        this.requestCountPerSocket.forEach((requests, socket) => {
          if (requests === 0)
            socket.end();
        });
        await closePromise;
        return gracefully;
      }
    };
    exports2.Stopper = Stopper;
  }
});

// node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js
var require_drainHttpServer = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginDrainHttpServer = void 0;
    var stoppable_1 = require_stoppable();
    function ApolloServerPluginDrainHttpServer(options) {
      const stopper = new stoppable_1.Stopper(options.httpServer);
      return {
        async serverWillStart() {
          return {
            async drainServer() {
              var _a;
              await stopper.stop((_a = options.stopGracePeriodMillis) !== null && _a !== void 0 ? _a : 1e4);
            }
          };
        }
      };
    }
    __name(ApolloServerPluginDrainHttpServer, "ApolloServerPluginDrainHttpServer");
    exports2.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
  }
});

// node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js
var require_default = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEmbeddedSandboxHTML = exports2.getEmbeddedExplorerHTML = exports2.ApolloServerPluginLandingPageProductionDefault = exports2.ApolloServerPluginLandingPageLocalDefault = void 0;
    function ApolloServerPluginLandingPageLocalDefault(options = {}) {
      const { version: version3, __internal_apolloStudioEnv__, ...rest } = options;
      return ApolloServerPluginLandingPageDefault(version3, {
        isProd: false,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
      });
    }
    __name(ApolloServerPluginLandingPageLocalDefault, "ApolloServerPluginLandingPageLocalDefault");
    exports2.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
    function ApolloServerPluginLandingPageProductionDefault(options = {}) {
      const { version: version3, __internal_apolloStudioEnv__, ...rest } = options;
      return ApolloServerPluginLandingPageDefault(version3, {
        isProd: true,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
      });
    }
    __name(ApolloServerPluginLandingPageProductionDefault, "ApolloServerPluginLandingPageProductionDefault");
    exports2.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
    function encodeConfig(config2) {
      return JSON.stringify(encodeURIComponent(JSON.stringify(config2)));
    }
    __name(encodeConfig, "encodeConfig");
    function getConfigStringForHtml(config2) {
      return JSON.stringify(config2).replace("<", "\\u003c").replace(">", "\\u003e").replace("&", "\\u0026").replace("'", "\\u0027");
    }
    __name(getConfigStringForHtml, "getConfigStringForHtml");
    var getEmbeddedExplorerHTML = /* @__PURE__ */ __name((version3, config2) => {
      const productionLandingPageConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        ...typeof config2.embed === "boolean" ? {} : config2.embed
      };
      const embeddedExplorerParams = {
        ...config2,
        target: "#embeddableExplorer",
        initialState: {
          ...config2,
          displayOptions: {
            ...productionLandingPageConfigOrDefault.displayOptions
          }
        },
        persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState
      };
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version3}/embeddable-explorer.umd.production.min.js"><\/script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
<\/script>
`;
    }, "getEmbeddedExplorerHTML");
    exports2.getEmbeddedExplorerHTML = getEmbeddedExplorerHTML;
    var getEmbeddedSandboxHTML = /* @__PURE__ */ __name((version3, config2) => {
      var _a, _b, _c, _d;
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version3}/embeddable-sandbox.umd.production.min.js"><\/script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${(_a = config2.includeCookies) !== null && _a !== void 0 ? _a : "false"},
    initialState: ${getConfigStringForHtml({
        document: (_b = config2.document) !== null && _b !== void 0 ? _b : void 0,
        variables: (_c = config2.variables) !== null && _c !== void 0 ? _c : void 0,
        headers: (_d = config2.headers) !== null && _d !== void 0 ? _d : void 0
      })},
  });
<\/script>
`;
    }, "getEmbeddedSandboxHTML");
    exports2.getEmbeddedSandboxHTML = getEmbeddedSandboxHTML;
    var getNonEmbeddedLandingPageHTML = /* @__PURE__ */ __name((version3, config2) => {
      const encodedConfig = encodeConfig(config2);
      return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};<\/script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version3}/static/js/main.js"><\/script>`;
    }, "getNonEmbeddedLandingPageHTML");
    function ApolloServerPluginLandingPageDefault(maybeVersion, config2) {
      const version3 = maybeVersion !== null && maybeVersion !== void 0 ? maybeVersion : "_latest";
      return {
        __internal_installed_implicitly__: false,
        async serverWillStart() {
          return {
            async renderLandingPage() {
              const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version3}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version3}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version3}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config2.embed ? "graphRef" in config2 && config2.graphRef ? (0, exports2.getEmbeddedExplorerHTML)(version3, config2) : (0, exports2.getEmbeddedSandboxHTML)(version3, config2) : getNonEmbeddedLandingPageHTML(version3, config2)}
    </div>
  </body>
</html>
          `;
              return { html };
            }
          };
        }
      };
    }
    __name(ApolloServerPluginLandingPageDefault, "ApolloServerPluginLandingPageDefault");
  }
});

// node_modules/cssfilter/lib/default.js
var require_default2 = __commonJS({
  "node_modules/cssfilter/lib/default.js"(exports2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function getDefaultWhiteList() {
      var whiteList = {};
      whiteList["align-content"] = false;
      whiteList["align-items"] = false;
      whiteList["align-self"] = false;
      whiteList["alignment-adjust"] = false;
      whiteList["alignment-baseline"] = false;
      whiteList["all"] = false;
      whiteList["anchor-point"] = false;
      whiteList["animation"] = false;
      whiteList["animation-delay"] = false;
      whiteList["animation-direction"] = false;
      whiteList["animation-duration"] = false;
      whiteList["animation-fill-mode"] = false;
      whiteList["animation-iteration-count"] = false;
      whiteList["animation-name"] = false;
      whiteList["animation-play-state"] = false;
      whiteList["animation-timing-function"] = false;
      whiteList["azimuth"] = false;
      whiteList["backface-visibility"] = false;
      whiteList["background"] = true;
      whiteList["background-attachment"] = true;
      whiteList["background-clip"] = true;
      whiteList["background-color"] = true;
      whiteList["background-image"] = true;
      whiteList["background-origin"] = true;
      whiteList["background-position"] = true;
      whiteList["background-repeat"] = true;
      whiteList["background-size"] = true;
      whiteList["baseline-shift"] = false;
      whiteList["binding"] = false;
      whiteList["bleed"] = false;
      whiteList["bookmark-label"] = false;
      whiteList["bookmark-level"] = false;
      whiteList["bookmark-state"] = false;
      whiteList["border"] = true;
      whiteList["border-bottom"] = true;
      whiteList["border-bottom-color"] = true;
      whiteList["border-bottom-left-radius"] = true;
      whiteList["border-bottom-right-radius"] = true;
      whiteList["border-bottom-style"] = true;
      whiteList["border-bottom-width"] = true;
      whiteList["border-collapse"] = true;
      whiteList["border-color"] = true;
      whiteList["border-image"] = true;
      whiteList["border-image-outset"] = true;
      whiteList["border-image-repeat"] = true;
      whiteList["border-image-slice"] = true;
      whiteList["border-image-source"] = true;
      whiteList["border-image-width"] = true;
      whiteList["border-left"] = true;
      whiteList["border-left-color"] = true;
      whiteList["border-left-style"] = true;
      whiteList["border-left-width"] = true;
      whiteList["border-radius"] = true;
      whiteList["border-right"] = true;
      whiteList["border-right-color"] = true;
      whiteList["border-right-style"] = true;
      whiteList["border-right-width"] = true;
      whiteList["border-spacing"] = true;
      whiteList["border-style"] = true;
      whiteList["border-top"] = true;
      whiteList["border-top-color"] = true;
      whiteList["border-top-left-radius"] = true;
      whiteList["border-top-right-radius"] = true;
      whiteList["border-top-style"] = true;
      whiteList["border-top-width"] = true;
      whiteList["border-width"] = true;
      whiteList["bottom"] = false;
      whiteList["box-decoration-break"] = true;
      whiteList["box-shadow"] = true;
      whiteList["box-sizing"] = true;
      whiteList["box-snap"] = true;
      whiteList["box-suppress"] = true;
      whiteList["break-after"] = true;
      whiteList["break-before"] = true;
      whiteList["break-inside"] = true;
      whiteList["caption-side"] = false;
      whiteList["chains"] = false;
      whiteList["clear"] = true;
      whiteList["clip"] = false;
      whiteList["clip-path"] = false;
      whiteList["clip-rule"] = false;
      whiteList["color"] = true;
      whiteList["color-interpolation-filters"] = true;
      whiteList["column-count"] = false;
      whiteList["column-fill"] = false;
      whiteList["column-gap"] = false;
      whiteList["column-rule"] = false;
      whiteList["column-rule-color"] = false;
      whiteList["column-rule-style"] = false;
      whiteList["column-rule-width"] = false;
      whiteList["column-span"] = false;
      whiteList["column-width"] = false;
      whiteList["columns"] = false;
      whiteList["contain"] = false;
      whiteList["content"] = false;
      whiteList["counter-increment"] = false;
      whiteList["counter-reset"] = false;
      whiteList["counter-set"] = false;
      whiteList["crop"] = false;
      whiteList["cue"] = false;
      whiteList["cue-after"] = false;
      whiteList["cue-before"] = false;
      whiteList["cursor"] = false;
      whiteList["direction"] = false;
      whiteList["display"] = true;
      whiteList["display-inside"] = true;
      whiteList["display-list"] = true;
      whiteList["display-outside"] = true;
      whiteList["dominant-baseline"] = false;
      whiteList["elevation"] = false;
      whiteList["empty-cells"] = false;
      whiteList["filter"] = false;
      whiteList["flex"] = false;
      whiteList["flex-basis"] = false;
      whiteList["flex-direction"] = false;
      whiteList["flex-flow"] = false;
      whiteList["flex-grow"] = false;
      whiteList["flex-shrink"] = false;
      whiteList["flex-wrap"] = false;
      whiteList["float"] = false;
      whiteList["float-offset"] = false;
      whiteList["flood-color"] = false;
      whiteList["flood-opacity"] = false;
      whiteList["flow-from"] = false;
      whiteList["flow-into"] = false;
      whiteList["font"] = true;
      whiteList["font-family"] = true;
      whiteList["font-feature-settings"] = true;
      whiteList["font-kerning"] = true;
      whiteList["font-language-override"] = true;
      whiteList["font-size"] = true;
      whiteList["font-size-adjust"] = true;
      whiteList["font-stretch"] = true;
      whiteList["font-style"] = true;
      whiteList["font-synthesis"] = true;
      whiteList["font-variant"] = true;
      whiteList["font-variant-alternates"] = true;
      whiteList["font-variant-caps"] = true;
      whiteList["font-variant-east-asian"] = true;
      whiteList["font-variant-ligatures"] = true;
      whiteList["font-variant-numeric"] = true;
      whiteList["font-variant-position"] = true;
      whiteList["font-weight"] = true;
      whiteList["grid"] = false;
      whiteList["grid-area"] = false;
      whiteList["grid-auto-columns"] = false;
      whiteList["grid-auto-flow"] = false;
      whiteList["grid-auto-rows"] = false;
      whiteList["grid-column"] = false;
      whiteList["grid-column-end"] = false;
      whiteList["grid-column-start"] = false;
      whiteList["grid-row"] = false;
      whiteList["grid-row-end"] = false;
      whiteList["grid-row-start"] = false;
      whiteList["grid-template"] = false;
      whiteList["grid-template-areas"] = false;
      whiteList["grid-template-columns"] = false;
      whiteList["grid-template-rows"] = false;
      whiteList["hanging-punctuation"] = false;
      whiteList["height"] = true;
      whiteList["hyphens"] = false;
      whiteList["icon"] = false;
      whiteList["image-orientation"] = false;
      whiteList["image-resolution"] = false;
      whiteList["ime-mode"] = false;
      whiteList["initial-letters"] = false;
      whiteList["inline-box-align"] = false;
      whiteList["justify-content"] = false;
      whiteList["justify-items"] = false;
      whiteList["justify-self"] = false;
      whiteList["left"] = false;
      whiteList["letter-spacing"] = true;
      whiteList["lighting-color"] = true;
      whiteList["line-box-contain"] = false;
      whiteList["line-break"] = false;
      whiteList["line-grid"] = false;
      whiteList["line-height"] = false;
      whiteList["line-snap"] = false;
      whiteList["line-stacking"] = false;
      whiteList["line-stacking-ruby"] = false;
      whiteList["line-stacking-shift"] = false;
      whiteList["line-stacking-strategy"] = false;
      whiteList["list-style"] = true;
      whiteList["list-style-image"] = true;
      whiteList["list-style-position"] = true;
      whiteList["list-style-type"] = true;
      whiteList["margin"] = true;
      whiteList["margin-bottom"] = true;
      whiteList["margin-left"] = true;
      whiteList["margin-right"] = true;
      whiteList["margin-top"] = true;
      whiteList["marker-offset"] = false;
      whiteList["marker-side"] = false;
      whiteList["marks"] = false;
      whiteList["mask"] = false;
      whiteList["mask-box"] = false;
      whiteList["mask-box-outset"] = false;
      whiteList["mask-box-repeat"] = false;
      whiteList["mask-box-slice"] = false;
      whiteList["mask-box-source"] = false;
      whiteList["mask-box-width"] = false;
      whiteList["mask-clip"] = false;
      whiteList["mask-image"] = false;
      whiteList["mask-origin"] = false;
      whiteList["mask-position"] = false;
      whiteList["mask-repeat"] = false;
      whiteList["mask-size"] = false;
      whiteList["mask-source-type"] = false;
      whiteList["mask-type"] = false;
      whiteList["max-height"] = true;
      whiteList["max-lines"] = false;
      whiteList["max-width"] = true;
      whiteList["min-height"] = true;
      whiteList["min-width"] = true;
      whiteList["move-to"] = false;
      whiteList["nav-down"] = false;
      whiteList["nav-index"] = false;
      whiteList["nav-left"] = false;
      whiteList["nav-right"] = false;
      whiteList["nav-up"] = false;
      whiteList["object-fit"] = false;
      whiteList["object-position"] = false;
      whiteList["opacity"] = false;
      whiteList["order"] = false;
      whiteList["orphans"] = false;
      whiteList["outline"] = false;
      whiteList["outline-color"] = false;
      whiteList["outline-offset"] = false;
      whiteList["outline-style"] = false;
      whiteList["outline-width"] = false;
      whiteList["overflow"] = false;
      whiteList["overflow-wrap"] = false;
      whiteList["overflow-x"] = false;
      whiteList["overflow-y"] = false;
      whiteList["padding"] = true;
      whiteList["padding-bottom"] = true;
      whiteList["padding-left"] = true;
      whiteList["padding-right"] = true;
      whiteList["padding-top"] = true;
      whiteList["page"] = false;
      whiteList["page-break-after"] = false;
      whiteList["page-break-before"] = false;
      whiteList["page-break-inside"] = false;
      whiteList["page-policy"] = false;
      whiteList["pause"] = false;
      whiteList["pause-after"] = false;
      whiteList["pause-before"] = false;
      whiteList["perspective"] = false;
      whiteList["perspective-origin"] = false;
      whiteList["pitch"] = false;
      whiteList["pitch-range"] = false;
      whiteList["play-during"] = false;
      whiteList["position"] = false;
      whiteList["presentation-level"] = false;
      whiteList["quotes"] = false;
      whiteList["region-fragment"] = false;
      whiteList["resize"] = false;
      whiteList["rest"] = false;
      whiteList["rest-after"] = false;
      whiteList["rest-before"] = false;
      whiteList["richness"] = false;
      whiteList["right"] = false;
      whiteList["rotation"] = false;
      whiteList["rotation-point"] = false;
      whiteList["ruby-align"] = false;
      whiteList["ruby-merge"] = false;
      whiteList["ruby-position"] = false;
      whiteList["shape-image-threshold"] = false;
      whiteList["shape-outside"] = false;
      whiteList["shape-margin"] = false;
      whiteList["size"] = false;
      whiteList["speak"] = false;
      whiteList["speak-as"] = false;
      whiteList["speak-header"] = false;
      whiteList["speak-numeral"] = false;
      whiteList["speak-punctuation"] = false;
      whiteList["speech-rate"] = false;
      whiteList["stress"] = false;
      whiteList["string-set"] = false;
      whiteList["tab-size"] = false;
      whiteList["table-layout"] = false;
      whiteList["text-align"] = true;
      whiteList["text-align-last"] = true;
      whiteList["text-combine-upright"] = true;
      whiteList["text-decoration"] = true;
      whiteList["text-decoration-color"] = true;
      whiteList["text-decoration-line"] = true;
      whiteList["text-decoration-skip"] = true;
      whiteList["text-decoration-style"] = true;
      whiteList["text-emphasis"] = true;
      whiteList["text-emphasis-color"] = true;
      whiteList["text-emphasis-position"] = true;
      whiteList["text-emphasis-style"] = true;
      whiteList["text-height"] = true;
      whiteList["text-indent"] = true;
      whiteList["text-justify"] = true;
      whiteList["text-orientation"] = true;
      whiteList["text-overflow"] = true;
      whiteList["text-shadow"] = true;
      whiteList["text-space-collapse"] = true;
      whiteList["text-transform"] = true;
      whiteList["text-underline-position"] = true;
      whiteList["text-wrap"] = true;
      whiteList["top"] = false;
      whiteList["transform"] = false;
      whiteList["transform-origin"] = false;
      whiteList["transform-style"] = false;
      whiteList["transition"] = false;
      whiteList["transition-delay"] = false;
      whiteList["transition-duration"] = false;
      whiteList["transition-property"] = false;
      whiteList["transition-timing-function"] = false;
      whiteList["unicode-bidi"] = false;
      whiteList["vertical-align"] = false;
      whiteList["visibility"] = false;
      whiteList["voice-balance"] = false;
      whiteList["voice-duration"] = false;
      whiteList["voice-family"] = false;
      whiteList["voice-pitch"] = false;
      whiteList["voice-range"] = false;
      whiteList["voice-rate"] = false;
      whiteList["voice-stress"] = false;
      whiteList["voice-volume"] = false;
      whiteList["volume"] = false;
      whiteList["white-space"] = false;
      whiteList["widows"] = false;
      whiteList["width"] = true;
      whiteList["will-change"] = false;
      whiteList["word-break"] = true;
      whiteList["word-spacing"] = true;
      whiteList["word-wrap"] = true;
      whiteList["wrap-flow"] = false;
      whiteList["wrap-through"] = false;
      whiteList["writing-mode"] = false;
      whiteList["z-index"] = false;
      return whiteList;
    }
    __name(getDefaultWhiteList, "getDefaultWhiteList");
    function onAttr(name, value, options) {
    }
    __name(onAttr, "onAttr");
    function onIgnoreAttr(name, value, options) {
    }
    __name(onIgnoreAttr, "onIgnoreAttr");
    var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
    function safeAttrValue(name, value) {
      if (REGEXP_URL_JAVASCRIPT.test(value)) return "";
      return value;
    }
    __name(safeAttrValue, "safeAttrValue");
    exports2.whiteList = getDefaultWhiteList();
    exports2.getDefaultWhiteList = getDefaultWhiteList;
    exports2.onAttr = onAttr;
    exports2.onIgnoreAttr = onIgnoreAttr;
    exports2.safeAttrValue = safeAttrValue;
  }
});

// node_modules/cssfilter/lib/util.js
var require_util2 = __commonJS({
  "node_modules/cssfilter/lib/util.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {
      indexOf: /* @__PURE__ */ __name(function(arr, item) {
        var i, j;
        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }
        return -1;
      }, "indexOf"),
      forEach: /* @__PURE__ */ __name(function(arr, fn, scope) {
        var i, j;
        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      }, "forEach"),
      trim: /* @__PURE__ */ __name(function(str) {
        if (String.prototype.trim) {
          return str.trim();
        }
        return str.replace(/(^\s*)|(\s*$)/g, "");
      }, "trim"),
      trimRight: /* @__PURE__ */ __name(function(str) {
        if (String.prototype.trimRight) {
          return str.trimRight();
        }
        return str.replace(/(\s*$)/g, "");
      }, "trimRight")
    };
  }
});

// node_modules/cssfilter/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/cssfilter/lib/parser.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _ = require_util2();
    function parseStyle(css, onAttr) {
      css = _.trimRight(css);
      if (css[css.length - 1] !== ";") css += ";";
      var cssLength = css.length;
      var isParenthesisOpen = false;
      var lastPos = 0;
      var i = 0;
      var retCSS = "";
      function addNewAttr() {
        if (!isParenthesisOpen) {
          var source = _.trim(css.slice(lastPos, i));
          var j2 = source.indexOf(":");
          if (j2 !== -1) {
            var name = _.trim(source.slice(0, j2));
            var value = _.trim(source.slice(j2 + 1));
            if (name) {
              var ret = onAttr(lastPos, retCSS.length, name, value, source);
              if (ret) retCSS += ret + "; ";
            }
          }
        }
        lastPos = i + 1;
      }
      __name(addNewAttr, "addNewAttr");
      for (; i < cssLength; i++) {
        var c = css[i];
        if (c === "/" && css[i + 1] === "*") {
          var j = css.indexOf("*/", i + 2);
          if (j === -1) break;
          i = j + 1;
          lastPos = i + 1;
          isParenthesisOpen = false;
        } else if (c === "(") {
          isParenthesisOpen = true;
        } else if (c === ")") {
          isParenthesisOpen = false;
        } else if (c === ";") {
          if (isParenthesisOpen) {
          } else {
            addNewAttr();
          }
        } else if (c === "\n") {
          addNewAttr();
        }
      }
      return _.trim(retCSS);
    }
    __name(parseStyle, "parseStyle");
    module2.exports = parseStyle;
  }
});

// node_modules/cssfilter/lib/css.js
var require_css = __commonJS({
  "node_modules/cssfilter/lib/css.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DEFAULT = require_default2();
    var parseStyle = require_parser3();
    var _ = require_util2();
    function isNull2(obj) {
      return obj === void 0 || obj === null;
    }
    __name(isNull2, "isNull");
    function shallowCopyObject(obj) {
      var ret = {};
      for (var i in obj) {
        ret[i] = obj[i];
      }
      return ret;
    }
    __name(shallowCopyObject, "shallowCopyObject");
    function FilterCSS(options) {
      options = shallowCopyObject(options || {});
      options.whiteList = options.whiteList || DEFAULT.whiteList;
      options.onAttr = options.onAttr || DEFAULT.onAttr;
      options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      this.options = options;
    }
    __name(FilterCSS, "FilterCSS");
    FilterCSS.prototype.process = function(css) {
      css = css || "";
      css = css.toString();
      if (!css) return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onAttr = options.onAttr;
      var onIgnoreAttr = options.onIgnoreAttr;
      var safeAttrValue = options.safeAttrValue;
      var retCSS = parseStyle(css, function(sourcePosition, position, name, value, source) {
        var check = whiteList[name];
        var isWhite = false;
        if (check === true) isWhite = check;
        else if (typeof check === "function") isWhite = check(value);
        else if (check instanceof RegExp) isWhite = check.test(value);
        if (isWhite !== true) isWhite = false;
        value = safeAttrValue(name, value);
        if (!value) return;
        var opts = {
          position,
          sourcePosition,
          source,
          isWhite
        };
        if (isWhite) {
          var ret = onAttr(name, value, opts);
          if (isNull2(ret)) {
            return name + ":" + value;
          } else {
            return ret;
          }
        } else {
          var ret = onIgnoreAttr(name, value, opts);
          if (!isNull2(ret)) {
            return ret;
          }
        }
      });
      return retCSS;
    };
    module2.exports = FilterCSS;
  }
});

// node_modules/cssfilter/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/cssfilter/lib/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DEFAULT = require_default2();
    var FilterCSS = require_css();
    function filterCSS(html, options) {
      var xss = new FilterCSS(options);
      return xss.process(html);
    }
    __name(filterCSS, "filterCSS");
    exports2 = module2.exports = filterCSS;
    exports2.FilterCSS = FilterCSS;
    for (i in DEFAULT) exports2[i] = DEFAULT[i];
    var i;
    if (typeof window !== "undefined") {
      window.filterCSS = module2.exports;
    }
  }
});

// node_modules/xss/lib/util.js
var require_util3 = __commonJS({
  "node_modules/xss/lib/util.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {
      indexOf: /* @__PURE__ */ __name(function(arr, item) {
        var i, j;
        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }
        return -1;
      }, "indexOf"),
      forEach: /* @__PURE__ */ __name(function(arr, fn, scope) {
        var i, j;
        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      }, "forEach"),
      trim: /* @__PURE__ */ __name(function(str) {
        if (String.prototype.trim) {
          return str.trim();
        }
        return str.replace(/(^\s*)|(\s*$)/g, "");
      }, "trim"),
      spaceIndex: /* @__PURE__ */ __name(function(str) {
        var reg = /\s|\n|\t/;
        var match = reg.exec(str);
        return match ? match.index : -1;
      }, "spaceIndex")
    };
  }
});

// node_modules/xss/lib/default.js
var require_default3 = __commonJS({
  "node_modules/xss/lib/default.js"(exports2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FilterCSS = require_lib3().FilterCSS;
    var getDefaultCSSWhiteList = require_lib3().getDefaultWhiteList;
    var _ = require_util3();
    function getDefaultWhiteList() {
      return {
        a: ["target", "href", "title"],
        abbr: ["title"],
        address: [],
        area: ["shape", "coords", "href", "alt"],
        article: [],
        aside: [],
        audio: [
          "autoplay",
          "controls",
          "crossorigin",
          "loop",
          "muted",
          "preload",
          "src"
        ],
        b: [],
        bdi: ["dir"],
        bdo: ["dir"],
        big: [],
        blockquote: ["cite"],
        br: [],
        caption: [],
        center: [],
        cite: [],
        code: [],
        col: ["align", "valign", "span", "width"],
        colgroup: ["align", "valign", "span", "width"],
        dd: [],
        del: ["datetime"],
        details: ["open"],
        div: [],
        dl: [],
        dt: [],
        em: [],
        figcaption: [],
        figure: [],
        font: ["color", "size", "face"],
        footer: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        header: [],
        hr: [],
        i: [],
        img: ["src", "alt", "title", "width", "height", "loading"],
        ins: ["datetime"],
        kbd: [],
        li: [],
        mark: [],
        nav: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        section: [],
        small: [],
        span: [],
        sub: [],
        summary: [],
        sup: [],
        strong: [],
        strike: [],
        table: ["width", "border", "align", "valign"],
        tbody: ["align", "valign"],
        td: ["width", "rowspan", "colspan", "align", "valign"],
        tfoot: ["align", "valign"],
        th: ["width", "rowspan", "colspan", "align", "valign"],
        thead: ["align", "valign"],
        tr: ["rowspan", "align", "valign"],
        tt: [],
        u: [],
        ul: [],
        video: [
          "autoplay",
          "controls",
          "crossorigin",
          "loop",
          "muted",
          "playsinline",
          "poster",
          "preload",
          "src",
          "height",
          "width"
        ]
      };
    }
    __name(getDefaultWhiteList, "getDefaultWhiteList");
    var defaultCSSFilter = new FilterCSS();
    function onTag(tag, html, options) {
    }
    __name(onTag, "onTag");
    function onIgnoreTag(tag, html, options) {
    }
    __name(onIgnoreTag, "onIgnoreTag");
    function onTagAttr(tag, name, value) {
    }
    __name(onTagAttr, "onTagAttr");
    function onIgnoreTagAttr(tag, name, value) {
    }
    __name(onIgnoreTagAttr, "onIgnoreTagAttr");
    function escapeHtml(html) {
      return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
    }
    __name(escapeHtml, "escapeHtml");
    function safeAttrValue(tag, name, value, cssFilter) {
      value = friendlyAttrValue(value);
      if (name === "href" || name === "src") {
        value = _.trim(value);
        if (value === "#") return "#";
        if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
          return "";
        }
      } else if (name === "background") {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      } else if (name === "style") {
        REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
          return "";
        }
        REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
          REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
          if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
            return "";
          }
        }
        if (cssFilter !== false) {
          cssFilter = cssFilter || defaultCSSFilter;
          value = cssFilter.process(value);
        }
      }
      value = escapeAttrValue(value);
      return value;
    }
    __name(safeAttrValue, "safeAttrValue");
    var REGEXP_LT = /</g;
    var REGEXP_GT = />/g;
    var REGEXP_QUOTE = /"/g;
    var REGEXP_QUOTE_2 = /&quot;/g;
    var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
    var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
    var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
    var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
    function escapeQuote(str) {
      return str.replace(REGEXP_QUOTE, "&quot;");
    }
    __name(escapeQuote, "escapeQuote");
    function unescapeQuote(str) {
      return str.replace(REGEXP_QUOTE_2, '"');
    }
    __name(unescapeQuote, "unescapeQuote");
    function escapeHtmlEntities(str) {
      return str.replace(REGEXP_ATTR_VALUE_1, /* @__PURE__ */ __name(function replaceUnicode(str2, code) {
        return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
      }, "replaceUnicode"));
    }
    __name(escapeHtmlEntities, "escapeHtmlEntities");
    function escapeDangerHtml5Entities(str) {
      return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
    }
    __name(escapeDangerHtml5Entities, "escapeDangerHtml5Entities");
    function clearNonPrintableCharacter(str) {
      var str2 = "";
      for (var i = 0, len = str.length; i < len; i++) {
        str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
      }
      return _.trim(str2);
    }
    __name(clearNonPrintableCharacter, "clearNonPrintableCharacter");
    function friendlyAttrValue(str) {
      str = unescapeQuote(str);
      str = escapeHtmlEntities(str);
      str = escapeDangerHtml5Entities(str);
      str = clearNonPrintableCharacter(str);
      return str;
    }
    __name(friendlyAttrValue, "friendlyAttrValue");
    function escapeAttrValue(str) {
      str = escapeQuote(str);
      str = escapeHtml(str);
      return str;
    }
    __name(escapeAttrValue, "escapeAttrValue");
    function onIgnoreTagStripAll() {
      return "";
    }
    __name(onIgnoreTagStripAll, "onIgnoreTagStripAll");
    function StripTagBody(tags, next) {
      if (typeof next !== "function") {
        next = /* @__PURE__ */ __name(function() {
        }, "next");
      }
      var isRemoveAllTag = !Array.isArray(tags);
      function isRemoveTag(tag) {
        if (isRemoveAllTag) return true;
        return _.indexOf(tags, tag) !== -1;
      }
      __name(isRemoveTag, "isRemoveTag");
      var removeList = [];
      var posStart = false;
      return {
        onIgnoreTag: /* @__PURE__ */ __name(function(tag, html, options) {
          if (isRemoveTag(tag)) {
            if (options.isClosing) {
              var ret = "[/removed]";
              var end = options.position + ret.length;
              removeList.push([
                posStart !== false ? posStart : options.position,
                end
              ]);
              posStart = false;
              return ret;
            } else {
              if (!posStart) {
                posStart = options.position;
              }
              return "[removed]";
            }
          } else {
            return next(tag, html, options);
          }
        }, "onIgnoreTag"),
        remove: /* @__PURE__ */ __name(function(html) {
          var rethtml = "";
          var lastPos = 0;
          _.forEach(removeList, function(pos) {
            rethtml += html.slice(lastPos, pos[0]);
            lastPos = pos[1];
          });
          rethtml += html.slice(lastPos);
          return rethtml;
        }, "remove")
      };
    }
    __name(StripTagBody, "StripTagBody");
    function stripCommentTag(html) {
      var retHtml = "";
      var lastPos = 0;
      while (lastPos < html.length) {
        var i = html.indexOf("<!--", lastPos);
        if (i === -1) {
          retHtml += html.slice(lastPos);
          break;
        }
        retHtml += html.slice(lastPos, i);
        var j = html.indexOf("-->", i);
        if (j === -1) {
          break;
        }
        lastPos = j + 3;
      }
      return retHtml;
    }
    __name(stripCommentTag, "stripCommentTag");
    function stripBlankChar(html) {
      var chars = html.split("");
      chars = chars.filter(function(char) {
        var c = char.charCodeAt(0);
        if (c === 127) return false;
        if (c <= 31) {
          if (c === 10 || c === 13) return true;
          return false;
        }
        return true;
      });
      return chars.join("");
    }
    __name(stripBlankChar, "stripBlankChar");
    exports2.whiteList = getDefaultWhiteList();
    exports2.getDefaultWhiteList = getDefaultWhiteList;
    exports2.onTag = onTag;
    exports2.onIgnoreTag = onIgnoreTag;
    exports2.onTagAttr = onTagAttr;
    exports2.onIgnoreTagAttr = onIgnoreTagAttr;
    exports2.safeAttrValue = safeAttrValue;
    exports2.escapeHtml = escapeHtml;
    exports2.escapeQuote = escapeQuote;
    exports2.unescapeQuote = unescapeQuote;
    exports2.escapeHtmlEntities = escapeHtmlEntities;
    exports2.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
    exports2.clearNonPrintableCharacter = clearNonPrintableCharacter;
    exports2.friendlyAttrValue = friendlyAttrValue;
    exports2.escapeAttrValue = escapeAttrValue;
    exports2.onIgnoreTagStripAll = onIgnoreTagStripAll;
    exports2.StripTagBody = StripTagBody;
    exports2.stripCommentTag = stripCommentTag;
    exports2.stripBlankChar = stripBlankChar;
    exports2.attributeWrapSign = '"';
    exports2.cssFilter = defaultCSSFilter;
    exports2.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
  }
});

// node_modules/xss/lib/parser.js
var require_parser4 = __commonJS({
  "node_modules/xss/lib/parser.js"(exports2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _ = require_util3();
    function getTagName(html) {
      var i = _.spaceIndex(html);
      var tagName;
      if (i === -1) {
        tagName = html.slice(1, -1);
      } else {
        tagName = html.slice(1, i + 1);
      }
      tagName = _.trim(tagName).toLowerCase();
      if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
      if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
      return tagName;
    }
    __name(getTagName, "getTagName");
    function isClosing(html) {
      return html.slice(0, 2) === "</";
    }
    __name(isClosing, "isClosing");
    function parseTag(html, onTag, escapeHtml) {
      "use strict";
      var rethtml = "";
      var lastPos = 0;
      var tagStart = false;
      var quoteStart = false;
      var currentPos = 0;
      var len = html.length;
      var currentTagName = "";
      var currentHtml = "";
      chariterator: for (currentPos = 0; currentPos < len; currentPos++) {
        var c = html.charAt(currentPos);
        if (tagStart === false) {
          if (c === "<") {
            tagStart = currentPos;
            continue;
          }
        } else {
          if (quoteStart === false) {
            if (c === "<") {
              rethtml += escapeHtml(html.slice(lastPos, currentPos));
              tagStart = currentPos;
              lastPos = currentPos;
              continue;
            }
            if (c === ">" || currentPos === len - 1) {
              rethtml += escapeHtml(html.slice(lastPos, tagStart));
              currentHtml = html.slice(tagStart, currentPos + 1);
              currentTagName = getTagName(currentHtml);
              rethtml += onTag(
                tagStart,
                rethtml.length,
                currentTagName,
                currentHtml,
                isClosing(currentHtml)
              );
              lastPos = currentPos + 1;
              tagStart = false;
              continue;
            }
            if (c === '"' || c === "'") {
              var i = 1;
              var ic = html.charAt(currentPos - i);
              while (ic.trim() === "" || ic === "=") {
                if (ic === "=") {
                  quoteStart = c;
                  continue chariterator;
                }
                ic = html.charAt(currentPos - ++i);
              }
            }
          } else {
            if (c === quoteStart) {
              quoteStart = false;
              continue;
            }
          }
        }
      }
      if (lastPos < len) {
        rethtml += escapeHtml(html.substr(lastPos));
      }
      return rethtml;
    }
    __name(parseTag, "parseTag");
    var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
    function parseAttr(html, onAttr) {
      "use strict";
      var lastPos = 0;
      var lastMarkPos = 0;
      var retAttrs = [];
      var tmpName = false;
      var len = html.length;
      function addAttr(name, value) {
        name = _.trim(name);
        name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
        if (name.length < 1) return;
        var ret = onAttr(name, value || "");
        if (ret) retAttrs.push(ret);
      }
      __name(addAttr, "addAttr");
      for (var i = 0; i < len; i++) {
        var c = html.charAt(i);
        var v, j;
        if (tmpName === false && c === "=") {
          tmpName = html.slice(lastPos, i);
          lastPos = i + 1;
          lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i + 1);
          continue;
        }
        if (tmpName !== false) {
          if (i === lastMarkPos) {
            j = html.indexOf(c, i + 1);
            if (j === -1) {
              break;
            } else {
              v = _.trim(html.slice(lastMarkPos + 1, j));
              addAttr(tmpName, v);
              tmpName = false;
              i = j;
              lastPos = i + 1;
              continue;
            }
          }
        }
        if (/\s|\n|\t/.test(c)) {
          html = html.replace(/\s|\n|\t/g, " ");
          if (tmpName === false) {
            j = findNextEqual(html, i);
            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              addAttr(v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              i = j - 1;
              continue;
            }
          } else {
            j = findBeforeEqual(html, i - 1);
            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              v = stripQuoteWrap(v);
              addAttr(tmpName, v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              continue;
            }
          }
        }
      }
      if (lastPos < html.length) {
        if (tmpName === false) {
          addAttr(html.slice(lastPos));
        } else {
          addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));
        }
      }
      return _.trim(retAttrs.join(" "));
    }
    __name(parseAttr, "parseAttr");
    function findNextEqual(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ") continue;
        if (c === "=") return i;
        return -1;
      }
    }
    __name(findNextEqual, "findNextEqual");
    function findNextQuotationMark(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ") continue;
        if (c === "'" || c === '"') return i;
        return -1;
      }
    }
    __name(findNextQuotationMark, "findNextQuotationMark");
    function findBeforeEqual(str, i) {
      for (; i > 0; i--) {
        var c = str[i];
        if (c === " ") continue;
        if (c === "=") return i;
        return -1;
      }
    }
    __name(findBeforeEqual, "findBeforeEqual");
    function isQuoteWrapString(text) {
      if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
        return true;
      } else {
        return false;
      }
    }
    __name(isQuoteWrapString, "isQuoteWrapString");
    function stripQuoteWrap(text) {
      if (isQuoteWrapString(text)) {
        return text.substr(1, text.length - 2);
      } else {
        return text;
      }
    }
    __name(stripQuoteWrap, "stripQuoteWrap");
    exports2.parseTag = parseTag;
    exports2.parseAttr = parseAttr;
  }
});

// node_modules/xss/lib/xss.js
var require_xss = __commonJS({
  "node_modules/xss/lib/xss.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FilterCSS = require_lib3().FilterCSS;
    var DEFAULT = require_default3();
    var parser = require_parser4();
    var parseTag = parser.parseTag;
    var parseAttr = parser.parseAttr;
    var _ = require_util3();
    function isNull2(obj) {
      return obj === void 0 || obj === null;
    }
    __name(isNull2, "isNull");
    function getAttrs(html) {
      var i = _.spaceIndex(html);
      if (i === -1) {
        return {
          html: "",
          closing: html[html.length - 2] === "/"
        };
      }
      html = _.trim(html.slice(i + 1, -1));
      var isClosing = html[html.length - 1] === "/";
      if (isClosing) html = _.trim(html.slice(0, -1));
      return {
        html,
        closing: isClosing
      };
    }
    __name(getAttrs, "getAttrs");
    function shallowCopyObject(obj) {
      var ret = {};
      for (var i in obj) {
        ret[i] = obj[i];
      }
      return ret;
    }
    __name(shallowCopyObject, "shallowCopyObject");
    function keysToLowerCase(obj) {
      var ret = {};
      for (var i in obj) {
        if (Array.isArray(obj[i])) {
          ret[i.toLowerCase()] = obj[i].map(function(item) {
            return item.toLowerCase();
          });
        } else {
          ret[i.toLowerCase()] = obj[i];
        }
      }
      return ret;
    }
    __name(keysToLowerCase, "keysToLowerCase");
    function FilterXSS(options) {
      options = shallowCopyObject(options || {});
      if (options.stripIgnoreTag) {
        if (options.onIgnoreTag) {
          console.error(
            'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
          );
        }
        options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
      }
      if (options.whiteList || options.allowList) {
        options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
      } else {
        options.whiteList = DEFAULT.whiteList;
      }
      this.attributeWrapSign = options.singleQuotedAttributeValue === true ? "'" : DEFAULT.attributeWrapSign;
      options.onTag = options.onTag || DEFAULT.onTag;
      options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
      options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
      options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
      this.options = options;
      if (options.css === false) {
        this.cssFilter = false;
      } else {
        options.css = options.css || {};
        this.cssFilter = new FilterCSS(options.css);
      }
    }
    __name(FilterXSS, "FilterXSS");
    FilterXSS.prototype.process = function(html) {
      html = html || "";
      html = html.toString();
      if (!html) return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onTag = options.onTag;
      var onIgnoreTag = options.onIgnoreTag;
      var onTagAttr = options.onTagAttr;
      var onIgnoreTagAttr = options.onIgnoreTagAttr;
      var safeAttrValue = options.safeAttrValue;
      var escapeHtml = options.escapeHtml;
      var attributeWrapSign = me.attributeWrapSign;
      var cssFilter = me.cssFilter;
      if (options.stripBlankChar) {
        html = DEFAULT.stripBlankChar(html);
      }
      if (!options.allowCommentTag) {
        html = DEFAULT.stripCommentTag(html);
      }
      var stripIgnoreTagBody = false;
      if (options.stripIgnoreTagBody) {
        stripIgnoreTagBody = DEFAULT.StripTagBody(
          options.stripIgnoreTagBody,
          onIgnoreTag
        );
        onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
      }
      var retHtml = parseTag(
        html,
        function(sourcePosition, position, tag, html2, isClosing) {
          var info3 = {
            sourcePosition,
            position,
            isClosing,
            isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
          };
          var ret = onTag(tag, html2, info3);
          if (!isNull2(ret)) return ret;
          if (info3.isWhite) {
            if (info3.isClosing) {
              return "</" + tag + ">";
            }
            var attrs = getAttrs(html2);
            var whiteAttrList = whiteList[tag];
            var attrsHtml = parseAttr(attrs.html, function(name, value) {
              var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
              var ret2 = onTagAttr(tag, name, value, isWhiteAttr);
              if (!isNull2(ret2)) return ret2;
              if (isWhiteAttr) {
                value = safeAttrValue(tag, name, value, cssFilter);
                if (value) {
                  return name + "=" + attributeWrapSign + value + attributeWrapSign;
                } else {
                  return name;
                }
              } else {
                ret2 = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
                if (!isNull2(ret2)) return ret2;
                return;
              }
            });
            html2 = "<" + tag;
            if (attrsHtml) html2 += " " + attrsHtml;
            if (attrs.closing) html2 += " /";
            html2 += ">";
            return html2;
          } else {
            ret = onIgnoreTag(tag, html2, info3);
            if (!isNull2(ret)) return ret;
            return escapeHtml(html2);
          }
        },
        escapeHtml
      );
      if (stripIgnoreTagBody) {
        retHtml = stripIgnoreTagBody.remove(retHtml);
      }
      return retHtml;
    };
    module2.exports = FilterXSS;
  }
});

// node_modules/xss/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/xss/lib/index.js"(exports2, module2) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DEFAULT = require_default3();
    var parser = require_parser4();
    var FilterXSS = require_xss();
    function filterXSS(html, options) {
      var xss = new FilterXSS(options);
      return xss.process(html);
    }
    __name(filterXSS, "filterXSS");
    exports2 = module2.exports = filterXSS;
    exports2.filterXSS = filterXSS;
    exports2.FilterXSS = FilterXSS;
    (function() {
      for (var i in DEFAULT) {
        exports2[i] = DEFAULT[i];
      }
      for (var j in parser) {
        exports2[j] = parser[j];
      }
    })();
    if (typeof window !== "undefined") {
      window.filterXSS = module2.exports;
    }
    function isWorkerEnv() {
      return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
    }
    __name(isWorkerEnv, "isWorkerEnv");
    if (isWorkerEnv()) {
      self.filterXSS = module2.exports;
    }
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js
var require_get_loading_markup = __commonJS({
  "node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getLoadingMarkup = /* @__PURE__ */ __name(function() {
      return {
        script: "\n    const loadingWrapper = document.getElementById('loading-wrapper');\n    if (loadingWrapper) {\n      loadingWrapper.classList.add('fadeOut');\n    }\n    ",
        container: '\n<style type="text/css">\n.fadeOut {\n  -webkit-animation: fadeOut 0.5s ease-out forwards;\n  animation: fadeOut 0.5s ease-out forwards;\n}\n\n@-webkit-keyframes fadeIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@-webkit-keyframes fadeOut {\n  from {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n  to {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n  to {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n}\n\n@-webkit-keyframes appearIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(0px);\n    -ms-transform: translateY(0px);\n    transform: translateY(0px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@keyframes appearIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(0px);\n    -ms-transform: translateY(0px);\n    transform: translateY(0px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@-webkit-keyframes scaleIn {\n  from {\n    -webkit-transform: scale(0);\n    -ms-transform: scale(0);\n    transform: scale(0);\n  }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1);\n  }\n}\n\n@keyframes scaleIn {\n  from {\n    -webkit-transform: scale(0);\n    -ms-transform: scale(0);\n    transform: scale(0);\n  }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1);\n  }\n}\n\n@-webkit-keyframes innerDrawIn {\n  0% {\n    stroke-dashoffset: 70;\n  }\n  50% {\n    stroke-dashoffset: 140;\n  }\n  100% {\n    stroke-dashoffset: 210;\n  }\n}\n\n@keyframes innerDrawIn {\n  0% {\n    stroke-dashoffset: 70;\n  }\n  50% {\n    stroke-dashoffset: 140;\n  }\n  100% {\n    stroke-dashoffset: 210;\n  }\n}\n\n@-webkit-keyframes outerDrawIn {\n  0% {\n    stroke-dashoffset: 76;\n  }\n  100% {\n    stroke-dashoffset: 152;\n  }\n}\n\n@keyframes outerDrawIn {\n  0% {\n    stroke-dashoffset: 76;\n  }\n  100% {\n    stroke-dashoffset: 152;\n  }\n}\n\n.hHWjkv {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n}\n\n.gCDOzd {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n}\n\n.hmCcxi {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n}\n\n.eHamQi {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n}\n\n.byhgGu {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n}\n\n.llAKP {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n}\n\n.bglIGM {\n  -webkit-transform-origin: 64px 28px;\n  -ms-transform-origin: 64px 28px;\n  transform-origin: 64px 28px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n}\n\n.ksxRII {\n  -webkit-transform-origin: 95.98500061035156px 46.510000228881836px;\n  -ms-transform-origin: 95.98500061035156px 46.510000228881836px;\n  transform-origin: 95.98500061035156px 46.510000228881836px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n}\n\n.cWrBmb {\n  -webkit-transform-origin: 95.97162628173828px 83.4900016784668px;\n  -ms-transform-origin: 95.97162628173828px 83.4900016784668px;\n  transform-origin: 95.97162628173828px 83.4900016784668px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n}\n\n.Wnusb {\n  -webkit-transform-origin: 64px 101.97999572753906px;\n  -ms-transform-origin: 64px 101.97999572753906px;\n  transform-origin: 64px 101.97999572753906px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n}\n\n.bfPqf {\n  -webkit-transform-origin: 32.03982162475586px 83.4900016784668px;\n  -ms-transform-origin: 32.03982162475586px 83.4900016784668px;\n  transform-origin: 32.03982162475586px 83.4900016784668px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n}\n\n.edRCTN {\n  -webkit-transform-origin: 32.033552169799805px 46.510000228881836px;\n  -ms-transform-origin: 32.033552169799805px 46.510000228881836px;\n  transform-origin: 32.033552169799805px 46.510000228881836px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n}\n\n.iEGVWn {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.bsocdx {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.jAZXmP {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.hSeArx {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.bVgqGk {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.hEFqBt {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.dzEKCM {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n.DYnPx {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n.hjPEAQ {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n#loading-wrapper {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n\n.logo {\n  width: 75px;\n  height: 75px;\n  margin-bottom: 20px;\n  opacity: 0;\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\n  animation: fadeIn 0.5s ease-out forwards;\n}\n\n.text {\n  font-size: 32px;\n  font-weight: 200;\n  text-align: center;\n  color: rgba(255, 255, 255, 0.6);\n  opacity: 0;\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\n  animation: fadeIn 0.5s ease-out forwards;\n}\n\n.dGfHfc {\n  font-weight: 400;\n}\n</style>\n<div id="loading-wrapper">\n<svg class="logo" viewBox="0 0 128 128" xmlns:xlink="http://www.w3.org/1999/xlink">\n  <title>GraphQL Playground Logo</title>\n  <defs>\n    <linearGradient id="linearGradient-1" x1="4.86%" x2="96.21%" y1="0%" y2="99.66%">\n      <stop stop-color="#E00082" stop-opacity=".8" offset="0%"></stop>\n      <stop stop-color="#E00082" offset="100%"></stop>\n    </linearGradient>\n  </defs>\n  <g>\n    <rect id="Gradient" width="127.96" height="127.96" y="1" fill="url(#linearGradient-1)" rx="4"></rect>\n    <path id="Border" fill="#E00082" fill-rule="nonzero" d="M4.7 2.84c-1.58 0-2.86 1.28-2.86 2.85v116.57c0 1.57 1.28 2.84 2.85 2.84h116.57c1.57 0 2.84-1.26 2.84-2.83V5.67c0-1.55-1.26-2.83-2.83-2.83H4.67zM4.7 0h116.58c3.14 0 5.68 2.55 5.68 5.7v116.58c0 3.14-2.54 5.68-5.68 5.68H4.68c-3.13 0-5.68-2.54-5.68-5.68V5.68C-1 2.56 1.55 0 4.7 0z"></path>\n    <path class="bglIGM" x="64" y="28" fill="#fff" d="M64 36c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8" style="transform: translate(100px, 100px);"></path>\n    <path class="ksxRII" x="95.98500061035156" y="46.510000228881836" fill="#fff" d="M89.04 50.52c-2.2-3.84-.9-8.73 2.94-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.76.9-10.97-2.94"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="cWrBmb" x="95.97162628173828" y="83.4900016784668" fill="#fff" d="M102.9 87.5c-2.2 3.84-7.1 5.15-10.94 2.94-3.84-2.2-5.14-7.12-2.94-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.86 2.23 5.16 7.12 2.94 10.96"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="Wnusb" x="64" y="101.97999572753906" fill="#fff" d="M64 110c-4.43 0-8-3.6-8-8.02 0-4.44 3.57-8.02 8-8.02s8 3.58 8 8.02c0 4.4-3.57 8.02-8 8.02"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="bfPqf" x="32.03982162475586" y="83.4900016784668" fill="#fff" d="M25.1 87.5c-2.2-3.84-.9-8.73 2.93-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.74.9-10.95-2.94"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="edRCTN" x="32.033552169799805" y="46.510000228881836" fill="#fff" d="M38.96 50.52c-2.2 3.84-7.12 5.15-10.95 2.94-3.82-2.2-5.12-7.12-2.92-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.83 2.23 5.14 7.12 2.94 10.96"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="iEGVWn" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M63.55 27.5l32.9 19-32.9-19z"></path>\n    <path class="bsocdx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96 46v38-38z"></path>\n    <path class="jAZXmP" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96.45 84.5l-32.9 19 32.9-19z"></path>\n    <path class="hSeArx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M64.45 103.5l-32.9-19 32.9 19z"></path>\n    <path class="bVgqGk" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M32 84V46v38z"></path>\n    <path class="hEFqBt" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M31.55 46.5l32.9-19-32.9 19z"></path>\n    <path class="dzEKCM" id="Triangle-Bottom" stroke="#fff" stroke-width="4" d="M30 84h70" stroke-linecap="round"></path>\n    <path class="DYnPx" id="Triangle-Left" stroke="#fff" stroke-width="4" d="M65 26L30 87" stroke-linecap="round"></path>\n    <path class="hjPEAQ" id="Triangle-Right" stroke="#fff" stroke-width="4" d="M98 87L63 26" stroke-linecap="round"></path>\n  </g>\n</svg>\n<div class="text">Loading\n  <span class="dGfHfc">GraphQL Playground</span>\n</div>\n</div>\n'
      };
    }, "getLoadingMarkup");
    exports2.default = getLoadingMarkup;
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js
var require_render_playground_page = __commonJS({
  "node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renderPlaygroundPage = void 0;
    var xss_1 = require_lib4();
    var get_loading_markup_1 = require_get_loading_markup();
    var filter = /* @__PURE__ */ __name(function(val) {
      return xss_1.filterXSS(val, {
        // @ts-ignore
        whiteList: [],
        stripIgnoreTag: true,
        stripIgnoreTagBody: ["script"]
      });
    }, "filter");
    var loading = get_loading_markup_1.default();
    var reactPackageName = "@apollographql/graphql-playground-react";
    var getCdnMarkup = /* @__PURE__ */ __name(function(_a) {
      var version3 = _a.version, _b = _a.cdnUrl, cdnUrl = _b === void 0 ? "//cdn.jsdelivr.net/npm" : _b, faviconUrl = _a.faviconUrl;
      var buildCDNUrl = /* @__PURE__ */ __name(function(packageName, suffix) {
        return filter(cdnUrl + "/" + packageName + (version3 ? "@" + version3 : "") + "/" + suffix || "");
      }, "buildCDNUrl");
      return '\n    <link\n      rel="stylesheet"\n      href="' + buildCDNUrl(reactPackageName, "build/static/css/index.css") + '"\n    />\n    ' + (typeof faviconUrl === "string" ? '<link rel="shortcut icon" href="' + filter(faviconUrl || "") + '" />' : "") + "\n    " + (faviconUrl === void 0 ? '<link rel="shortcut icon" href="' + buildCDNUrl(reactPackageName, "build/favicon.png") + '" />' : "") + '\n    <script\n      src="' + buildCDNUrl(reactPackageName, "build/static/js/middleware.js") + '"\n    ><\/script>\n';
    }, "getCdnMarkup");
    var renderConfig = /* @__PURE__ */ __name(function(config2) {
      return '<div id="playground-config" style="display: none;">' + xss_1.filterXSS(JSON.stringify(config2), {
        // @ts-ignore
        whiteList: []
      }) + "</div>";
    }, "renderConfig");
    function renderPlaygroundPage(options) {
      var extendedOptions = __assign(__assign({}, options), { canSaveConfig: false });
      if (options.subscriptionsEndpoint) {
        extendedOptions.subscriptionEndpoint = filter(options.subscriptionsEndpoint || "");
      }
      if (options.config) {
        extendedOptions.configString = JSON.stringify(options.config, null, 2);
      }
      if (extendedOptions.endpoint) {
        extendedOptions.endpoint = filter(extendedOptions.endpoint || "");
      }
      return '\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <meta charset=utf-8 />\n    <meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">\n    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|Source+Code+Pro:400,700" rel="stylesheet">\n    <title>' + (filter(extendedOptions.title) || "GraphQL Playground") + "</title>\n    " + (extendedOptions.env === "react" || extendedOptions.env === "electron" ? "" : getCdnMarkup(extendedOptions)) + '\n  </head>\n  <body>\n    <style type="text/css">\n      html {\n        font-family: "Open Sans", sans-serif;\n        overflow: hidden;\n      }\n  \n      body {\n        margin: 0;\n        background: #172a3a;\n      }\n  \n      .playgroundIn {\n        -webkit-animation: playgroundIn 0.5s ease-out forwards;\n        animation: playgroundIn 0.5s ease-out forwards;\n      }\n  \n      @-webkit-keyframes playgroundIn {\n        from {\n          opacity: 0;\n          -webkit-transform: translateY(10px);\n          -ms-transform: translateY(10px);\n          transform: translateY(10px);\n        }\n        to {\n          opacity: 1;\n          -webkit-transform: translateY(0);\n          -ms-transform: translateY(0);\n          transform: translateY(0);\n        }\n      }\n  \n      @keyframes playgroundIn {\n        from {\n          opacity: 0;\n          -webkit-transform: translateY(10px);\n          -ms-transform: translateY(10px);\n          transform: translateY(10px);\n        }\n        to {\n          opacity: 1;\n          -webkit-transform: translateY(0);\n          -ms-transform: translateY(0);\n          transform: translateY(0);\n        }\n      }\n    </style>\n    ' + loading.container + "\n    " + renderConfig(extendedOptions) + `
    <div id="root" />
    <script type="text/javascript">
      window.addEventListener('load', function (event) {
        ` + loading.script + `
  
        const root = document.getElementById('root');
        root.classList.add('playgroundIn');
        const configText = document.getElementById('playground-config').innerText
        if(configText && configText.length) {
          try {
            GraphQLPlayground.init(root, JSON.parse(configText))
          }
          catch(err) {
            console.error("could not find config")
          }
        }
      })
    <\/script>
  </body>
  </html>
`;
    }
    __name(renderPlaygroundPage, "renderPlaygroundPage");
    exports2.renderPlaygroundPage = renderPlaygroundPage;
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@apollographql/graphql-playground-html/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var render_playground_page_1 = require_render_playground_page();
    Object.defineProperty(exports2, "renderPlaygroundPage", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return render_playground_page_1.renderPlaygroundPage;
    }, "get") });
  }
});

// node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js
var require_graphqlPlayground = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = void 0;
    var graphql_playground_html_1 = require_dist10();
    var defaultPlaygroundVersion = "1.7.42";
    function ApolloServerPluginLandingPageGraphQLPlayground(options = /* @__PURE__ */ Object.create(null)) {
      return {
        async serverWillStart() {
          return {
            async renderLandingPage() {
              return {
                html: (0, graphql_playground_html_1.renderPlaygroundPage)({
                  version: defaultPlaygroundVersion,
                  ...options
                })
              };
            }
          };
        }
      };
    }
    __name(ApolloServerPluginLandingPageGraphQLPlayground, "ApolloServerPluginLandingPageGraphQLPlayground");
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
  }
});

// node_modules/apollo-server-core/dist/plugin/index.js
var require_plugin2 = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = exports2.ApolloServerPluginLandingPageProductionDefault = exports2.ApolloServerPluginLandingPageLocalDefault = exports2.ApolloServerPluginLandingPageDisabled = exports2.ApolloServerPluginDrainHttpServer = exports2.ApolloServerPluginCacheControlDisabled = exports2.ApolloServerPluginCacheControl = exports2.ApolloServerPluginInlineTraceDisabled = exports2.ApolloServerPluginInlineTrace = exports2.ApolloServerPluginSchemaReporting = exports2.ApolloServerPluginUsageReportingDisabled = exports2.ApolloServerPluginUsageReporting = void 0;
    function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
      return require_usageReporting().ApolloServerPluginUsageReporting(options);
    }
    __name(ApolloServerPluginUsageReporting, "ApolloServerPluginUsageReporting");
    exports2.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
    function ApolloServerPluginUsageReportingDisabled() {
      return require_usageReporting().ApolloServerPluginUsageReportingDisabled();
    }
    __name(ApolloServerPluginUsageReportingDisabled, "ApolloServerPluginUsageReportingDisabled");
    exports2.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
    function ApolloServerPluginSchemaReporting(options = /* @__PURE__ */ Object.create(null)) {
      return require_schemaReporting().ApolloServerPluginSchemaReporting(options);
    }
    __name(ApolloServerPluginSchemaReporting, "ApolloServerPluginSchemaReporting");
    exports2.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
    function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
      return require_inlineTrace().ApolloServerPluginInlineTrace(options);
    }
    __name(ApolloServerPluginInlineTrace, "ApolloServerPluginInlineTrace");
    exports2.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
    function ApolloServerPluginInlineTraceDisabled() {
      return require_inlineTrace().ApolloServerPluginInlineTraceDisabled();
    }
    __name(ApolloServerPluginInlineTraceDisabled, "ApolloServerPluginInlineTraceDisabled");
    exports2.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
    function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
      return require_cacheControl().ApolloServerPluginCacheControl(options);
    }
    __name(ApolloServerPluginCacheControl, "ApolloServerPluginCacheControl");
    exports2.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
    function ApolloServerPluginCacheControlDisabled() {
      return require_cacheControl().ApolloServerPluginCacheControlDisabled();
    }
    __name(ApolloServerPluginCacheControlDisabled, "ApolloServerPluginCacheControlDisabled");
    exports2.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
    function ApolloServerPluginDrainHttpServer(options) {
      return require_drainHttpServer().ApolloServerPluginDrainHttpServer(options);
    }
    __name(ApolloServerPluginDrainHttpServer, "ApolloServerPluginDrainHttpServer");
    exports2.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
    function ApolloServerPluginLandingPageDisabled() {
      const plugin = {
        __internal_plugin_id__() {
          return "LandingPageDisabled";
        }
      };
      return plugin;
    }
    __name(ApolloServerPluginLandingPageDisabled, "ApolloServerPluginLandingPageDisabled");
    exports2.ApolloServerPluginLandingPageDisabled = ApolloServerPluginLandingPageDisabled;
    function ApolloServerPluginLandingPageLocalDefault(options) {
      return require_default().ApolloServerPluginLandingPageLocalDefault(options);
    }
    __name(ApolloServerPluginLandingPageLocalDefault, "ApolloServerPluginLandingPageLocalDefault");
    exports2.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
    function ApolloServerPluginLandingPageProductionDefault(options) {
      return require_default().ApolloServerPluginLandingPageProductionDefault(options);
    }
    __name(ApolloServerPluginLandingPageProductionDefault, "ApolloServerPluginLandingPageProductionDefault");
    exports2.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
    function ApolloServerPluginLandingPageGraphQLPlayground(options = /* @__PURE__ */ Object.create(null)) {
      return require_graphqlPlayground().ApolloServerPluginLandingPageGraphQLPlayground(options);
    }
    __name(ApolloServerPluginLandingPageGraphQLPlayground, "ApolloServerPluginLandingPageGraphQLPlayground");
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
  }
});

// node_modules/apollo-server-core/dist/internalPlugin.js
var require_internalPlugin = __commonJS({
  "node_modules/apollo-server-core/dist/internalPlugin.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pluginIsInternal = void 0;
    function pluginIsInternal(plugin) {
      return "__internal_plugin_id__" in plugin;
    }
    __name(pluginIsInternal, "pluginIsInternal");
    exports2.pluginIsInternal = pluginIsInternal;
  }
});

// node_modules/apollo-server-core/dist/utils/schemaManager.js
var require_schemaManager = __commonJS({
  "node_modules/apollo-server-core/dist/utils/schemaManager.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GatewayIsTooOldError = exports2.SchemaManager = void 0;
    var SchemaManager = class {
      static {
        __name(this, "SchemaManager");
      }
      constructor(options) {
        this.onSchemaLoadOrUpdateListeners = /* @__PURE__ */ new Set();
        this.isStopped = false;
        this.logger = options.logger;
        this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
        if ("gateway" in options) {
          this.modeSpecificState = {
            mode: "gateway",
            gateway: options.gateway,
            apolloConfig: options.apolloConfig
          };
        } else {
          this.modeSpecificState = {
            mode: "schema",
            apiSchema: options.apiSchema,
            schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)
          };
        }
      }
      async start() {
        if (this.modeSpecificState.mode === "gateway") {
          const gateway = this.modeSpecificState.gateway;
          if (gateway.onSchemaLoadOrUpdate) {
            this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate((schemaContext) => {
              this.processSchemaLoadOrUpdateEvent(schemaContext);
            });
          } else if (gateway.onSchemaChange) {
            this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange((apiSchema) => {
              this.processSchemaLoadOrUpdateEvent({ apiSchema });
            });
          } else {
            throw new Error("Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway");
          }
          const config2 = await this.modeSpecificState.gateway.load({
            apollo: this.modeSpecificState.apolloConfig
          });
          if (!this.schemaDerivedData) {
            this.processSchemaLoadOrUpdateEvent({ apiSchema: config2.schema });
          }
          return config2.executor;
        } else {
          this.processSchemaLoadOrUpdateEvent({
            apiSchema: this.modeSpecificState.apiSchema
          }, this.modeSpecificState.schemaDerivedData);
          return null;
        }
      }
      onSchemaLoadOrUpdate(callback) {
        if (this.modeSpecificState.mode === "gateway" && !this.modeSpecificState.gateway.onSchemaLoadOrUpdate) {
          throw new GatewayIsTooOldError([
            `Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`,
            `Please update your version of @apollo/gateway to at least 0.35.0.`
          ].join(" "));
        } else {
          if (!this.schemaContext) {
            throw new Error("You must call start() before onSchemaLoadOrUpdate()");
          }
          if (!this.isStopped) {
            try {
              callback(this.schemaContext);
            } catch (e) {
              throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
            }
          }
          this.onSchemaLoadOrUpdateListeners.add(callback);
        }
        return () => {
          this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
      }
      getSchemaDerivedData() {
        if (!this.schemaDerivedData) {
          throw new Error("You must call start() before getSchemaDerivedData()");
        }
        return this.schemaDerivedData;
      }
      async stop() {
        var _a, _b, _c, _d;
        this.isStopped = true;
        if (this.modeSpecificState.mode === "gateway") {
          (_b = (_a = this.modeSpecificState).unsubscribeFromGateway) === null || _b === void 0 ? void 0 : _b.call(_a);
          await ((_d = (_c = this.modeSpecificState.gateway).stop) === null || _d === void 0 ? void 0 : _d.call(_c));
        }
      }
      processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
        if (!this.isStopped) {
          this.schemaDerivedData = schemaDerivedData !== null && schemaDerivedData !== void 0 ? schemaDerivedData : this.schemaDerivedDataProvider(schemaContext.apiSchema);
          this.schemaContext = schemaContext;
          this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
            try {
              listener(schemaContext);
            } catch (e) {
              this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
              this.logger.error(e);
            }
          });
        }
      }
    };
    exports2.SchemaManager = SchemaManager;
    var GatewayIsTooOldError = class extends Error {
      static {
        __name(this, "GatewayIsTooOldError");
      }
      constructor(message) {
        super(message);
      }
    };
    exports2.GatewayIsTooOldError = GatewayIsTooOldError;
  }
});

// node_modules/apollo-server-core/dist/utils/UnboundedCache.js
var require_UnboundedCache = __commonJS({
  "node_modules/apollo-server-core/dist/utils/UnboundedCache.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnboundedCache = void 0;
    var UnboundedCache = class {
      static {
        __name(this, "UnboundedCache");
      }
      constructor(cache = /* @__PURE__ */ new Map()) {
        this.cache = cache;
      }
      async get(key) {
        const entry = this.cache.get(key);
        if (!entry)
          return void 0;
        if (entry.deadline && entry.deadline <= Date.now()) {
          await this.delete(key);
          return void 0;
        }
        return entry.value;
      }
      async set(key, value, { ttl } = { ttl: null }) {
        this.cache.set(key, {
          value,
          deadline: ttl ? Date.now() + ttl * 1e3 : null
        });
      }
      async delete(key) {
        this.cache.delete(key);
      }
    };
    exports2.UnboundedCache = UnboundedCache;
  }
});

// node_modules/apollo-server-core/dist/ApolloServer.js
var require_ApolloServer = __commonJS({
  "node_modules/apollo-server-core/dist/ApolloServer.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isImplicitlyInstallablePlugin = exports2.ApolloServerBase = void 0;
    var mock_1 = require_cjs4();
    var schema_1 = require_cjs8();
    var loglevel_1 = __importDefault(require_loglevel());
    var graphql_1 = require_graphql2();
    var resolvable_1 = __importDefault(require_resolvable());
    var utils_keyvaluecache_1 = require_dist3();
    var schemaHash_1 = require_schemaHash();
    var requestPipeline_1 = require_requestPipeline();
    var apollo_server_env_1 = require_index_browser();
    var apollo_tools_1 = require_lib();
    var runHttpQuery_1 = require_runHttpQuery();
    var isNodeLike_1 = __importDefault(require_isNodeLike());
    var determineApolloConfig_1 = require_determineApolloConfig();
    var plugin_1 = require_plugin2();
    var internalPlugin_1 = require_internalPlugin();
    var cachePolicy_1 = require_cachePolicy();
    var schemaManager_1 = require_schemaManager();
    var uuid = __importStar(require_commonjs_browser());
    var UnboundedCache_1 = require_UnboundedCache();
    var NoIntrospection = /* @__PURE__ */ __name((context2) => ({
      Field(node) {
        if (node.name.value === "__schema" || node.name.value === "__type") {
          context2.reportError(new graphql_1.GraphQLError("GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production", [node]));
        }
      }
    }), "NoIntrospection");
    var UnreachableCaseError = class extends Error {
      static {
        __name(this, "UnreachableCaseError");
      }
      constructor(val) {
        super(`Unreachable case: ${val}`);
      }
    };
    var recommendedCsrfPreventionRequestHeaders = [
      "x-apollo-operation-name",
      "apollo-require-preflight"
    ];
    var ApolloServerBase = class {
      static {
        __name(this, "ApolloServerBase");
      }
      constructor(config2) {
        var _a, _b;
        this.graphqlPath = "/graphql";
        this.requestOptions = /* @__PURE__ */ Object.create(null);
        this.plugins = [];
        this.toDispose = /* @__PURE__ */ new Set();
        this.toDisposeLast = /* @__PURE__ */ new Set();
        this.drainServers = null;
        this.landingPage = null;
        if (!config2)
          throw new Error("ApolloServer requires options.");
        this.config = {
          ...config2,
          nodeEnv: (_a = config2.nodeEnv) !== null && _a !== void 0 ? _a : "undefined"
        };
        const { context: context2, resolvers: resolvers2, schema, modules, typeDefs: typeDefs2, parseOptions = {}, introspection, plugins, gateway, apollo, stopOnTerminationSignals, mocks, mockEntireSchema, documentStore, csrfPrevention, ...requestOptions } = this.config;
        if (config2.logger) {
          this.logger = config2.logger;
        } else {
          const loglevelLogger = loglevel_1.default.getLogger("apollo-server");
          if (this.config.debug === true) {
            loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
          } else {
            loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
          }
          this.logger = loglevelLogger;
        }
        this.apolloConfig = (0, determineApolloConfig_1.determineApolloConfig)(apollo, this.logger);
        if (gateway && (modules || schema || typeDefs2 || resolvers2)) {
          throw new Error("Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`");
        }
        this.parseOptions = parseOptions;
        this.context = context2;
        this.csrfPreventionRequestHeaders = csrfPrevention === true ? recommendedCsrfPreventionRequestHeaders : csrfPrevention === false ? null : csrfPrevention === void 0 ? null : (_b = csrfPrevention.requestHeaders) !== null && _b !== void 0 ? _b : recommendedCsrfPreventionRequestHeaders;
        const isDev = this.config.nodeEnv !== "production";
        this.stopOnTerminationSignals = typeof stopOnTerminationSignals === "boolean" ? stopOnTerminationSignals : isNodeLike_1.default && this.config.nodeEnv !== "test" && !this.serverlessFramework();
        if (typeof introspection === "boolean" && !introspection || introspection === void 0 && !isDev) {
          const noIntro = [NoIntrospection];
          requestOptions.validationRules = requestOptions.validationRules ? requestOptions.validationRules.concat(noIntro) : noIntro;
        }
        if (requestOptions.cache === "bounded") {
          requestOptions.cache = new utils_keyvaluecache_1.InMemoryLRUCache();
        }
        if (!requestOptions.cache) {
          requestOptions.cache = new UnboundedCache_1.UnboundedCache();
          if (!isDev && (requestOptions.persistedQueries === void 0 || requestOptions.persistedQueries && !requestOptions.persistedQueries.cache)) {
            this.logger.warn('Persisted queries are enabled and are using an unbounded cache. Your server is vulnerable to denial of service attacks via memory exhaustion. Set `cache: "bounded"` or `persistedQueries: false` in your ApolloServer constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.');
          }
        }
        if (requestOptions.persistedQueries !== false) {
          const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || /* @__PURE__ */ Object.create(null);
          requestOptions.persistedQueries = {
            cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
            ...apqOtherOptions
          };
        } else {
          delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        this.ensurePluginInstantiation(plugins, isDev);
        if (gateway) {
          this.state = {
            phase: "initialized",
            schemaManager: new schemaManager_1.SchemaManager({
              gateway,
              apolloConfig: this.apolloConfig,
              schemaDerivedDataProvider: /* @__PURE__ */ __name((schema2) => this.generateSchemaDerivedData(schema2), "schemaDerivedDataProvider"),
              logger: this.logger
            })
          };
        } else {
          this.state = {
            phase: "initialized",
            schemaManager: new schemaManager_1.SchemaManager({
              apiSchema: this.maybeAddMocksToConstructedSchema(this.constructSchema()),
              schemaDerivedDataProvider: /* @__PURE__ */ __name((schema2) => this.generateSchemaDerivedData(schema2), "schemaDerivedDataProvider"),
              logger: this.logger
            })
          };
        }
        if (this.serverlessFramework()) {
          this._start().catch((e) => this.logStartupError(e));
        }
      }
      async start() {
        if (this.serverlessFramework()) {
          throw new Error("When using an ApolloServer subclass from a serverless framework package, you don't need to call start(); just call createHandler().");
        }
        return await this._start();
      }
      async _start() {
        var _a;
        if (this.state.phase !== "initialized") {
          throw new Error(`called start() with surprising state ${this.state.phase}`);
        }
        const schemaManager = this.state.schemaManager;
        const barrier = (0, resolvable_1.default)();
        this.state = {
          phase: "starting",
          barrier,
          schemaManager
        };
        try {
          const executor = await schemaManager.start();
          this.toDispose.add(async () => {
            await schemaManager.stop();
          });
          if (executor) {
            this.requestOptions.executor = executor;
          }
          const schemaDerivedData = schemaManager.getSchemaDerivedData();
          const service = {
            logger: this.logger,
            schema: schemaDerivedData.schema,
            schemaHash: schemaDerivedData.schemaHash,
            apollo: this.apolloConfig,
            serverlessFramework: this.serverlessFramework()
          };
          if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {
            service.persistedQueries = {
              cache: this.requestOptions.persistedQueries.cache
            };
          }
          const taggedServerListeners = (await Promise.all(this.plugins.map(async (plugin) => ({
            serverListener: plugin.serverWillStart && await plugin.serverWillStart(service),
            installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__
          })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === "object");
          taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
            if (schemaDidLoadOrUpdate) {
              try {
                schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
              } catch (e) {
                if (e instanceof schemaManager_1.GatewayIsTooOldError) {
                  throw new Error([
                    `One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`,
                    `but your gateway version is too old to support this hook.`,
                    `Please update your version of @apollo/gateway to at least 0.35.0.`
                  ].join(" "));
                }
                throw e;
              }
            }
          });
          const serverWillStops = taggedServerListeners.flatMap((l) => l.serverListener.serverWillStop ? [l.serverListener.serverWillStop] : []);
          if (serverWillStops.length) {
            this.toDispose.add(async () => {
              await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
            });
          }
          const drainServerCallbacks = taggedServerListeners.flatMap((l) => l.serverListener.drainServer ? [l.serverListener.drainServer] : []);
          if (drainServerCallbacks.length) {
            this.drainServers = async () => {
              await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
            };
          }
          let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
          if (taggedServerListenersWithRenderLandingPage.length > 1) {
            taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
          }
          if (taggedServerListenersWithRenderLandingPage.length > 1) {
            throw Error("Only one plugin can implement renderLandingPage.");
          } else if (taggedServerListenersWithRenderLandingPage.length) {
            this.landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();
          } else {
            this.landingPage = null;
          }
          this.state = {
            phase: "started",
            schemaManager
          };
          this.maybeRegisterTerminationSignalHandlers(["SIGINT", "SIGTERM"]);
        } catch (error3) {
          this.state = { phase: "failed to start", error: error3 };
          throw error3;
        } finally {
          barrier.resolve();
        }
      }
      maybeRegisterTerminationSignalHandlers(signals2) {
        if (!this.stopOnTerminationSignals) {
          return;
        }
        let receivedSignal = false;
        const signalHandler = /* @__PURE__ */ __name(async (signal) => {
          if (receivedSignal) {
            return;
          }
          receivedSignal = true;
          try {
            await this.stop();
          } catch (e) {
            this.logger.error(`stop() threw during ${signal} shutdown`);
            this.logger.error(e);
            process.exit(1);
          }
          process.kill(process.pid, signal);
        }, "signalHandler");
        signals2.forEach((signal) => {
          process.on(signal, signalHandler);
          this.toDisposeLast.add(async () => {
            process.removeListener(signal, signalHandler);
          });
        });
      }
      async _ensureStarted() {
        while (true) {
          switch (this.state.phase) {
            case "initialized":
              throw new Error("You need to call `server.start()` before using your Apollo Server.");
            case "starting":
              await this.state.barrier;
              break;
            case "failed to start":
              this.logStartupError(this.state.error);
              throw new Error("This data graph is missing a valid configuration. More details may be available in the server logs.");
            case "started":
            case "draining":
              return this.state.schemaManager.getSchemaDerivedData();
            case "stopping":
              throw new Error("Cannot execute GraphQL operations while the server is stopping.");
            case "stopped":
              throw new Error("Cannot execute GraphQL operations after the server has stopped.");
            default:
              throw new UnreachableCaseError(this.state);
          }
        }
      }
      async ensureStarted() {
        await this._ensureStarted();
      }
      assertStarted(methodName) {
        if (this.state.phase !== "started" && this.state.phase !== "draining") {
          throw new Error("You must `await server.start()` before calling `server." + methodName + "()`");
        }
      }
      logStartupError(err) {
        this.logger.error("An error occurred during Apollo Server startup. All GraphQL requests will now fail. The startup error was: " + ((err === null || err === void 0 ? void 0 : err.message) || err));
      }
      constructSchema() {
        const { schema, modules, typeDefs: typeDefs2, resolvers: resolvers2, parseOptions } = this.config;
        if (schema) {
          return schema;
        }
        if (modules) {
          const { schema: schema2, errors } = (0, apollo_tools_1.buildServiceDefinition)(modules);
          if (errors && errors.length > 0) {
            throw new Error(errors.map((error3) => error3.message).join("\n\n"));
          }
          return schema2;
        }
        if (!typeDefs2) {
          throw Error("Apollo Server requires either an existing schema, modules or typeDefs");
        }
        const augmentedTypeDefs = Array.isArray(typeDefs2) ? typeDefs2 : [typeDefs2];
        return (0, schema_1.makeExecutableSchema)({
          typeDefs: augmentedTypeDefs,
          resolvers: resolvers2,
          parseOptions
        });
      }
      maybeAddMocksToConstructedSchema(schema) {
        const { mocks, mockEntireSchema } = this.config;
        if (mocks === false) {
          return schema;
        }
        if (!mocks && typeof mockEntireSchema === "undefined") {
          return schema;
        }
        return (0, mock_1.addMocksToSchema)({
          schema,
          mocks: mocks === true || typeof mocks === "undefined" ? {} : mocks,
          preserveResolvers: typeof mockEntireSchema === "undefined" ? false : !mockEntireSchema
        });
      }
      generateSchemaDerivedData(schema) {
        const schemaHash = (0, schemaHash_1.generateSchemaHash)(schema);
        return {
          schema,
          schemaHash,
          documentStore: this.config.documentStore === void 0 ? new utils_keyvaluecache_1.InMemoryLRUCache() : this.config.documentStore === null ? null : new utils_keyvaluecache_1.PrefixingKeyValueCache(this.config.documentStore, `${uuid.v4()}:`)
        };
      }
      async stop() {
        var _a;
        switch (this.state.phase) {
          case "initialized":
          case "starting":
          case "failed to start":
            throw Error("apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded");
          case "stopped":
            if (this.state.stopError) {
              throw this.state.stopError;
            }
            return;
          case "stopping":
          case "draining": {
            await this.state.barrier;
            const state = this.state;
            if (state.phase !== "stopped") {
              throw Error(`Surprising post-stopping state ${state.phase}`);
            }
            if (state.stopError) {
              throw state.stopError;
            }
            return;
          }
          case "started":
            break;
          default:
            throw new UnreachableCaseError(this.state);
        }
        const barrier = (0, resolvable_1.default)();
        this.state = {
          phase: "draining",
          schemaManager: this.state.schemaManager,
          barrier
        };
        try {
          await ((_a = this.drainServers) === null || _a === void 0 ? void 0 : _a.call(this));
          this.state = { phase: "stopping", barrier };
          await Promise.all([...this.toDispose].map((dispose) => dispose()));
          await Promise.all([...this.toDisposeLast].map((dispose) => dispose()));
        } catch (stopError) {
          this.state = { phase: "stopped", stopError };
          barrier.resolve();
          throw stopError;
        }
        this.state = { phase: "stopped", stopError: null };
      }
      serverlessFramework() {
        return false;
      }
      ensurePluginInstantiation(userPlugins = [], isDev) {
        this.plugins = userPlugins.map((plugin) => {
          if (typeof plugin === "function") {
            return plugin();
          }
          return plugin;
        });
        const alreadyHavePluginWithInternalId = /* @__PURE__ */ __name((id) => this.plugins.some((p) => (0, internalPlugin_1.pluginIsInternal)(p) && p.__internal_plugin_id__() === id), "alreadyHavePluginWithInternalId");
        {
          if (!alreadyHavePluginWithInternalId("CacheControl")) {
            this.plugins.push((0, plugin_1.ApolloServerPluginCacheControl)());
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("UsageReporting");
          if (!alreadyHavePlugin2 && this.apolloConfig.key) {
            if (this.apolloConfig.graphRef) {
              this.plugins.unshift((0, plugin_1.ApolloServerPluginUsageReporting)());
            } else {
              this.logger.warn("You have specified an Apollo key but have not specified a graph ref; usage reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` environment variable to `your-graph-id@your-graph-variant`. To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.");
            }
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("SchemaReporting");
          const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === "true";
          if (!alreadyHavePlugin2 && enabledViaEnvVar) {
            if (this.apolloConfig.key) {
              const options = {};
              this.plugins.push((0, plugin_1.ApolloServerPluginSchemaReporting)(options));
            } else {
              throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING environment variable to true, but you also need to provide your Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})");
            }
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("InlineTrace");
          if (!alreadyHavePlugin2) {
            this.plugins.push((0, plugin_1.ApolloServerPluginInlineTrace)({ __onlyIfSchemaIsFederated: true }));
          }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId("LandingPageDisabled");
        if (!alreadyHavePlugin) {
          const plugin = isDev ? (0, plugin_1.ApolloServerPluginLandingPageLocalDefault)() : (0, plugin_1.ApolloServerPluginLandingPageProductionDefault)();
          if (!isImplicitlyInstallablePlugin(plugin)) {
            throw Error("default landing page plugin should be implicitly installable?");
          }
          plugin.__internal_installed_implicitly__ = true;
          this.plugins.push(plugin);
        }
      }
      async graphQLServerOptions(integrationContextArgument) {
        const { schema, schemaHash, documentStore } = await this._ensureStarted();
        let context2 = this.context ? this.context : {};
        try {
          context2 = typeof this.context === "function" ? await this.context(integrationContextArgument || {}) : context2;
        } catch (error3) {
          context2 = /* @__PURE__ */ __name(() => {
            throw error3;
          }, "context");
        }
        return {
          schema,
          schemaHash,
          logger: this.logger,
          plugins: this.plugins,
          documentStore,
          dangerouslyDisableValidation: this.config.dangerouslyDisableValidation,
          context: context2,
          parseOptions: this.parseOptions,
          ...this.requestOptions
        };
      }
      async executeOperation(request2, integrationContextArgument) {
        if (this.state.phase === "initialized") {
          await this._start();
        }
        const options = await this.graphQLServerOptions(integrationContextArgument);
        if (typeof options.context === "function") {
          options.context = options.context();
        } else if (typeof options.context === "object") {
          options.context = (0, runHttpQuery_1.cloneObject)(options.context);
        }
        const requestCtx = {
          logger: this.logger,
          schema: options.schema,
          schemaHash: options.schemaHash,
          request: {
            ...request2,
            query: request2.query && typeof request2.query !== "string" ? (0, graphql_1.print)(request2.query) : request2.query
          },
          context: options.context || /* @__PURE__ */ Object.create(null),
          cache: options.cache,
          metrics: {},
          response: {
            http: {
              headers: new apollo_server_env_1.Headers()
            }
          },
          debug: options.debug,
          overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
          requestIsBatched: false
        };
        return (0, requestPipeline_1.processGraphQLRequest)(options, requestCtx);
      }
      getLandingPage() {
        this.assertStarted("getLandingPage");
        return this.landingPage;
      }
    };
    exports2.ApolloServerBase = ApolloServerBase;
    function isImplicitlyInstallablePlugin(p) {
      return "__internal_installed_implicitly__" in p;
    }
    __name(isImplicitlyInstallablePlugin, "isImplicitlyInstallablePlugin");
    exports2.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;
  }
});

// node_modules/apollo-server-core/dist/types.js
var require_types7 = __commonJS({
  "node_modules/apollo-server-core/dist/types.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/apollo-server-core/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/apollo-server-core/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerBase = exports2.convertNodeHttpToRequest = exports2.formatApolloErrors = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.toApolloError = exports2.ApolloError = exports2.resolveGraphqlOptions = exports2.isHttpQueryError = exports2.HttpQueryError = exports2.runHttpQuery = void 0;
    var runHttpQuery_1 = require_runHttpQuery();
    Object.defineProperty(exports2, "runHttpQuery", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return runHttpQuery_1.runHttpQuery;
    }, "get") });
    Object.defineProperty(exports2, "HttpQueryError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return runHttpQuery_1.HttpQueryError;
    }, "get") });
    Object.defineProperty(exports2, "isHttpQueryError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return runHttpQuery_1.isHttpQueryError;
    }, "get") });
    var graphqlOptions_1 = require_graphqlOptions();
    Object.defineProperty(exports2, "resolveGraphqlOptions", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return graphqlOptions_1.resolveGraphqlOptions;
    }, "get") });
    var apollo_server_errors_1 = require_dist();
    Object.defineProperty(exports2, "ApolloError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.ApolloError;
    }, "get") });
    Object.defineProperty(exports2, "toApolloError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.toApolloError;
    }, "get") });
    Object.defineProperty(exports2, "SyntaxError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.SyntaxError;
    }, "get") });
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.ValidationError;
    }, "get") });
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.AuthenticationError;
    }, "get") });
    Object.defineProperty(exports2, "ForbiddenError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.ForbiddenError;
    }, "get") });
    Object.defineProperty(exports2, "UserInputError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.UserInputError;
    }, "get") });
    Object.defineProperty(exports2, "formatApolloErrors", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_errors_1.formatApolloErrors;
    }, "get") });
    var nodeHttpToRequest_1 = require_nodeHttpToRequest();
    Object.defineProperty(exports2, "convertNodeHttpToRequest", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return nodeHttpToRequest_1.convertNodeHttpToRequest;
    }, "get") });
    var ApolloServer_1 = require_ApolloServer();
    Object.defineProperty(exports2, "ApolloServerBase", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ApolloServer_1.ApolloServerBase;
    }, "get") });
    __exportStar(require_types7(), exports2);
    var apollo_server_types_1 = require_dist2();
    __exportStar(require_gql(), exports2);
    __exportStar(require_plugin2(), exports2);
  }
});

// node_modules/apollo-server-cloudflare/dist/cloudflareApollo.js
var require_cloudflareApollo = __commonJS({
  "node_modules/apollo-server-cloudflare/dist/cloudflareApollo.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.graphqlCloudflare = void 0;
    var apollo_server_core_1 = require_dist11();
    var apollo_server_env_1 = require_index_browser();
    function graphqlCloudflare2(options, csrfPreventionRequestHeaders) {
      if (!options) {
        throw new Error("Apollo Server requires options.");
      }
      const graphqlHandler = /* @__PURE__ */ __name(async (req) => {
        const url = new apollo_server_env_1.URL(req.url);
        const query = req.method === "POST" ? await req.json() : {
          query: url.searchParams.get("query"),
          variables: url.searchParams.get("variables"),
          operationName: url.searchParams.get("operationName"),
          extensions: url.searchParams.get("extensions")
        };
        return (0, apollo_server_core_1.runHttpQuery)([req], {
          method: req.method,
          options,
          query,
          request: req
        }, csrfPreventionRequestHeaders).then(({ graphqlResponse, responseInit }) => new apollo_server_env_1.Response(graphqlResponse, responseInit), (error3) => {
          if ("HttpQueryError" !== error3.name)
            throw error3;
          const res = new apollo_server_env_1.Response(error3.message, {
            status: error3.statusCode,
            headers: error3.headers
          });
          return res;
        });
      }, "graphqlHandler");
      return graphqlHandler;
    }
    __name(graphqlCloudflare2, "graphqlCloudflare");
    exports2.graphqlCloudflare = graphqlCloudflare2;
  }
});

// node_modules/apollo-server-cloudflare/dist/ApolloServer.js
var require_ApolloServer2 = __commonJS({
  "node_modules/apollo-server-cloudflare/dist/ApolloServer.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServer = void 0;
    var cloudflareApollo_1 = require_cloudflareApollo();
    var apollo_server_core_1 = require_dist11();
    var apollo_server_core_2 = require_dist11();
    var ApolloServer2 = class extends apollo_server_core_1.ApolloServerBase {
      static {
        __name(this, "ApolloServer");
      }
      async createGraphQLServerOptions(request2) {
        return super.graphQLServerOptions({ request: request2 });
      }
      async listen() {
        this.assertStarted("listen");
        addEventListener("fetch", (event) => {
          event.respondWith((0, cloudflareApollo_1.graphqlCloudflare)(() => {
            return this.createGraphQLServerOptions(event.request);
          }, this.csrfPreventionRequestHeaders)(event.request));
        });
        return await { url: "", port: null };
      }
    };
    exports2.ApolloServer = ApolloServer2;
  }
});

// node_modules/apollo-server-cloudflare/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/apollo-server-cloudflare/dist/index.js"(exports2) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServer = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.toApolloError = exports2.ApolloError = exports2.gql = void 0;
    var apollo_server_core_1 = require_dist11();
    Object.defineProperty(exports2, "gql", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.gql;
    }, "get") });
    Object.defineProperty(exports2, "ApolloError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.ApolloError;
    }, "get") });
    Object.defineProperty(exports2, "toApolloError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.toApolloError;
    }, "get") });
    Object.defineProperty(exports2, "SyntaxError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.SyntaxError;
    }, "get") });
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.ValidationError;
    }, "get") });
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.AuthenticationError;
    }, "get") });
    Object.defineProperty(exports2, "ForbiddenError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.ForbiddenError;
    }, "get") });
    Object.defineProperty(exports2, "UserInputError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return apollo_server_core_1.UserInputError;
    }, "get") });
    var ApolloServer_1 = require_ApolloServer2();
    Object.defineProperty(exports2, "ApolloServer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ApolloServer_1.ApolloServer;
    }, "get") });
  }
});

// .wrangler/tmp/bundle-YuYojL/middleware-loader.entry.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-YuYojL/middleware-insertion-facade.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/graphql.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_apollo_server_cloudflare = __toESM(require_dist12());
var typeDefs = import_apollo_server_cloudflare.gql`
  type Query {
    hello: String
  }
  
  type Mutation {
    generateText(prompt: String!): TextResponse!
  }
  
  type TextResponse {
    text: String!
  }
`;
var resolvers = {
  Query: {
    hello: /* @__PURE__ */ __name(() => "Hello from GraphQL!", "hello")
  },
  Mutation: {
    generateText: /* @__PURE__ */ __name(async (_, { prompt }, { env: env2 }) => {
      try {
        const response = await fetch("https://api.deepseek.com/v1/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${env2.DEEPSEEK_API_KEY}`
          },
          body: JSON.stringify({
            model: "deepseek-chat",
            messages: [
              { role: "user", content: prompt }
            ]
          })
        });
        if (!response.ok) {
          throw new Error(`DeepSeek API error: ${response.status}`);
        }
        const data = await response.json();
        return {
          text: data.choices[0].message.content
        };
      } catch (error3) {
        console.error("Error calling DeepSeek API:", error3);
        throw new Error("Failed to generate text from DeepSeek");
      }
    }, "generateText")
  }
};
function createApolloServer(env2) {
  return new import_apollo_server_cloudflare.ApolloServer({
    typeDefs,
    resolvers,
    introspection: true,
    context: { env: env2 }
  });
}
__name(createApolloServer, "createApolloServer");

// src/index.ts
var import_cloudflareApollo = __toESM(require_cloudflareApollo());
function addCorsHeaders(response) {
  const headers = new Headers(response.headers);
  headers.set("Access-Control-Allow-Origin", "*");
  headers.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  headers.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers
  });
}
__name(addCorsHeaders, "addCorsHeaders");
var src_default = {
  async fetch(request2, env2, ctx) {
    if (request2.method === "OPTIONS") {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
          "Access-Control-Max-Age": "86400"
        }
      });
    }
    const url = new URL(request2.url);
    try {
      if (url.pathname === "/graphql") {
        const server = createApolloServer(env2);
        const response = await (0, import_cloudflareApollo.graphqlCloudflare)(
          () => server.createGraphQLServerOptions(request2)
        )(request2);
        return addCorsHeaders(response);
      } else if (url.pathname === "/") {
        return new Response(
          JSON.stringify({
            message: "GlyphScript API",
            version: "1.0.0",
            endpoints: ["/graphql"],
            status: "operational"
          }),
          {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            },
            status: 200
          }
        );
      }
      return new Response("Not Found", {
        status: 404,
        headers: { "Access-Control-Allow-Origin": "*" }
      });
    } catch (error3) {
      console.error("Server error:", error3);
      return new Response(
        JSON.stringify({ error: "Internal Server Error", message: error3.message }),
        {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        }
      );
    }
  }
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request2, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env2);
  } finally {
    try {
      if (request2.body !== null && !request2.bodyUsed) {
        const reader = request2.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request2, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env2);
  } catch (e) {
    const error3 = reduceError(e);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-YuYojL/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request2, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request2, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request2, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request2, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-YuYojL/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request2, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request2, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request2, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type2, init) {
        if (type2 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request2, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request2, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request2);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type2, init) => {
      if (type2 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request2) {
      return __facade_invoke__(
        request2,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=index.js.map
